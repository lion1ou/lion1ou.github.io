<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux 通过 nvm 安装 Node</title>
      <link href="/2023-09/linux-%E9%80%9A%E8%BF%87-nvm-%E5%AE%89%E8%A3%85-node/"/>
      <url>/2023-09/linux-%E9%80%9A%E8%BF%87-nvm-%E5%AE%89%E8%A3%85-node/</url>
      
        <content type="html"><![CDATA[<p>在 CentOS 7 下，无法安装 Node 18 以上版本，该如何解决？本文给出完整步骤与常见错误的处理。</p><span id="more"></span><h3 id="安装nvm"><a href="#安装nvm" class="headerlink" title="安装nvm"></a>安装nvm</h3><ul><li>下载 压缩文件并解压到指定文件夹</li></ul><pre><code class="bash">sudo chmod 777 /.nvm  # 获取权限cd / # 打开根目录wget https://github.com/nvm-sh/nvm/archive/refs/tags/v0.39.1.tar.gz # 下载文件mkdir -p /.nvm  # 创建nvm文件夹ll -a # 查看目录tar -zxvf v0.39.1.tar.gz -C .nvm  # 解压文件</code></pre><ul><li>修改 .bashrc 文件</li></ul><p><code>vim ~/.bashrc</code></p><pre><code class="bash">export NVM_DIR=&quot;/.nvm/nvm-0.39.1&quot;  # 注意版本号[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot;  # This loads nvm[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \. &quot;$NVM_DIR/bash_completion&quot;  # This loads nvm bash_completion</code></pre><p><code>source ~/.bashrc</code></p><ul><li>验证是否安装成功</li></ul><p><code>nvm ls</code></p><!-- 这是一张图片，ocr 内容为：[15:08:15 LS NVM SYSTEM N/A (DEFAULT) IOJS STABLE (-> N/A) (DEFAULT) NODE N/A(DEFAULT) UNSTABLE --><p><img src="https://cdn.lion1ou.tech/picGo/dcb4662c98521f3e26f0338fd2aeea85_MD5.png">  </p><p>这样就说明安装成功了，然后根据自己的需求安装相应的node</p><ul><li>安装node</li></ul><p><code>nvm install 18</code></p><!-- 这是一张图片，ocr 内容为：[15:35:0 # NVM INSTALL 18 DOWNLOADING AND INSTALLING NODE V18.17.1... DOWNLOADING HTTPS://NODEJS.ORG/DIST/V18.17.1/NODE-V18.17.1-LINUX-X64.TAR.9Z. ##################################################################################################### ##################################################################################################### COMPUTING CHECKSUM WITH SHA256SUM CHECKSUMS MATCHED! NOW USING NODE V18.17.1 (NPM V) 18 CREATING DEFAULT ALIAS:DEFAULT V18.17.1) --><p><img src="https://cdn.lion1ou.tech/picGo/f536a46a63834b90b40be70de3e3ae4c_MD5.png"></p><ul><li>验证是否可用</li></ul><p><code>node -v</code></p><h3 id="安装-C-基础依赖"><a href="#安装-C-基础依赖" class="headerlink" title="安装 C++ 基础依赖"></a>安装 C++ 基础依赖</h3><p>如果根据上面的步骤执行完，可以看到node版本返回，那么就成功了，就不需要看下面的了。</p><p>如果出现下面报错，则需要根据下面步骤解决：</p><!-- 这是一张图片，ocr 内容为：[15:15:02ROOT@FAT-CONCHSERVICE-DC01-026091: # NODE-V LNODE: /IB64/LIBM.SO.6: VERSION (REQUIRED BY NOT FOUND (REQUIRED BY NODE) INODE: /LIB64/LIBC.SO.6: VERSION (GLIBC_25' NOT FOUND (REQUIRED BY NODE) -/LIBC.SO.6: VERSION 'GLIBC_2.28' NOT FOUND (REQUIRED BY NODE) NODE://LIB64/LI NOT FOUND (REQUIRED BY NODE) NODE: /LIB64/LIBSTDC++.SO.6: VERSION 'CXXABI_1.3.9 NOT FOUND (REQUIRED BY NODE) NODE: /LIB64/LIBSTDC++.SO.6:VERSION GLIBCXX_3.4.20 'GLIBCXX_3.4.21' NOT FOUND (REQUIRED BY NODE) INODE:/LIB64/LIBSTDC++.SO.6:VERSION --><p><img src="https://cdn.lion1ou.tech/picGo/be7d854f09e51c7af52a4ad274a40274_MD5.png"></p><p>出现这个报错的原因是：新版的node v18开始 都需要GLIBC_2.28支持，可是目前系统内却没有那么高的版本。</p><h4 id="解决-GLIBC-问题"><a href="#解决-GLIBC-问题" class="headerlink" title="解决 GLIBC 问题"></a>解决 GLIBC 问题</h4><p>可以根据需求在 <a target="_blank" rel="noopener" href="http://ftp.gnu.org/gnu/glibc/">http://ftp.gnu.org/gnu/glibc/</a> ，找到需要的版本，这里使用2.28版本</p><pre><code class="bash">cd /wget http://ftp.gnu.org/gnu/glibc/glibc-2.28.tar.gztar xf glibc-2.28.tar.gz cd glibc-2.28/ &amp;&amp; mkdir build  &amp;&amp; cd build../configure --prefix=/usr --disable-profile --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/bin</code></pre><p>根据上面步骤安装完后，可能会出现以下错误，没出现错误的可以跳过。</p><ul><li>错误1</li></ul><!-- 这是一张图片，ocr 内容为：:/GLIBC-2.28/BUILD] [10:12:27 ../CONFIGURE --WITH-BINUTILS/USR/BIN "USR --DISABLE-PROFILE --ENABLE-ADD-ONS --WITH-HEADERS-/USR/INCLUDE -PREFIX CHECKING BUILD SYSTEM TYPE... X86-64-PC-LINUS PC-LINUX-GNU CHECKING HOST SYSTEM TYPE.. X86_64-PC-LINUX-GNU CHECKING FOR GCC.... NO CHECKING FOR CC.... NO CHECKING FOR CL.EXE... .. NO CONFIGURE:ERROR:IN /GLIBC-2.28/BUILD': CONFIGURE: ERROR: NO ACCEPTABLE C COMPILER FOUND IN $PATH 'CONFIG.LOG''FOR MORE DETAILS SEE --><p><img src="https://cdn.lion1ou.tech/picGo/1d88f011528faad907f9bbef039b825c_MD5.png"></p><p>原因是gcc 不存在，需要安装gcc， <code>yum install gcc</code></p><p>安装后，继续执行上面的命令</p><ul><li>错误2</li></ul><!-- 这是一张图片，ocr 内容为：CHECKING VERSION OF MSGFMT... 0.19.8.1, 0 `1, OK CHECKING FOR MAKEINFO... NO CHECKING FOR SED. SED LON OF SED...4.2.2,OK CHECKING VERSION OF CHECKING FOR GAWK... GAWK CHECKING VE GVERSION OF GAWK....4.0.2,OK FOR  BISON.....NO CHECKING IF GCC -B/USR/BIN/ IS SUFFICIENT TO BUILD LIBC... NO CHECKING CHECKING FOR N NM.. NM CHECKING FOR PYTHON3. PYTHON3 CONFIGURE: ERROR: *** THESE CRITICAL PRE AL PROGRAMS ARE MISSING OR TOO OLD: MAKE BISON COMPILER CHECK THE INSTALL FILE FOR REQUIRED VERSIONS. 水水水 --><p><img src="https://cdn.lion1ou.tech/picGo/7a498c2d533842c3f66e24158c9b3703_MD5.png"></p><p><font style="color:rgb(35, 38, 59);">解决办法：升级gcc与make</font></p><pre><code class="shell"># 升级GCC(默认为4 升级为8)yum install -y centos-release-sclyum install -y devtoolset-8-gccmv /usr/bin/gcc /usr/bin/gcc-4.8.5ln -s /opt/rh/devtoolset-8/root/bin/gcc /usr/bin/gccmv /usr/bin/g++ /usr/bin/g++-4.8.5 # 如果出现不存在，跳过，直接执行下面命令ln -s /opt/rh/devtoolset-8/root/bin/g++ /usr/bin/g++# 升级 make(默认为3 升级为4)cd /wget http://ftp.gnu.org/gnu/make/make-4.3.tar.gztar -xzvf make-4.3.tar.gz &amp;&amp; cd make-4.3/./configure  --prefix=/usr/local/makemake &amp;&amp; make installcd /usr/bin/ &amp;&amp; mv make make.bakln -sv /usr/local/make/bin/make /usr/bin/make</code></pre><p>返回目录执行</p><pre><code class="shell">cd /glibc-2.28/build../configure --prefix=/usr --disable-profile --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/bin</code></pre><ul><li>错误3</li></ul><!-- 这是一张图片，ocr 内容为：CHECKING FOR NM...NM CHECKING FOR PYTHON3...PYTHON3 CONFIGURE: ERROR: THESE CRITICAL PROGRAMS ARE MISSING OR TOO OLD: BISON 水水水 水水水 CHECK THE INSTALL FILE FOR REQUIRED VERSIONS --><p><img src="https://cdn.lion1ou.tech/picGo/59b58125a77f205431be7be53162bec4_MD5.png"></p><p>安装 <code>yum install bison</code></p><p>到这里所有问题解决完了。</p><pre><code class="shell">cd /glibc-2.28/build../configure --prefix=/usr --disable-profile --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/bin</code></pre><p>然后就执行 <code>make &amp;&amp; make install</code>，开始编译吧，大概需要半小时时间。</p><p>参考：[node: /lib64/libm.so.6: version `GLIBC_2.27′ not found - 丁少华 - 博客园](<a target="_blank" rel="noopener" href="https://www.cnblogs.com/dingshaohua/p/17103654.html">https://www.cnblogs.com/dingshaohua/p/17103654.html</a>)</p><h4 id="解决-GLIBCXX-问题"><a href="#解决-GLIBCXX-问题" class="headerlink" title="解决 GLIBCXX 问题"></a>解决 GLIBCXX 问题</h4><!-- 这是一张图片，ocr 内容为：[15:46:02ROOT@FAT-CONCHSERVICE-DC01-026091:/GLIBC-2.28/BUILD] NODE -V O.6: VERSION 'CXXABI_1.3.9' NOT FOUND (REQUIRED BY NODE) NODE://LIB64/LIBSTDC++.SO.6 S VERSION 'GLIBCXX_3.4.20' NOT FOUND (REQUIRED BY NODE) NODE://LIB64/LIBSTDC++.SO.6:VEL LNODE: /LIB64/LIBSTDC++SO.6: VERSION (GLIBCXX.3.4.21' NOT FOUND (REQUIRED BY NODE) --><p><img src="https://cdn.lion1ou.tech/picGo/9fa828b8495e74916bc22032cfa16d4a_MD5.png"></p><p>问题跟上面其实是一样的，缺少GLIBCXX依赖</p><ul><li>首先检查，当前系统的动态库</li></ul><pre><code class="shell">strings /usr/lib64/libstdc++.so.6 | grep GLIBC</code></pre><p>会发现确实不存在我们需要的依赖</p><!-- 这是一张图片，ocr 内容为：/USR/LIB64/LIBSTDC++.SO T.SO.6 GLIBC STRINGS GREP GLIBCXX_3.4 GLIBCXX_3.4.1 GLIBCXX_3.4.2 GLIBCXX_3.4.3 GLIBCXX_3.4.4 GLIBCXX_3.4.5 GLIBCXX_3.4.6 GLIBCXX_3.4.7 GLIBCXX_3.4.8 GLIBCXX_3.4.9 GLIBCXX_3.4.10 GLIBCXX_3.4.11 GLIBCXX_3.4.12 GLIBCXX_3.4.13 GLIBCXX_3.4.14 GLIBCXX_3.4.15 GLIBCXX_3.4.16 GLIBCXX_3.4.17 GLIBCXX_3.4.18 GLIBCXX_3.4.19 GLIBC_2.3 GLIBC_2.2.5 GLIBC_2.14 GLIBC_2.4 GLIBC_2.3.2 GLIBCXX_DEBUG_MESSAGE_LENGTH --><p><img src="https://cdn.lion1ou.tech/picGo/a79f0bad653869205a633e63e31283a6_MD5.png"></p><ul><li>检查当前动态库的位置和版本</li></ul><pre><code class="shell">find / -name libstdc++.so.6*</code></pre><!-- 这是一张图片，ocr 内容为：FIND /-NAME LIBSTDC++.SO.6 0  6* /USR/LIB64/LIBSTDC++.SO.6 /USR/LIB64/LIBSTDC++.SO.6.0.19 /USR/SHARE/GDB/AUTO-LOAD/USR/LIB64/LIBSTDC++.SO.6.0.19-GDB.PY /USR/SHARE/GDB/AUTO-LOAD/USR/LIB64/LIBSTDC++.SO.6.0.19-GDB.PY /USR/SHARE/GDB/AUTO-LOAD/USR/LIB64/LIBSTDC++.SO.6.0.19-GDB.PYO --><p><img src="https://cdn.lion1ou.tech/picGo/c5d30852d9a7a8f5cdae47288e027e7e_MD5.png">  </p><p>发现我们系统本地也不存在新的动态库，那只能去升级了</p><ul><li>下载gcc版本，选择最新的</li></ul><pre><code class="bash">cd /wget https://ftp.gnu.org/gnu/gcc/gcc-13.2.0/gcc-13.2.0.tar.gz  --no-check-certificatetar -zxvf  gcc-13.2.0.tar.gz  # 解压cd gcc-13.2.0./contrib/download_prerequisites # 下载各项依赖mkdir build &amp;&amp; cd build ../configure --enable-checking=release --enable-languages=c,c++ --disable-multilibmake &amp;&amp; make install  # 需要几个小时时间(我花了4个小时)，耐心等着吧</code></pre><ul><li>检查 gcc 版本，<code>gcc -v</code></li></ul><p>可能出现错误：</p><!-- 这是一张图片，ocr 内容为： --><p><img src="https://cdn.lion1ou.tech/picGo/a1415b1f4d32beb008cafbd0deda969c_MD5.png">  </p><ul><li>创建软链接</li></ul><p>查找GCC编译时生成的最新的动态库位置</p><pre><code class="bash">find / -name &quot;libstdc++.so*&quot;</code></pre><!-- 这是一张图片，ocr 内容为：# FIND / -NAME "LIBSTDC++.SO*" /USR/LIB/GCC/X86_64-REDHAT-LINUX/4.8.2/32/TIBSTDC++.S0 /USR/LIB/GCC/X86_64-REDHAT-LINUX/4.8.2/LIBSTDC++.SO /USR/LIB64/LIBSTDC++.SO.6 /USR/LIB64/LIBSTDC++.SO.6.0.19 /USR/SHARE/GDB/AUTO-LOAD/USR/LIB64/LIBSTDC++.SO.6.0.19-GDB.PY /USR/SHARE/GAB/AUTO-LOAD/USR/LIB64/LIBSTDC++.SO.6.0.19-GDB.PY /USP/SHARE/GAB/AUTO-LOAD/USR/LIB64/LIBSTDC++.SO.6.0.19-GDB.PYO /USR/LOCAL/LIB64/LIBSTDC++.SO.6.0.32 /USR/LOCAL/LIB64/LIBSTDC++.SO.6 /USR/LOCAL/LIB64/LIBSTDC++.SO /USR/LOCAL/LIB64/LIBSTDC++.SO.6.0.32-GDB.PY /OPT/TH/DEVTOOLSET-8/ROOT/USR/LIB/GCC/X86-64-REDHAT-LINUX/8/3Z/LIBSTDC++.SO /OPT/RH/DEVTOOLSET-8/ROOT/USP/LIB/GCC/X86-64-REDHAT-LINUX/8/LIBSTAC++ SO /GCC-13.2.0/BUILD/X86_64-PC-LINUX-GNU/LIBSTDCH+V3/SRC/.LIBS/LIBSTDC++.S0.6.0.32 /9CC-13,2.0/BULLD/X86_64-PC-11NUX-GNU/LIBSTDCH+V3/SRC/.1IBS/LIBSTDCH+.SO. /GCC-13.2.0/BUILD/X86-64-PC-LINUX-GHU/LIBSTDC++-V3/SRC/.LIBS/LIBSTDC++.SO /9CC-13.2.9/BUILD/PREV-X86-64-PC-LINUX-GNU/LIBSTAC++V3/SRC/,LIBS/LIBS/LIBSTDC++50.6.0.33 /GCC-13.2.0/BUILD/PREV-X86.64-PC-LINUX-GNU/LIBSTDC++V3/SRC/.LIBS/LIBSTDC++.SO.6 /GCC-13.2.0/BUILD/PREV-X86-64-PC-LINUX-GNU/LIBSTDC++V3/SRC/.LIBS/LIBSTDCH+.SO /9CC-13.2.0/BUILD/STAGEL-X86-64-PC-LINUX-GNU/LIBSTDC++-V3/SRC/.LIBS/LIBSTDCH+SO.6.0.6.0.32 /9CC-13.2.0/BUILD/STAGEL-X86-64-PC-LINUX-GNU/LIBSTAC++-V3/SRC/,1IBS/LIBSTDC++50.9 /GCC-13,2.0/BUILA/STAGEI-X86-64-PC-LINUX-GNU/LIBSTDC++-V3/SRC/.IIBS/LIBSTDCH+SO --><p><img src="https://cdn.lion1ou.tech/picGo/7618026338ce53a8cbb9687b2ea5948a_MD5.png">  </p><p><font style="color:rgb(77, 77, 77);">可以看到，有更高的版本 </font><code>&lt;font style=&quot;color:rgb(77, 77, 77);&quot;&gt;/usr/local/lib64/libstdc++.so.6.0.32&lt;/font&gt;</code></p><pre><code class="bash">cp /usr/local/lib64/libstdc++.so.6.0.32 /usr/lib64/cd /usr/lib64/rm libstdc++.so.6ln -s libstdc++.so.6.0.32 libstdc++.so.6</code></pre><p>最后 执行 <code>node -v</code>，如果展示node版本，就说明大功告成了</p><p>参考：<a target="_blank" rel="noopener" href="https://www.imqianduan.com/linux/gcc-update-libstdc.html">https://www.imqianduan.com/linux/gcc-update-libstdc.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>北极星报表搭建平台</title>
      <link href="/2023-05/%E5%8C%97%E6%9E%81%E6%98%9F%E6%8A%A5%E8%A1%A8%E6%90%AD%E5%BB%BA%E5%B9%B3%E5%8F%B0/"/>
      <url>/2023-05/%E5%8C%97%E6%9E%81%E6%98%9F%E6%8A%A5%E8%A1%A8%E6%90%AD%E5%BB%BA%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<p>随着公司内部对各类报表需求的不断攀升，原有的极光系统已经无法满足移动端、实时大屏等各类场景；另外由于页面逻辑中涵盖了大量计算，导致页面性能偏差且无法支持灵活的外部拓展，导致数据源单一；最后由于项目比较久远，整体UI风格相对老旧、交互方式单一。为了满足公司内部各业务灵活的数据报表产出需求，以及保证数据团队报表产出效率，就有了我们的北极星报表搭建平台。</p><span id="more"></span><h2 id="伽利略数据平台"><a href="#伽利略数据平台" class="headerlink" title="伽利略数据平台"></a>伽利略数据平台</h2><p>首先我们来介绍一下伽利略数据平台，伽利略数据平台主要由三个部分组成，一个是报表展示层，就是目前的伽利略报表系统，同时支持运行于钉钉微应用和PC端。一个是伽利略管理后台，主要用于报表各数据源管理配置和报表目录与发布管理。最后一个部分就是我们的报表搭建平台–北极星。</p><p><img src="https://cdn.lion1ou.tech/picGo/280d5ed202c4a1c0dd9a5166fd641974_MD5.png">  </p><p>由上图我们也可以看出三个系统之间相互关联，又完全解耦，可完全独立运行。北极星搭建系统，作为数据报表产出工具，支持高度复用，可随意对接外部展示系统和数据来源系统。</p><h2 id="北极星报表搭建平台"><a href="#北极星报表搭建平台" class="headerlink" title="北极星报表搭建平台"></a>北极星报表搭建平台</h2><p><img src="https://cdn.lion1ou.tech/picGo/8ff57b797b411a5628792be6156dd848_MD5.png"></p><p>首先我们从一张流程示意图来看看，北极星主要实现原理。我们通过管理后台的编辑器以及组件管理模块，抽象维护数据、组件、树结构、样式、组件属性等模块信息，再通过解析器解析渲染，控制页面上下线、版本以及页面中包含的组件，接着通过接口调用获取数据源信息，生成适配各个场景的报表能力。</p><p>北极星报表搭建系统主要分成四个层面，有展示层，包括渲染器，编辑管理后台，以及多端的适配能力。有基础层，通过抽象页面、组件、数据、协议、权限等模块，来支持展示层的复用。有框架层，主要依赖业界成熟的antd (antd-mobile) + react、图表使用F2和G2。还有服务层，通过自建node服务，提供页面、组件、报表和权限等管理能力。</p><p><img src="https://cdn.lion1ou.tech/picGo/00416bd7350e7ba6aff7072a3917c606_MD5.png"></p><h2 id="组件设计"><a href="#组件设计" class="headerlink" title="组件设计"></a>组件设计</h2><p>北极星搭建系统支持antd 现成组件、自定义业务组件的灵活接入，只需要组件配合引入属性配置表和默认数据信息，通过发布平台发布npm包，最后在北极星系统上线后，即可快速接入到各报表页面。在一些特殊的属性场景上，我们还支持对组件属性的配置能力进行自定义开发。</p><p><img src="https://cdn.lion1ou.tech/picGo/aae571960656922930f9925b052089a9_MD5.png"></p><h3 id="组件版本控制"><a href="#组件版本控制" class="headerlink" title="组件版本控制"></a>组件版本控制</h3><p>在搭建系统中，其实我们用的最多的就是组件，而且组件随着项目的不断迭代，可能会出现很多版本，那么在多个版本的情况下，我们如何来保障页面可以快速读取对应版本组件的信息呢？ 如果使用npm形式引入，我们需要将所有组件拆分成独立的npm包，进行管理。而且这种情况下，我们也不能做到在一个页面需要多个版本组件的情况下共存，只能同时更新所有组件版本，这样很可能存在潜在的问题，导致页面出现版本不兼容的bug。</p><h3 id="组件按需加载"><a href="#组件按需加载" class="headerlink" title="组件按需加载"></a>组件按需加载</h3><p>在通常的前端项目中，我们都是通过引用npm组件，然后加载并渲染在页面上。这种形式有个问题，在我们不知道用户引用哪个组件时，那我们就需要将所有组件都引用，打到最终的渲染包里，然后根据用户需求，去读取对应的组件。这个过程就浪费了很多资源，也会造成页面性能问题。</p><h3 id="动态组件方案"><a href="#动态组件方案" class="headerlink" title="动态组件方案"></a>动态组件方案</h3><p>为了解决上面的问题，保障页面性能和准确的版本控制。我们使用的cdn方式，我们将每次发布的后的组件都上传至cdn，再通过组件类型、组件版本等字段拼接cdn链接，最后通过ajax请求动态获取组件文件，渲染成相应的组件，提供给页面使用。这也是为什么，我们需要对现成可用的antd组件，进行简单封装上架到北极星。另外我们后续还将提供更加灵活的升级配置，支持快速、批量修复线上bug。</p><p><img src="https://cdn.lion1ou.tech/picGo/a6705f3841fc85c88f0ce61d225603e3_MD5.png"></p><p>动态组件在实现上我们提供了两个方案，一个是通过ajax获取文件，通过eval进行代码执行，导出对应的组件实例。另一个方案是，通过动态加载script标签的方式加载指定组件。两种方案有各自的优缺点，通过ajax方式获取，可以通过indexedDB进行缓存，减少了后续请求，性能提升明显，但这种方案组件报错后，无法获取具体报错信息。动态加载script标签的方式容易出现缓存泄露问题，且无法支持缓存。所以我们目前的方案是，在测试开发环境，使用动态script标签方式，在线上使用ajax获取文件方式。具体代码如下：</p><pre><code class="javascript">// 使用eval解析, 无法catch组件内部的错误export const loadScriptModule = async (  url: string, packageName: string,) =&gt; new Promise(async (reslove, reject) =&gt; &#123;  const id = getIdformUrl(url);  const Reg = /[http://|https://]/;  if (url &amp;&amp; Reg.test(url) &amp;&amp; id) &#123;    try &#123;      // 这里可添加缓存获取逻辑            const &#123; data &#125; = await axios.get(url, &#123; timeout: 30 * 1000 &#125;);            if (!data) &#123;        const err = new Error(&#39;文件加载失败，请检查链接&#39;);        reject(err);        return;      &#125;      // 这里可添加缓存存储逻辑                  window.eval(`$&#123;data&#125;`);      const res = (window as any)[packageName] || &#123;&#125;;      reslove(res);      (window as any)[packageName] = null;    &#125; catch (error) &#123;      console.error(error);      reject(error);    &#125;  &#125; else &#123;    const error = new Error(&#39;url 格式错误，请检查链接&#39;);    reject(error);  &#125;&#125;);</code></pre><pre><code class="javascript">// 动态加载js文件， 可能存在内存泄露的问题export const loadScriptModule = async (  url: string, packageName: string,) =&gt; new Promise(async (resolve, reject) =&gt; &#123;  const id = getIdformUrl(url);  const Reg = /[http://|https://]/;  if (url &amp;&amp; Reg.test(url)) &#123;    let script: any = document.createElement(&#39;script&#39;);    script.setAttribute(&#39;src&#39;, url);    document.head.appendChild(script);    // 监听加载完成事件    script.addEventListener(&#39;load&#39;, async () =&gt; &#123;      const res = (window as any)[packageName] || &#123;&#125;;      resolve(res);      (window as any)[packageName] = null;      script = null;    &#125;);    // 监听加载失败情况    script.addEventListener(&#39;error&#39;, (error: any) =&gt; &#123;      message.error(&#39;组件加载失败，请检查是否已同步CDN&#39;);      reject(error);    &#125;);      &#125; else &#123;    reject(error);  &#125;&#125;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 低代码 </tag>
            
            <tag> 搭建平台 </tag>
            
            <tag> 报表系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小前端看大前端大会 — GMTC 总结</title>
      <link href="/2023-02/%E5%B0%8F%E5%89%8D%E7%AB%AF%E7%9C%8B%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%A4%A7%E4%BC%9A-%E2%80%94-gmtc-%E6%80%BB%E7%BB%93/"/>
      <url>/2023-02/%E5%B0%8F%E5%89%8D%E7%AB%AF%E7%9C%8B%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%A4%A7%E4%BC%9A-%E2%80%94-gmtc-%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>很荣幸跟几位同事一起参加了 GMTC 全球大前端技术大会。本文按主题梳理我的现场笔记与思考，涵盖工程化、性能与监控、团队管理等方向。</p><span id="more"></span><h2 id="全干工程师"><a href="#全干工程师" class="headerlink" title="全干工程师"></a>全干工程师</h2><p>会议第一天继会议主编发言之后，就开始了由快手俞天翔大佬带来的《从“全干”工程师的发展路径看前端的定位与价值》。在分享中俞天翔老师表达了对前端定位和价值的观点。前端技术具有先天的优势，可以在不同的平台上运行，为前端同学提供了更多可能性，从跨端到全栈再到“全干”。从整个产品的开发交付流程上看，前端几乎在所有流程节点中都能有应用场景。包括各类前台业务支持：大型活动页面、直播、电商等业务，各类管理中台系统，各类提效后台系统和各场景上的基础建设。俞老师认为前端的挑战和价值的重点在工程化。如何理解工程化呢？探索并应用合适的技术，通过合理的抽象与分层，完成平台建设、业务落地、完善基建，辅助业务落地持续拿战功的同时，体现自身价值。</p><!-- 这是一张图片，ocr 内容为：业务落地与支持 前端的定位和价值: WEB技术优势 流程整合 应用形态 工作支持 业务 WEB APP *开发成本低:声明式&多范式 INIT/UPDATE C端 追鸭 PC站 电喵 音乐人 小剧场 站外分享 大型活动 付费内容 游戏百播 WEB APP B端 小程序 小程序 CODE *能力覆盖广:从跨端到全栈 皮卡 态费 融合激励 音乐宣发 抖饭 赚钱页 本地应用 小柱序 年汤圆 支付宝 微信 00 小程序 小程序 COMPLLE 小程序 小程序 小程序 小程序 SDK COMMIT *标准化:保证了能力下限 移动端APP 中台 业务中台 IM SDK 活动平台 开放平台 支付SDK 鲜花后台 支付中台 YODA SDK BUILD 库/框架 后台 工程化解读 服务 开发检查/ 业务架构 TEST KTRACE 状态管理 NPM LIVEEDITOR WEBOPS 动效平台 SDK 设计 准出 探索并应用合适的技 基础建设 术,通过合理的抽象与分 PREVIEW 前端的挑战 层,完成平台建设,业务 场景编辑 业务架构 开发检查/ 结构化编 PET组建 &价值 动效平台 状态管理 PLAYGROUND 准出 市场 器转 设计 DEPLOY 落地,完善基建,辅助业 工程化 务落地持续拿战功的同时, 能力储备 体现自身价值. MEASURE 分布式 算法 GUI渲染 数据结构 编程语言 软件工程 计算机网络 编译 --><p><img src="https://cdn.lion1ou.tech/picGo/530c509c862bdc4eae9994db59d53b09_MD5.png?imageslim"></p><p>那在工程化上我们该如何实践呢？俞老师从价值、路径和结果，三个方面分析了对工程化的思考。首先在实现路径上我们需要对方案做简化降维，将复杂的问题拆解成单一的问题，然后再进行逐个击破。这样对于系统的可维护性和实现成本都有明显的优势。平常我们在做工程化项目的时候，往往目的都是为了保证开发流程的稳定、高效运行，不受限于某个开发同学或某项特定技术栈的支持。那么就需要将零散、复杂的提效工具整合成完善的服务或平台形态，减少‘人’在系统中的依赖，降低用户使用和理解成本，并且可以保障各项关键节点的溯源和权限管理。像这样完成项目后，在价值体现上我们可以从降本维度，包括直接成本和间接成本，如服务器数量、cdn费用、人力投入上去考虑。还可以通过交付质量层面，对业务系统的表现力、性能情况、稳定性提升等方面去考量工程化系统的价值所在。</p><!-- 这是一张图片，ocr 内容为：前端的定位和价值: 工程化的思考 平衡 追求极致 工程化 创新 取舍 路径 价值 结果 单- 直接成本+间接成本 E-LEARN 单一 LOOO 复杂 CDN费用 服务器数量 单一 降维 工具形态 服务/产品形态 人力投入 交付质量 未解 已解 已解 性能 表现力 稳定性 逐个攻破 减少对"人"的依赖 --><p><img src="https://cdn.lion1ou.tech/picGo/c1ceab03ec60dd4a912ae3e5bbc1af52_MD5.png?imageslim"></p><h2 id="性能与监控"><a href="#性能与监控" class="headerlink" title="性能与监控"></a>性能与监控</h2><p>下午场去参加了大前端监控话题的分享，现场异常火爆。可能是因为随着互联网业务稳步发展，整个前端体系也逐渐走向精细化运营和质量开发，用户体验问题也越来越受到开发者重视，前端监控变得尤为重要。在本专题会上各位老师都介绍了自家公司监控产品的实现方案和探索方向。</p><ul><li>前端监控演进——如何提升问题发现率</li></ul><p>阿里的墨辉老师，从问题发现率的角度出发，探索了在技术指标稳定的情况下如何快速发现线上业务问题，如何通过异常检测方案、业务监控和告警策略，提升线上业务问题的发现率。</p><!-- 这是一张图片，ocr 内容为：方案总结 安全生产 业务治理 报警策略 异常检测 治理工单 业务监控 规则报警 产品应用 解决方案 非预期检测 灰度报警 最佳实践 多维报警 统计分类 相似度聚类 数据分析 数据处理 JSERROR 接口 灰度信息 页面结构 资源 数据采集 采集规范/采集CORE --><p><img src="https://cdn.lion1ou.tech/picGo/0fdbd8a79a2cf8b65923d6ef82a44e87_MD5.png?imageslim"></p><ul><li>大前端精细化治理——组件 ID 机制</li></ul><p>去哪儿网的江保贵老师，从精细化治理角度出发，通过建立全端层面的组件ID机制，解决线上快速定位问题能力。并通过建立用户体验评分模型，对各维度数据进行汇总计算，得出相对全面的用户体验评分系统。从而实现对平台应用质量的全面把控，及时发现各应用的薄弱环节规避风险。</p><!-- 这是一张图片，ocr 内容为：大前端精细化治理目标 建立组件ID机制 创建业务开发团队ID,组件/资源包ID,页面ID,VIEWID等信息 快速定位线上问题 通过服务配置不同ID开关,动态收集上传异常,运行日志等信息 搭建用户体验指标度量平台 用户体验多指标融合,数字量化用户体验,统一入口 --><p><img src="https://cdn.lion1ou.tech/picGo/d8d6d13750527e8b50b92a5264155713_MD5.png?imageslim">  </p><ul><li>北斗大前端监控系统建设与实践</li></ul><p>58同城的李祎老师，给我们详细介绍了北斗大前端监控系统的架构方案。包含SDK层：JSSDK、RNSDK、NativeSDK；数据收集层：数据采样、清洗、转换、转发；数据存储层：日志明细、指标数据；核心服务层：告警分析、采样率计算、日志整合、可视化平台业务；可视化平台：日志查询、可视化图表分析。</p><!-- 这是一张图片，ocr 内容为：基础监控架构 SDK LAYER 关注点 RN IOS MINI APP WEB ANDROID 监控数据实时性 LOGS LOGS ID MAPPING 整体架构可维护性 DATA COLLECT SERVICE LAYER 技术栈横向扩展 集团级的流量和日志存储 KAFKA KAFKA OTHER LOGS PLATFORM 架构 STORAGE LAYER WTRACE SDK层 JSSDK,RNSDK,NATIVESDK ELASTICSEARCH HDFS MYSQL DRUID 数据收集层数据采样,清洗,转换,转发 BIZLOGS TIMESTAMP.DIMENSION.METRICS QUERY STORGE 数据存储层日志明细,指标数据 CORE SERVICE LAYER 核心服务层告警分析,采样率计算,日志整 DASHBOARD SCHEDULE 合,可视化平台业务 LOGS LINK SERVLCE JOBS LIMIT LPGS SYNC 可视化平台日志查询,可视化图表分析 SEND ALERT --><p><img src="https://cdn.lion1ou.tech/picGo/851e04cc3a425d100a35b4027232f318_MD5.png?imageslim"></p><p>另外在多端异常问题定位上，李祎老师也给我们提供了不少思路。在JS异常分析过程中为不同场景提供不同的定位工具。包括源码自动映射，智能维度分析，执行链路日志，场景模拟还原和自定义日志查询，尽可能为所有问题场景提供可用的数据支持和解决思路。在智能维度分析上，通过对维度占比排序和逐步减少条件的方式，找到占比最大的条件组合来实现智能分析。</p><ul><li>腾讯前端监控体系建设</li></ul><p>腾讯的李振老师，从多平台监控SDK、百万QPS上报的接入层和限流与网关这几个方面，给我们分享了他们的实践方案。目前腾讯的RUM(Real User Monitoring)支持的接入平台数量众多，通过单一平台单个sdk的方案，存在代码维护困难，协同成本高，发布版本不一致等问题。为了解决这些问题，他们采用了胖内核、异步插件、灵活配置插件组合的方案。中间经历过多次重构迭代，通过不断重构使设计模式和架构更趋于合理，提高SDK的拓展性和维护性。</p><!-- 这是一张图片，ocr 内容为：多平台监控SDK设计与实现 方案与效果 集成打包模式 抽取公共逻辑,通过内核定义全部功能 解决方案: CORE CORE管理平台无关的功能 平台 生命周 平台无 插件 配置 COCOS-SDK 期管理 无关 关功能 管理 管理 SDK内部管理上报逻辑 CORE HIPPY-SOLK >LITEAPP-SDK 插件化管理公共逻辑或者自有逻辑 >MP-SDK SDK NODE-SDK 数据上报管道化PIPELINE QUICKAPP-SDK MSSDK 平台 VIOLA-SDK MINI 优化效果: NODE WEB WEB-SDK RN 相关 PROGRAM _. TESTS_ >LIB 代码逻辑更加清晰自洽 NODE_MODULES VSRC 开发编译按需打包 PLUGINS 协议统一 页面 数据 数据 染色 TS INDEX.TS 离线 测速 PV 抽样 性能 NPMIGNORE 采集 处理 日志 存储 PACKAGE-LOCK.JSON 集成打包带来的问题 打包后文件非常大(440K) TS CREATOR.D.TS PIPELINE:限流,去重,合并请求,白名单等 开发过程中编译速度非常慢 GMITC INFOQ --><p><img src="https://cdn.lion1ou.tech/picGo/cffa98a597405960a73065749392bb89_MD5.png?imageslim">  </p><!-- 这是一张图片，ocr 内容为：多平台监控SDK设计与实现 14K是否已经是极限了? 订制专属SDK 优化后存在的问题 日志上报,白定义PV,自注义测速 SDK 盘功能, 连过锁定谷动物 PERFOMANTARASOUROETTERING 对关应达来的路查阅读进行主建. 不同用户有不同的诉求,大部分用户只会用到某些功能 如持:XHR 及 BESCT 进行接口测出. 随着功能增强代码包依然会不断扩大 海拔在上张约日志存请在用户本拍 IDENEDDB 中,供开发者商时携取 错误监控 有些用户把SDKINLINE到HTML 脂肪严重上约布有强逻:这块行罐复,PRORRISE铁行管误,AFSKH!我决定属,REL29DE异常,管理加整决激. 真面漂连 通过 PERIORNANCETENG 收解并二报DNS斯析,ICP语,55L后腰,SSL异糖,DDAN析,委源龙世哥解校,55L诗艘,DDNS斯析,整源龙世哥解校,55L后腰,SSL诗艘,DDON标,整 法计准首所时间. 厂用户同放 思考: 在不影响性能的落提下,监护违户的预行,并生成回放在开发着平台撞放. 单页应用 监督HASHCHANGA,HISTORY API ,在单页应用路由安北时上报页面PV. 能否通过定制化的方式让用户选择自己所需要的功能 天机阁全铁路日志 天组购全镜结日志,望老该销性.彩绘典面生成一个SPAN,并给问题的A以请来涉红一个棋蜂的温来失,关城页回 开始生成 十年+ 最终方案 定制专属SDK SOK组成:日志上报,自定义PV,自 自定义汉 读取的配置位数 15 // NAME:插件名,INDEX:读 不同插件排列组合 CONST PLUGINS INDEX:0 1 7, NAME:ASSET_SPEED { NAME:'CGI_SPEED', INDEX: 1 ], 可视化页面让用户动态选择自己所需要的功能 19 { NAME: 'OFFLINE_LOG', INDEX: 2 ], 20 { NAME: ON_ERROR',INDEX:3 ], 实现定制SDK 的基础是前面良好的插件化 21 { NAME:PAGE PERFORMANCE',INDEX:4 H, 22 { NAME:SHADOW_LOG',INDEX: 5 ], 23 { NAME:SPA ,INDEX:6>, 24 { NAME:TJG',INDEX:7), 25 { NAME:WEB_VITALS',INDEX:8 ], GITC 26 全球大前错技术大会 --><p><img src="https://cdn.lion1ou.tech/picGo/1a1646d85108bd296d7a4ff114e538d6_MD5.png?imageslim">  </p><p>另外在监控系统中，还有一个比较常见的问题就是数据量太大，对服务和性能的要求太高，并且可能出现不可预期的数据高峰情况，导致系统崩溃。通过在上报前的数据限流，清洗数据时的数据丢弃，定时缩扩容等方案处理之后，还是无法解决流量突增的问题。在不断摸索和试错过程中，他们通过新增动态中间网关层的方式，解决了流量突增的问题。这样的场景可能在一般的企业中是不太会出现，但是不乏也是一个解决相关问题的思路。</p><!-- 这是一张图片，ocr 内容为：问题思考 真正的方案 冗余 网关直接返回204,再 异步 缩容问题>修改NODE 默认全连接队列长度 服务器 异步把数据发送到服 网关 客户端 问题本质>流量激增(瞬时)的问题 削峰限流 务器? 提前扩容 204 限流与动态网关 方案分析 动态网关 方案对比 技术组件 USER 1.原生支持负载均衡 LUA提前关闭连接. 2.可快速扩容 IAS,STGW REG RSP STATUS 204 3. 不支持UPSTREAM 自定义 父子请求间,非阻 1.负载均衡 塞的内部请求,也 子请求 2.快速扩容(K8S) DYNAMIC GATEWAY, LUA->/SUB OPENRESTRY 没有进程间通信. 父请求 3.支持UPSTREAM自定义配置 4.研发成本低 ASYNCHRONOUS 1.负载均衡相对繁琐 REG 自研GOLANG网关 2.高并发能力略逊于NGINX 3.研发成本较高 APP SERVER 具体实践 高并发优化 核心代码 1.HTTP 连接快速关闭 KEEP_ALIVETIME 1.最大连接数SOMAXCONN 2.子进程打开连接WORKER_CONNECTIONS 2.加快 TCP 连接回收 TCP_TW_RECYLE -关闭连接,把数据返回给终端.后面操作继续执行 NGX.EOF() 3.子进程允许打开文件 3.空 TCP 回收 TW.REUSE NGX.REQ. READ_BODY() LOCAL RES NGX.LOCATION.CAPTURE( SPEED/CUSTOM", WORKER_RLIMIT_NOFILE 4.系统最大打开文件ULIMIT-N ARGS NGX.REQ.GET_URI ARGS(), 系统层面 NGINX层面 INTOQ GING 全球大前端技术大会 --><p><img src="https://cdn.lion1ou.tech/picGo/05deb32e8834f454538af9e6ab7eae7c_MD5.png?imageslim">  </p><h2 id="团队管理"><a href="#团队管理" class="headerlink" title="团队管理"></a>团队管理</h2><p>在团队管理专题场上，汇集了各位业界大佬的经验总结，满满都是干货。第一个分享，来自京东零售的盖旭天老师 – 《低碳背景下的技术管理》。在全球低碳背景下，业务追求创新愈加强烈，技术团队需要在无法大范围扩张的前提下，该如何考虑技术团队的管理呢？盖老师从技术战略的思考，低碳组织打造和成本减法与提升效能案例上，对其做了阐述。低碳组织打造，主要分为五点：组织飞轮，组织战略屋，定高起点，管好过程，拿量化结果。</p><!-- 这是一张图片，ocr 内容为： --><p><img src="https://cdn.lion1ou.tech/picGo/c6d700394feb5f5751a760b85aa1c953_MD5.jpg"></p><p>第二位则是58集团前段技术委员会主席井铎铎老师 – 《二手电商前端团队价值之路》。从前端团队价值、决策力，个人突破阐述了对团队管理的理解，并根据他的经验做了详细介绍。前端团队价值在于高效保证业务交付，创造更好的用户体验。决策力是管理者为实现总体目标，解决局部重要问题的一种选择。决策的本质是基于收益、损失、时间纬度的取舍。个人突破关键在于向上管理、升维思考、非正式网络构建和自我意识，最后让自己的工作进入心流状态。</p><!-- 这是一张图片，ocr 内容为：前端技术团队的价值-小结 高效保证业务交付,创新更好用户体验 守正出奇,业务为正,能力为奇 POR用乔士率 效丰盘 协作水平 270食品作问鉴 足浴车 前端技术团队的价值 交付价值 交付指标体系 秒开平 体验盘 质量盘 增量价值 基本价值 交付-招标体系 一手拯救 效率盘 质量出 数据决策 可能性 前瞻性 增量价值 体验盘 协作水平 GMITC INFOQ --><p><img src="https://cdn.lion1ou.tech/picGo/f6815ff72c042013e94effef812d834d_MD5.png?imageslim"></p><!-- 这是一张图片，ocr 内容为：团队管理中的决策力-小结 决策的本质是基于收益,损失,时间纬度的舍弃 好的决策一般不是来源于直觉,而是需要好的工具方法,花在它身上的时间都是值得的 未来的不确定性,当你遇到危机,糟糕的处境,不情愿去做决策时,能做出合理决策才是关键 管理中的决策力 中层管理者为实现总 体目标,解决局部重 要问题的一种选择 GMTC INFOQ 全球大前幅技术大会 --><p><img src="https://cdn.lion1ou.tech/picGo/c0165b7619125229294fbbb1271cc8b8_MD5.png?imageslim">  </p><!-- 这是一张图片，ocr 内容为：自我成长突破路径-小结 个人成长/突破 个人成长/突破 GROWING UP 焦虑 心流 菜道 自我管理 向上管理 SELF MANAGEMENT MANAGE UPWARDS 眼烦 增加按妮水平 0 0(低) (高)(G 技能 GITC INFOQ --><p><img src="https://cdn.lion1ou.tech/picGo/1d2574085f9440fe30f5e3d3ba218668_MD5.png?imageslim"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于篇幅有限，无法把所有分享都列出来，这里只是列举了让我印象深刻的几位老师的分享，最后谈谈我对这次大会的一些感受。</p><ol><li>这次大会上听到最多的词应该就是“提效”了吧，在很多分享上都能听到老师提到这个词。面对全行业都在说提效的大环境，作为一个基建团队的开发同学。我们应该调整思考问题的方式和角度，应该更多的去倾听业务线团队的声音，解决他们现有的痛点和问题，以保证业务持续增长为最终目的。做基建项目的节奏应该调整为以满足单一业务需求为起点，保证拓展性的同时，尽可能降低开发成本。直到公司内多业务线，多场景都有相同需求时，才去做公司层面的抽象，形成平台化的产品，这样对开发效率和开发成本都有很好的控制。尽量避免一开始就做大而全的产品，这样最后可能不一定有很好的ROI。</li><li>在目前前端体系也逐渐走向精细化运营和质量开发，用户体验问题也越来越重要，很多时候在现有复杂的业务场景下，很难只通过某种技术迭代或技术架构重构，就让产品的体验上升一个台阶。这种情况下，就需要我们对线上体验情况有更加精准的掌握，也对我们的前端监控能力提出了更高的要求，不能只停留在基础的技术指标层面。需要对指标变化的根因有细致的分析和处理。</li><li>团队管理方面，在目前的大背景下，很多时候不能通过直接招聘的形式来获取更多生产力，那就需要团队自身能够更加高效。高效的同时还需要对需求有清楚的辩识，哪些需要做减法，哪些需要持续投入。</li><li>个人成长方面，练好内功在什么样的环境下都是保护自己的最好方式。在工作时，时刻要提醒自己，不要做工具人。通过技术方案让自己不做工具人，通过沉淀输出方法论，避免自己做工具人。在保证身体健康的同时，多实践，多学习，持续保持竞争力。</li></ol><p>以上是基层小前端的浅显总结，有什么不对的地方欢迎批评指正。</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GMTC </tag>
            
            <tag> 前端 </tag>
            
            <tag> 工程化 </tag>
            
            <tag> 监控 </tag>
            
            <tag> 团队管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>而立之年的年终总结</title>
      <link href="/2022-01/%E8%80%8C%E7%AB%8B%E4%B9%8B%E5%B9%B4%E7%9A%84%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
      <url>/2022-01/%E8%80%8C%E7%AB%8B%E4%B9%8B%E5%B9%B4%E7%9A%84%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>随着2022年新年钟声敲响，我开始在键盘上敲下了第一行字。这篇年终总结其实在12月中旬就想写了，当时就大概想了下，列了下提纲，然后就因为各种原因搁置到了现在（拖延症真的很难治）。晚上趁儿子睡熟，老婆在忙，还没入睡的这段时间，来完成一下去年的任务吧。</p><span id="more"></span><h2 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h2><h3 id="乐刻四年"><a href="#乐刻四年" class="headerlink" title="乐刻四年"></a>乐刻四年</h3><p>在过去的2021年，最重要的事情就是我离职了，从一家我工作了1542天（4年多）的公司。虽然乐刻不是什么大公司，也没有什么技术大牛和强大的前端团队，但还是不舍，不舍得那些一起加班一起战斗的战友，不舍得那些从零开始负责的项目，不舍得那些还没达到理想状态的目标。除了不舍，还有就是感谢。感谢那些帮助过，提点过我的老板们、前辈们。感谢那些一起加班，一起写bug的小伙伴们，感谢4年的包容与帮助。另外还要感谢乐刻，感谢公司给予的平台和机会。</p><p>不过生活就像有句话说的一样：“人生就是一个不断选择和放弃的过程”。不断的取舍，是为了不断寻找下一个平衡点。可能当时我就刚好处在这个时间段，由于一些内在和外在的原因，所以有了跳槽的想法。于是我自己做了一些思考，也对未来几年做了些规划，还找了几个身边的朋友、同事和家人聊过，最后发现可能离开会更有助于前端生涯的发展。于是在6月中旬，我跟老板提了离职。</p><p>在乐刻的四年里，主要涉及技术栈包括：Vue、React Native、React。主要是一些偏向商家侧，服务于教练、店长、合伙人等角色，包括消费履约场景内的所有中间环节，有管理后台、H5前台，RN App，钉钉微应用等，另外还涉及组件库、工具库、性能监控、性能优化的基础建设。在离职前的一年时间里，由于职责的变动，我开始主要负责团队招聘，团队管理等工作。</p><p><img src="https://cdn.lion1ou.tech/WechatIMG29.jpeg?imageslim"></p><h3 id="关于面试"><a href="#关于面试" class="headerlink" title="关于面试"></a>关于面试</h3><p>说到离职，肯定离开不了面试。面经在掘金上已经很多了，面试前只要找几篇高赞的认真复习整理，就能基本涵盖到大大小小的基础知识，算法还是需要平时积累，多做多练。我这里只说说，在这次面试过程的一些小感受。因为在乐刻期间，做过一段比较长时间的面试官。所以这里想说几点比较深的感受：</p><ol><li>面试是一个双向选择的过程，不管你是面试官还是候选人，你在选对方的时候，对方也在选你。作为候选人时，尽量提前知晓应聘的岗位是需要什么样的角色，并结合自身情况看是否合适，再针对性的去准备面试。而不是没有目的的海投，这样只会让你疲于在各个面试中，不能很好的准备每场面试，可能最后的结果也会不理想。</li><li>对自身的能力层级要有一个清晰的认识，不然面试官对你的评价可能会和自己的预期有很大偏差，自己还没有感知。这点可能比较难，这个时候就需要多跟身边的同事，或者是社区里的大佬沟通，通过他人的评价和感受，来预估自己的能力层级。</li><li>要对自己做过的项目有一个全面的了解，对遇到的困难和最终的解决方案，还有项目中的亮点成果都要有准备。更重要的一点是一定要与业界成熟方案做对比，比较别人方案与自己方案的优劣，避免闭门造车，井底之蛙的处境。</li></ol><h3 id="新工作新开始"><a href="#新工作新开始" class="headerlink" title="新工作新开始"></a>新工作新开始</h3><p>目前新工作的团队是大前端基础技术部，个人主要负责公司前端监控告警平台。整个链路涉及技术栈包括：vuejs、koa、clickhouse、flink、kafka、postgre、以及部分运维相关。与之前的技术栈重叠度比较低，也刚好符合自己的规划。从入职到现在差不多半年时间，主要做了几件事：1. 重构升级了系统自助查询能力，让取数、报表变得更加方便和安全。2. 重构了JS错误分析模块，通过对底层clickhouse查询优化和物化视图的加持，大大缩短了查询时间，延长了查询跨度。3. 优化了内部多个基础模块，提升整体性能。</p><p>另外还有一件事比较印象深刻的是，做完自助分析重构后，在公司内部做了一次直播分享，介绍了整个自助分析模块大致的实现方案。第一次做直播分享还是比较紧张的，不过最终数据还不错。后来也抽空整理了一篇文章，感兴趣的同学可以看这里：<a href="https://lion1ou.tech/2021-11/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E7%9A%84%E8%87%AA%E5%8A%A9%E5%88%86%E6%9E%90%E8%83%BD%E5%8A%9B/">跳转文章</a></p><p>接下来会借助前端监控告警平台的开发，深入了解服务端相关内容，进一步提升技术能力，并通过对多平台上业务前端的监控，加深对不同平台、不同场景下前端开发的理解。通过两者之间的相辅相成，让前端监控平台可以真正服务于日常开发，提升研发效率的同时，保证用户体验。</p><p><img src="https://cdn.lion1ou.tech/image.png?imageslim"></p><blockquote><p>重构后的错误分析看板</p></blockquote><h2 id="关于生活"><a href="#关于生活" class="headerlink" title="关于生活"></a>关于生活</h2><h3 id="做计划"><a href="#做计划" class="headerlink" title="做计划"></a>做计划</h3><p>做计划这件事情其实一直都在做，只是之前的计划会比较空泛，没有具体实现的步骤，最终的结果也会比较不好衡量。很多时候是目标定了，但是等到季度末或者年度末，这些计划还只是计划。因为没有具体的实施方案，所以很多时候时间就会被生活中的各种琐事给占据。还有一个观点是：“行动力不足的真正原因是选择模糊”。因为模糊代表着不确定，人类在面对不确定性时，就会不自觉的逃避，所以计划一定要有确切的行动方案。</p><p>所以从今年的计划开始，一直在尝试各种方式，经过几个月的尝试，也逐渐开始形成一套自己的计划方式。首先会制定1-2个比较长远的目标，如三年目标五年目标，这些目标会比较空泛也会比较远。然后在每半年度开始时，先考虑这半年有没有要做的事，再拆解三年目标需要做的事，最终形成半年度的几个目标。再在每个月月初时，会把半年目标和本月需要做的其他事情结合起来，形成本月的待办事项。今年上半年，我只做到了这一步，到月末总结时，发现效果是有的，但是完成率还是不高。于是开始再拆解，拆解成周计划，并配合记日记。日记的话，只记录自己做过的事情，以及跟目标的偏差。</p><p>就这样做了2个月后，发现目标和计划很多时候是不可能100%完成的，这两个月计划的完成度在70-80%，因为计划永远跟不上变化，每周的事情不是全都可以提前计划好的，所以不要急功近利，写太多计划，需要留有一定的余量。但是总体来讲，自从做了这些工作后，比一开始只做计划，没有行动好太多了。</p><p><img src="https://cdn.lion1ou.tech/image-1.png?imageslim"></p><h3 id="周末时光"><a href="#周末时光" class="headerlink" title="周末时光"></a>周末时光</h3><p>今年随着儿子慢慢长大，小家伙已经不再是那个抱在手里只知道喝奶的奶娃娃了。他每天都在给你惊喜，每天都在长大，很可能你一不留神他就不要你抱抱亲亲举高高了。平时上班时间比较长，陪他的时间也不多。所以今年周末的大部分时间都在享受这个过程，没几个月的时间我们几乎把西湖区附近大大小小的商场都逛遍了，入秋后天气冷了加上疫情，我们开始选择去周边公园草地晒太阳。小家伙很喜欢，一会在草地上飞奔，一会蹲在地下看蚂蚁，一会又抬头看飞机。只要这么陪着他，你就能被他的快乐感染。</p><p><img src="https://cdn.lion1ou.tech/WechatIMG30.jpeg?imageslim"></p><h2 id="关于其他"><a href="#关于其他" class="headerlink" title="关于其他"></a>关于其他</h2><h3 id="关于工具"><a href="#关于工具" class="headerlink" title="关于工具"></a>关于工具</h3><p>平时比较喜欢关注一些工具，新奇的软件，也会逛逛新趣集和ProductHunt。这里推荐几个实用小工具：</p><ol><li> uTools，可以称得上是一个快捷百宝工具箱，任何场景下都可通过快捷键呼出，内部有各式各样的小工具插件可以选择。</li><li>Snipaste，一个快速截图工具，支持圈选标记等基础操作，还支持回退到上次截图记录，并且可以修改，贼好用，关键还免费。</li><li>Moom，一个Mac上的窗口管理工具，之前一直是用破解版的，结果这次升级mac后不能用了。然后果断APP Store上买了正版。</li><li>Inoreader，这是一款RSS服务，用来订阅一些RSS、博客等文章。由于现在短视频泛滥，很多时候会被推荐系统带着走，一不注意1-2个小时就过去了，很难深入获取一些实质性的信息。所以有段时间就去研究了一下RSS，国内像轻芒、即刻都已经不再是原来的RSS味道了；通过群晖自建的RSS，整体页面和功能都比较简陋，效果不理想；又找了几个国外的RSS平台，最后选择了Inoreader。因为它整体的页面交互体验都不错，免费用户还支持150个订阅源，足够用了，而且对接各个RSS客户端软件都很方便，有配套的chrome插件，手机端和Mac上（Reeder）体验都不错。</li><li>语雀，这个就不再太多介绍了。对比使用了印象笔记、有道云笔记、wolai、notion等，最终选择了完全迁移到语雀。这里只说几点比较符合我使用习惯的：1. 完美支持markdown，支持代码块，代码块支持伸缩，支持脑图、流程图等 2. 小记功能，非常适合零碎的记录， 3. 支持结构化目录，可以很好的整理和归纳学习笔记和日常笔记。不过有个不足的是：没有移动端，需要使用支付宝小程序，整体体验不是很好。</li></ol><p><img src="https://cdn.lion1ou.tech/image-2.png?imageslim"></p><h3 id="自建项目"><a href="#自建项目" class="headerlink" title="自建项目"></a>自建项目</h3><ol><li>日历插件<br>这个项目的契机是这样的，原先需要在电脑上看日历，都是在浏览器上搜一个日历页面打开。后来有了uTools之后就方便很多，但是在使用的过程中发现，日历插件有bug还一直没修复，不支持法定假日，24节气等，而且整体UI也比较简陋。然后就萌生了一个想法，要不自己搞一个!?  说干就干，趁着某个空闲的周末，用Vue3搞了个雏形，就上线发布了。本想自己用用的，结果收到了很多用户的反馈，后面就根据反馈不定期更新了几个版本，于是就有了这个项目。毕竟有用户了，所以打算后续慢慢打磨它，让它支持更多场景，成为一个实用小工具。目前也发了一个h5版本，<a target="_blank" rel="noopener" href="http://toy.lion1ou.tech/calendar/dist/index.html#/">跳转日历小工具</a>。</li></ol><p><img src="https://cdn.lion1ou.tech/image-3.png?imageslim"></p><ol start="2"><li>初韵茶苑<br>因为自家是做茶叶的 – 福鼎白茶。也有自己的品牌和门店，于是就自己搭了个官网，其实这次是第三次改版了，之前都是网上找的静态页面模板随便改改就上线了。这次准备从零开始，主要技术栈是Nuxt + Ant design + koa实现的一套包含前后台的小型博客系统，并利用爬虫爬取白茶相关文章充实内容。这个项目应该是去年开始，利用周末时间从原型到设计，再到编码上线，大概花了小半年时间吧。不过由于法律意识的缺失，上线后不久就被举报了，因为宣传文案和一些文章的内容不符合广告法的规定。所以紧急下线了大部分文章和宣传文案。由于没有想好后续需要如何整改，所以现在的官网有点残缺。<a target="_blank" rel="noopener" href="https://www.chuyunt.com/">跳转初韵茶苑</a> （有喜欢喝茶的小伙伴，可以淘宝搜索初韵茶苑，来看看哟~ 源头厂家，物美价廉）</li></ol><p><img src="https://cdn.lion1ou.tech/image-4.png?imageslim"></p><ol start="3"><li>重拾博客<br>把丢了很久的个人博客重新捡起来了，当时也写过一篇文章。<a href="https://lion1ou.tech/2021-10/%E9%87%8D%E6%8B%BE%E5%8D%9A%E5%AE%A2/">跳转重拾博客</a></li></ol><h3 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h3><p>今年看书计划和实际完成度还是有不少差距，不过在读完的书里，我想推荐的有两本：</p><ol><li>《认知觉醒》</li><li>《最重要的事情只有一件》<br>主要都是讲个人成长方面，可能可以触发你更深层次的思考，或许可以帮助你走出当前的困惑。</li></ol><p><img src="https://cdn.lion1ou.tech/image-5.png?imageslim"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>最后，整篇文章断断续续写了3-4个小时，发现写作能力已经退化到小学生水平了，不过还是坚持写完了。为什么一定要写呢？可能是因为不想一年年糊里糊涂就过去了，想给过去的日子一个交代吧，写到这里才反应过来，过完2021年，就临来自己的而立之年了。莫名的感觉肩上的担子也越来越重了，希望接下来的日子可以按着自己的目标，一步一步实现，生活越来越好，技术越来越强！最后的最后祝有缘看到这篇文章的朋友，新年快乐，心想事成！！</p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端监控的自助分析能力</title>
      <link href="/2021-11/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E7%9A%84%E8%87%AA%E5%8A%A9%E5%88%86%E6%9E%90%E8%83%BD%E5%8A%9B/"/>
      <url>/2021-11/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E7%9A%84%E8%87%AA%E5%8A%A9%E5%88%86%E6%9E%90%E8%83%BD%E5%8A%9B/</url>
      
        <content type="html"><![CDATA[<p>在来新公司差不多3个月的时候，老板让我完成一下组内的KPI — 在公司内部的技术分享会上来波分享。刚开始还是有点慌的，但是换位想想，其实可以把这个机会当成自己这段时间的工作总结，也可以锻炼锻炼分享能力，何乐而不为呢。然后果(you)断(yu)的就答应了。</p><p>其实想起来写这篇文章，分享已经结束差不多要一个月了。想想不能就这样结束了，还是要整理一些资料做为产出。所以就有了这篇文章，对分享PPT做了删减和去敏。</p><span id="more"></span><h2 id="前端监控系统"><a href="#前端监控系统" class="headerlink" title="前端监控系统"></a>前端监控系统</h2><p>一般的监控系统会分为四个部分，包括采集上报、日志存储、统计分析和数据展示。在我们公司内部是通过两个项目来分拆实现。</p><p><img src="http://cdn.lion1ou.tech/e558f6c581a944658976ed809a1c3ccd-0006.jpg?imageslim"></p><p>下面介绍一下系统流程，我们的数据会通过两种形式上传，一种是性能数据，一种是业务数据。性能数据则会按照流程图的顺序，将数据导入kafka，flink进行消费，然后存入clickhouse，clickhouse再根据相应聚合函数，生成对应的物化视图，便于node查询。因为clickhouse是一个擅长联机分析(OLAP)的数据库，但是对于常规的事务查询不太适合，所以我们会使用postgre作为业务逻辑存储。</p><p><img src="http://cdn.lion1ou.tech/e558f6c581a944658976ed809a1c3ccd-0007.jpg?imageslim"></p><p>上面流程图中讲到，数据存储和清洗的过程，对于前端同学来说，可能还是比较陌生的。我们先来一些下面几个名词。kafka、Flink、Clickhouse、物化视图。</p><p><img src="http://cdn.lion1ou.tech/e558f6c581a944658976ed809a1c3ccd-0008.jpg?imageslim"></p><p>上面这个图大家应该有了大概的认识，我这边重点讲讲物化视图。物化视图和普通视图对比，普通视图其实是SQL的封装，并不存储数据，但物化视图不同，它是会存储查询结果的中间状态，可以理解为是一个非常趋近于表的视图。如图我们举个例子，需要创建物化视图，就需要我们根据图上的SQL语句来创建。创建完成后，（看左下角图）当主表数据添加时，就会触发物化视图的sql，然后结果数据就会存储到由物化视图引擎生成的私有表。下次查询物化视图时，就会直接去查询私有表，而不是主表的数据。这样的实现，其实就是典型的空间换时间的思路。</p><p><img src="http://cdn.lion1ou.tech/e558f6c581a944658976ed809a1c3ccd-0009.jpg?imageslim"></p><p>介绍完数据存储过程，接下来就来看看我们的前端监控系统吧，看看他是如何实现的。整个系统主要分为三个部分，一个是数据层，就是上面讲到的用于保障数据来源。第二是逻辑层，主要负责页面展示逻辑，数据分析逻辑。第三是展示层，主要负责数据分析展示和信息展示。</p><p><img src="http://cdn.lion1ou.tech/e558f6c581a944658976ed809a1c3ccd-0011.jpg?imageslim"></p><p>下面是我们系统主要的几个功能：</p><p><img src="http://cdn.lion1ou.tech/e558f6c581a944658976ed809a1c3ccd-0012.jpg?imageslim"></p><h2 id="自助分析能力"><a href="#自助分析能力" class="headerlink" title="自助分析能力"></a>自助分析能力</h2><p>看到自助分析，大家肯定会问，什么是自助分析能力。其实自助分析能力，可以简单理解为可视化的SQL能力。通过一些表单的形式，或者是一些简易的SQL拼装，就能查询到自己想要结果的能力。</p><p>那为什么要做自助分析能力呢？主要是下面三方面原因：</p><p><img src="http://cdn.lion1ou.tech/e558f6c581a944658976ed809a1c3ccd-0013.jpg?imageslim"></p><p>下面这张图，主要介绍了我们自助分析能力的几个主要模块：</p><p><img src="http://cdn.lion1ou.tech/e558f6c581a944658976ed809a1c3ccd-0014.jpg?imageslim"></p><p>我抽两个比较重要的模块展开来讲一下，下面这个是我们的查询模块，也是最主要的模块之一了。通过两种不同的查询方式，拆成简单查询和高级查询，简单查询主要是通过表单方式，选择和填写查询条件，最终组装成查询语句。高级查询，则是可以通过sql的方式，进行一些复杂查询，并支持输入联想提示。</p><p><img src="http://cdn.lion1ou.tech/e558f6c581a944658976ed809a1c3ccd-0015.jpg?imageslim"></p><p>实现原来主要是通过对查询语句的拆解、校验和组装，形成一个可靠的查询SQL，得到最终的结果。</p><p><img src="http://cdn.lion1ou.tech/e558f6c581a944658976ed809a1c3ccd-0016.jpg?imageslim"></p><p>另外一个比较重要的模块就是自建看板了，自建看板主要是用于上面查询出的结果的聚合展示，独立分析。</p><p><img src="http://cdn.lion1ou.tech/e558f6c581a944658976ed809a1c3ccd-0017.jpg?imageslim"></p><p>通过将查询类型、查询规则、图表类型和图表配置聚合，形成独立的查询单元。当查询单元和单一的时间组合，就成了自助查询。当多个查询单元和时间、权限组合，就形成了自建看看板。</p><p><img src="http://cdn.lion1ou.tech/e558f6c581a944658976ed809a1c3ccd-0018.jpg?imageslim"></p><p>从上面的介绍可以看出，自助分析能力，主要做了三件事。简化SQL成本，保证数据安全，提高看板灵活度。</p><p><img src="http://cdn.lion1ou.tech/e558f6c581a944658976ed809a1c3ccd-0020.jpg?imageslim"></p><p>以上就是之前分享的主要内容了，总算能给自己一个交代了。</p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重拾博客</title>
      <link href="/2021-10/%E9%87%8D%E6%8B%BE%E5%8D%9A%E5%AE%A2/"/>
      <url>/2021-10/%E9%87%8D%E6%8B%BE%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>已经有将近一年没有发文章了，中间换了一次主题，然后大致配置了一下，就一直没关注了。 然后一直忙，直到这段时间，翻了翻博客发现，评价好像有问题，数据统计分析也有问题。而且之前在阿里云申请的lion1ou.win的域名被签到国际站了，而且还备案不了。而且由于刚换工作，周末时间也空闲了一些。然后就萌生重拾博客的想法，顺便再梳理一下自己做过的一些小项目。说干就干，9月底开始动手。</p><span id="more"></span><h2 id="升级Hexo"><a href="#升级Hexo" class="headerlink" title="升级Hexo"></a>升级Hexo</h2><h3 id="升级依赖，修改配置"><a href="#升级依赖，修改配置" class="headerlink" title="升级依赖，修改配置"></a>升级依赖，修改配置</h3><ol><li>修改 <code>package.json</code> 将默认依赖全部升级到了最新版本</li></ol><p><img src="https://cdn.chuyunt.com/picGo/update-hexo.png?imageslim"></p><ol start="2"><li>根据官网完完整整的修改了一遍config</li></ol><blockquote><p>这里就不展开了，官网有非常详细的说明，比之前完善了不少。 地址在这：<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/configuration">https://hexo.io/zh-cn/docs/configuration</a></p></blockquote><ol start="3"><li>整理原来使用的插件和大家都在用的hexo插件</li></ol><h3 id="添加插件"><a href="#添加插件" class="headerlink" title="添加插件"></a>添加插件</h3><ol><li><strong>字数统计</strong>：<a target="_blank" rel="noopener" href="https://github.com/willin/hexo-wordcount">https://github.com/willin/hexo-wordcount</a></li></ol><blockquote><p>在文章中显示文章字数、阅读时长信息</p></blockquote><pre><code class="bash">npm i --save hexo-wordcount</code></pre><pre><code class="yml">postInfo:  date: true  update: false  wordCount: false # 设置文章字数统计为 true.  totalCount: false # 设置站点文章总字数统计为 true.  min2read: false # 阅读时长.  readCount: false # 阅读次数.</code></pre><p>如果是使用现成的主题，只需要配置对应的config就会好了，如果是自己搞主题，就根据readme，想好添加到那个地方吧。</p><pre><code class="js">// 字数统计 WordCountwordcount(post.content)// 阅读时长预计 Min2Readmin2read(post.content)// 设置阅读速度 Set Reading Speed: (p.s. (v3.0.0 added))min2read(post.content, &#123;cn: 300, en: 160&#125;)// 总字数统计 TotalCounttotalcount(site)</code></pre><ol start="2"><li><strong>添加 RSS 订阅支持</strong>: <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo-generator-feed">https://github.com/hexojs/hexo-generator-feed</a></li></ol><blockquote><p>感觉RSS订阅应该是博客最标志性功能之一吧，这个还是要加上的</p></blockquote><pre><code class="bash">npm install hexo-generator-feed --save</code></pre><pre><code class="yml">feed:  enable: true  type:     - atom    - rss2  path:    - atom.xml    - rss2.xml  limit: 10  hub:  content:  content_limit: 140  content_limit_delim: &#39; &#39;  order_by: -date  icon: icon.png  autodiscovery: true  template:</code></pre><ol start="3"><li><strong>生成网站地图</strong></li></ol><pre><code class="bash">npm install hexo-generator-sitemap --save     </code></pre><pre><code class="yml">sitemap:  path: sitemap.xml  template: ./sitemap_template.xml  rel: false  tags: true  categories: true</code></pre><p>可用于提交给百度</p><pre><code class="bash">npm install hexo-generator-baidu-sitemap --save</code></pre><pre><code class="yml">baidusitemap:  path: baidusitemap.xml</code></pre><ol start="4"><li><strong>本地搜索</strong>: <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search">https://github.com/wzpan/hexo-generator-search</a></li></ol><pre><code class="yml">search:  path: search.xml  field: post  content: true  format: html  limit: 100</code></pre><blockquote><p>如果只是这样，本地搜索还是不可用的，还需要相应的主题是支持的，主题内会有相应的逻辑来匹配对应的搜索情况。</p></blockquote><h2 id="查看数据"><a href="#查看数据" class="headerlink" title="查看数据"></a>查看数据</h2><p>因为之前接过 google analysis，然后就去看了看站点的数据情况，整体流量还是很少的，主要来源还是谷歌搜索，另外还有一些其他博客平台，因为之前有些文章在多个平台发布过，并被多个网站收录了，吸引了一些流量。</p><ul><li>页面访问量数据</li></ul><p><img src="https://cdn.chuyunt.com/picGo/google-analysis.png?imageslim"></p><ul><li>站点来源数据</li></ul><p><img src="https://cdn.chuyunt.com/picGo/20211010214303.png?imageslim"></p><p>根据谷歌分析的一些数据，对站点的文章做了大量的删减，去除了一批内容比较陈旧，或者流量为零的文章。</p><blockquote><p>这里补充一下，其实站点之前也接入了百度统计，但是在百度统计看到的数据与谷歌分析的还是有一定差距，而且百度统计只能看到最近30天的数据。所有有需要的同学，还是推荐使用谷歌</p></blockquote><h2 id="域名迁移"><a href="#域名迁移" class="headerlink" title="域名迁移"></a>域名迁移</h2><ul><li>买域名</li></ul><p>接下来就是迁移域名了，首先要买一个新域名，在aliyun上对比了一下价格和可备案，并且跟博客有点关系。所以就有了现在的 lion1ou.tech </p><ul><li>新域名备案</li></ul><p>域名备案还是一个比较麻烦的过程，需要等待几天的审核时间。</p><ul><li>老域名续费</li></ul><p>担心老域名马上过期的话，其他外部来源将完全访问不了该站点，所以就去给老域名续了一下。由于老域名是在aliyun国际站，所以用常规支付方式是完成不了支付的，博主又没有VISA信用卡。所以只能求助万能的淘宝了。不过折算下来汇率将近1: 8。</p><p>接下来就是比较麻烦的事情了，之前本来想的是找个第三方转发平台：<a target="_blank" rel="noopener" href="https://www.mfpad.com/zh/login">米发</a>来配置一下就好了，结果发现效果不是很理想，测试过程中，始终不成功。也不知道问题出在哪里，所以只能放弃。</p><p>后来仔细想了想，下面这个方案还是比较完美的。</p><ul><li><p>老域名重定向到新域名</p><ul><li>新建一个github帐号</li><li>使用github page、index.html、404.md文件，来做重定向</li><li><a target="_blank" rel="noopener" href="https://github.com/chuyunt/chuyunt.github.io">https://github.com/chuyunt/chuyunt.github.io</a></li></ul></li></ul><p>中间我还做了一件事，就是我把hexo的永久路径规则给修改了，这样老的外链，就跳转不到对应的文章了。这怎么行，于是就在利用404.md，做了一个地址映射，把老地址和新地址一一对应了一下，算是完美解决了。</p><p>到这里算是把博客梳理清楚了。接下来就对之前fork的主题开刀了。 在这里还是要感谢一下原作者：<a target="_blank" rel="noopener" href="https://github.com/KevinOfNeu/hexo-theme-xoxo">https://github.com/KevinOfNeu/hexo-theme-xoxo</a></p><h2 id="自建主题"><a href="#自建主题" class="headerlink" title="自建主题"></a>自建主题</h2><p>打开代码之后，首先干的事情是，先对结构做了一下了解。根据自己的喜好调整了部分样式。</p><p>接下来对 tags、search页面都做了修改，保证在新版本hexo上，主题能够正常运行。</p><p>下面大概列一下做了哪些事情：</p><ul><li>将主题名字改成了sprite，雪碧的意思；希望后续的主题改造，能够一直秉持着这个风格</li><li>升级了gulp版本，优化了工作流</li><li>添加了赞赏功能</li><li>优化了footer</li><li>对config做了完全的配置梳理，支持更多配置，并配有详细注释</li></ul><p>感兴趣的同学，可以看看这个主题：<a target="_blank" rel="noopener" href="https://github.com/lion1ou/hexo-theme-sprite">https://github.com/lion1ou/hexo-theme-sprite</a></p><p>到这里，重拾博客的基础工作差不多都做完了，接下来希望可以坚持下来，持续输出一些优质文章，持续更新sprite主题。 加油！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端监控系列-数据上报</title>
      <link href="/2020-11/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E7%B3%BB%E5%88%97-%E6%95%B0%E6%8D%AE%E4%B8%8A%E6%8A%A5/"/>
      <url>/2020-11/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E7%B3%BB%E5%88%97-%E6%95%B0%E6%8D%AE%E4%B8%8A%E6%8A%A5/</url>
      
        <content type="html"><![CDATA[<p>性能监控和错误上报只是辅助功能，不应阻塞页面加载，因此只有当页面完成加载后，我们才进行数据获取和上报（实际上，页面加载完成前也获取不到必要信息），性能数据可以在页面加载完之后上报，尽量不要对页面性能造成影响。</p><span id="more"></span><h2 id="上报时机"><a href="#上报时机" class="headerlink" title="上报时机"></a>上报时机</h2><p>使用<code>window.requestIdleCallback()</code>，该方法将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。</p><pre><code class="js">window.onload = () =&gt; &#123;     if (window.requestIdleCallback) &#123;        window.requestIdleCallback(() =&gt; &#123;            monitor.performance = getPerformance()            monitor.resources = getResources()        &#125;)    &#125; else &#123;        setTimeout(() =&gt; &#123;            monitor.performance = getPerformance()            monitor.resources = getResources()        &#125;, 0)    &#125;&#125;</code></pre><p>当然，你也可以设一个定时器，循环上报。不过每次上报最好做一下对比去重再上报，避免同样的数据重复上报。</p><h2 id="数据上报"><a href="#数据上报" class="headerlink" title="数据上报"></a>数据上报</h2><p>对于一个埋点方案来说，数据上报有两个点需要着重考虑：</p><ul><li>对跨域做特殊处理。</li><li>页面销毁后，如何还能够将未上传的埋点数据成功上报？</li></ul><p>传统的XHR发送数据请求的方式，对上面提到的两个点都无能为力。在数据上报过程中，较为常用的有两种方式：</p><ul><li>动态创建img标签，在 img.src 中拼接url的方式发送请求</li><li>调用 sendBeacon 接口发送数据</li></ul><h3 id="new-img"><a href="#new-img" class="headerlink" title="new img"></a>new img</h3><p>利用<code>img</code>标签的<code>src</code>属性发送请求的方式，具体执行方案如下：</p><pre><code class="javascript">let _img = new Image();_img.src = `$&#123;url&#125;?$&#123;util.spliceParam(params)&#125;`;_img.onload = _img.onerror = function() &#123;&#125;</code></pre><p>它非常契合埋点数据上报这个应用场景：</p><ol><li>只上报的数据不需要接收响应；</li><li>img的src属性天然地不存在跨域问题。</li></ol><p>这种使用方式也存在缺陷。首先对于src 中的URL内容是有大小限制的，太大的数据量不适用。详细看<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers/417184#417184">这里</a>。其次，在页面卸载的时候，若存在数据未发送的情况，会先将对应的数据发送完，再执行页面卸载。这种情况下，会在体验上给使用者带来不方便。</p><h3 id="sendBeacon"><a href="#sendBeacon" class="headerlink" title="sendBeacon"></a>sendBeacon</h3><p>sendBeacon方法是一个异步、非阻塞的数据传输方法。具体使用方式如下：</p><pre><code class="javascript">window.navigator.sendBeacon &amp;&amp; window.navigator.sendBeacon(url, params)</code></pre><p>它的特点是：</p><ul><li>Beacon请求是Post方式。</li><li>Beacon请求优先避免与关键操作和更高优先级的网络请求竞争。</li><li>Beacon请求可以有效地合并，以优化移动设备上的能量使用。</li><li>Beacon保证页面卸载之前启动信标请求，并允许运行完成且不会阻塞请求或阻塞处理用户交互事件的任务。</li><li>返回值：sendBeacon 方法被执行后返回一个布尔值，<code>true</code>代表用户代理成功地将信标请求加入到队列中，否则返回<code>false</code>。</li></ul><p>对于sendBeacon方法，它的局限性体现在：</p><ul><li>不能跨域，需要服务端设置。</li><li>新特性接口，兼容性存在问题。</li></ul><p>因此，在实际的应用过程中，需要针对实际情况，结合 Img 标签 与 sendBeacon 的方式一起使用。</p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端监控系列-错误监控</title>
      <link href="/2020-11/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E7%B3%BB%E5%88%97-%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7/"/>
      <url>/2020-11/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E7%B3%BB%E5%88%97-%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<p>错误监控主要是为了在sls看板上，能更加全面的展示我们项目的情况，所以这边加了个错误上报的口子，其实错误上报很简单，只需要全局捕获几种类型的错误就好了。</p><span id="more"></span><pre><code class="javascript">// 监听资源错误window.addEventListener(  &#39;error&#39;,  (e) =&gt; &#123;    // 避免重复上报    if (e.target !== window) &#123;      reportError(&#123; e_name: &#39;addEventListenerError&#39;, e_msg: nodeToString(e.target).replace(&#39;&lt;&#39;, &#39;&lt;&#39;).replace(&#39;&gt;&#39;, &#39;&gt;&#39;), e_stack: e.target.currentSrc &#125;)    &#125;  &#125;,  true)// 监听js错误window.onerror = function (msg, url, row, col, error) &#123;  if (msg &amp;&amp; url &amp;&amp; row &amp;&amp; col &amp;&amp; error) &#123;    reportError(&#123; e_name: &#39;onError&#39;, e_msg: error.message, e_stack: error.stack &#125;)  &#125;&#125;// 监听promise相关报错window.addEventListener(  &#39;unhandledrejection&#39;,  (e) =&gt; &#123;    if (e.reason) &#123;      reportError(&#123; e_name: &#39;unhandledRejection&#39;, e_msg: e.reason.message, e_stack: e.reason.stack &#125;)    &#125;  &#125;,  true)// 监听console.errorconst consoleError = window.console.errorwindow.console.error = function (e) &#123;  if (e.name || e.message) &#123;    reportError(&#123; e_name: &#39;consoleError&#39;, e_msg: e.message, e_stack: e.stack &#125;)  &#125;  consoleError &amp;&amp; consoleError.apply(window, arguments)&#125;</code></pre><p>window.onerror 和 window.addEventListener(‘error’)的异同:</p><p>相同点是：</p><ol><li>都可以捕获到 window 上的 js 运行时错误。</li></ol><p>区别是：</p><ol><li>捕获到的错误参数不同</li><li>window.addEventListener(‘error’)可以捕获资源加载错误，但是 window.onerror 不能捕获到资源加载错误</li></ol><pre><code class="javascript">window.onerror = function (msg, url, row, col, error) &#123;  /**   * @param &#123;String&#125;  msg    错误信息   * @param &#123;String&#125;  url    出错文件   * @param &#123;Number&#125;  row    行号   * @param &#123;Number&#125;  col    列号   * @param &#123;Object&#125;  error  错误详细信息   */  console.log(&quot;+++++++++++++++++++++监听了onerror&quot;, msg, url, row, col, error);  if (msg) &#123;    reportError(&#123; errorName: &quot;onerror&quot;, errorMsg: msg &#125;);  &#125;  return true;&#125;;window.addEventListener(&#39;error&#39;, (e) =&gt; &#123;  console.log(&quot;+++++++++++++++++++++监听了onerror&quot;, msg, url, row, col, error);  if (e.message || e.error) &#123;    reportError(&#123; e_name: &#39;addEventListenerError&#39;, e_msg: e.message, e_stack: e.error.stack &#125;) // stack数据太长，无法上报  &#125;&#125;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端监控系列-性能监控</title>
      <link href="/2020-10/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E7%B3%BB%E5%88%97-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/"/>
      <url>/2020-10/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E7%B3%BB%E5%88%97-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<p>什么是性能监控，主要要监控哪些指标，有什么意义呢？</p><p>我们经常会遇到这样一个情况，发布在线上的页面，有一天老板或者是其他同学跟你反馈，你的页面怎么这么慢，是不是有bug。然后你会自己打开对应的页面，看了看感觉速度正常，也算是秒开吧。然后你再关闭缓存，再试了一下，还是好的呀，哪里慢了？这个时候你就很难评估出来这个页面到底是真慢还是某个设备的网络问题。</p><p>这种在单个设备上的表现，其实很难准确反映我们的页面在线上运行的真实情况。线上环境包括不同的设备、不同的宿主环境、不同的运营商网络、不同的地区这些关联因素，所以我们就需要有一套可以监控线上环境运行情况的系统。</p><span id="more"></span><h2 id="性能监控指标"><a href="#性能监控指标" class="headerlink" title="性能监控指标"></a>性能监控指标</h2><p>那监控线上环境，我们需要监控哪些指标呢？哪些指标能准确的反映出前端页面的运行性能呢？</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/174505/1606816139610-a4319fdd-55cd-49a0-8b8f-42cad87e9129.png#align=left&display=inline&height=528&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1056&originWidth=2372&size=252964&status=done&style=none&width=1186" alt="image.png"><br>chrome上的performance指标</p><ul><li>first paint (FP)：这个指标标志着浏览器渲染第一个像素点的时间。</li><li>first contentful paint (FCP)：和FP标志着任意一个像素点被渲染的时间不同，FCP 标志着浏览器渲染第一个内容元素的时间，这些内容元素可以是text、image、svg、canvas。</li><li>First meaningful paint (FMP)：这个指标标志着首屏最重要的一块区域的渲染，通常是用户最关注的区域。比如视频网站的视频播放区域，搜索网站的第一个搜索结果区域，又或者是购物网站的照片首图。（Lighthouse 6.0 中已不推荐使用 FMP）</li><li>Largest Contentful Paint（LCP）：由 Web 孵化器社区组（WICG）在 <a target="_blank" rel="noopener" href="https://wicg.github.io/largest-contentful-paint/#sec-intro">Largest Contentful Paint API</a> 中提出，是一个非标准化的 Web 性能度量。<strong>可视区域中最大的内容元素呈现</strong>到屏幕上的时间，用以估算页面的主要内容对用户可见时间。</li><li>First Screen Paint（FSP）：由百度在 W3C 标准提案 <a target="_blank" rel="noopener" href="https://www.w3.org/Submission/first-screen-paint/">First Screen Paint</a> 中提出。页面从开始加载到首屏内容全部绘制完成的时间，用户可以看到首屏的全部内容。</li><li>Onload Event（L）: 代表整个HTML 渲染完成，包括所有资源、样式都已经在家完成</li><li>Time to interactive (TTI)：由 Web 孵化器社区组（WICG）在 <a target="_blank" rel="noopener" href="https://github.com/WICG/time-to-interactive">Time To Interactive</a> 中提出，是一个非标准化的性能度量指标。这个指标表示浏览器已经渲染完了我们首屏需要显示的内容并且已经准备好接受用户的交互信息了，也标志着程序是否可用。</li><li>First CPU Idle（FCI）：由网络孵化器社区小组提出的 First Interactive 指标，并已被用于各种工具中。这个指标在 LightHouse 中称为 First CPU Idle（FCI）。页面第一次可以响应用户输入的时间。FCI 和 TTI 都是页面可以响应用户输入的时间。FCI 发生在<strong>用户可以开始</strong>与页面交互时；TTI 发生在 <strong>用户完全能够（可持续）</strong> 与页面交互时。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/174505/1606815971662-13829ba0-a2a7-4e1b-9ee3-91023f7191bd.png#align=left&display=inline&height=496&margin=%5Bobject%20Object%5D&name=Snipaste_20201201_174554.png&originHeight=496&originWidth=2216&size=380963&status=done&style=none&width=2216" alt="Snipaste_20201201_174554.png"><br>所以根据上面这些性能指标，我们大概可以确定出来几个对应的评估标准。</p><table><thead><tr><th>用户体验核心指标</th><th>定义</th><th>衡量指标</th></tr></thead><tbody><tr><td>白屏时间</td><td>页面开始有内容的时间，在没有内容之前是白屏</td><td>FP 或 FCP</td></tr><tr><td>首屏时间</td><td>可视区域内容已完全呈现的时间</td><td>FSP</td></tr><tr><td>可交互时间</td><td>用户第一次可以与页面交互的时间</td><td>FCI</td></tr><tr><td>可流畅交互时间</td><td>用户第一次可以持续与页面交互的时间</td><td>TTI</td></tr></tbody></table><h2 id="性能指标API"><a href="#性能指标API" class="headerlink" title="性能指标API"></a>性能指标API</h2><p>关于前端性能指标，W3C 定义了强大的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Performance_API">Performance API</a>，其中又包括了 High Resolution Time 、 Frame Timing 、 Navigation Timing 、 Performance Timeline 、Resource Timing 、 User Timing 等诸多具体标准。Web 性能标准则是在 window 上添加了 performance 属性，通过 window.performance 返回一个 Performance 对象。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/174505/1606903311306-85a8757f-e27d-4f8f-a0ff-125eebc72946.png#align=left&display=inline&height=1850&margin=%5Bobject%20Object%5D&name=Snipaste_20201202_180140.png&originHeight=1850&originWidth=2556&size=540403&status=done&style=none&width=2556" alt="Snipaste_20201202_180140.png"><br>对象中包含了很多用于衡量性能的属性和方法，而这些属性和方法由多种 Web 性能标准定义。 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904152317820935">详细介绍可以查看这篇文章</a><br>不过上面的对象在不同浏览器上也有不同，下面是safari的数据<br><img src="https://cdn.nlark.com/yuque/0/2020/png/174505/1606904676320-7142ccc4-0801-45e0-8ee5-fccc9f47ed0e.png#align=left&display=inline&height=702&margin=%5Bobject%20Object%5D&name=image.png&originHeight=787&originWidth=1012&size=141392&status=done&style=none&width=903" alt="image.png"></p><h3 id="performance-navigation"><a href="#performance-navigation" class="headerlink" title="performance.navigation"></a>performance.navigation</h3><ul><li>redirectCount<br>如果有重定向的话，页面通过几次重定向跳转而来</li><li>type<ul><li>0 即 TYPE_NAVIGATENEXT 正常进入的页面（非刷新、非重定向等）</li><li>1 即 TYPE_RELOAD 通过 window.location.reload() 刷新的页面</li><li>2 即 TYPE_BACK_FORWARD 通过浏览器的前进后退按钮进入的页面（历史记录）</li><li>255 即 TYPE_UNDEFINED 非以上方式进入的页面</li></ul></li></ul><p>navigation字段统计的是一些网页导航相关的数据：</p><ol><li>redirectCount:重定向的数量（只读），但是这个接口有同源策略限制，即仅能检测同源的重定向；</li><li>type 返回值应该是0,1,2 中的一个。分别对应三个枚举值:<ul><li>0 : TYPE_NAVIGATE (用户通过常规导航方式访问页面，比如点一个链接，或者一般的get方式)</li><li>1 : TYPE_RELOAD (用户通过刷新，包括JS调用刷新接口等方式访问页面)</li><li>2 : TYPE_BACK_FORWARD (用户通过后退按钮访问本页面)</li></ul></li></ol><h3 id="performance-timing"><a href="#performance-timing" class="headerlink" title="performance.timing"></a>performance.timing</h3><p>下面时间对照图对应上面performance.timing对象<img src="https://cdn.nlark.com/yuque/0/2020/png/174505/1607068442578-2e2c59a8-0dec-4a3d-840d-8a94373fc835.png#align=left&display=inline&height=1055&margin=%5Bobject%20Object%5D&name=pageload-1886-93237e4321.png&originHeight=1055&originWidth=1886&size=41185&status=done&style=none&width=1886" alt="pageload-1886-93237e4321.png"></p><table><thead><tr><th>名称</th><th>注释</th></tr></thead><tbody><tr><td>navigationStart</td><td>浏览器窗口的前一个网页关闭时发生unload事件时的Unix时间戳，属于最前的测量时间点</td></tr><tr><td>unloadEventStart</td><td>前网页与当前网页同属一个域名时，返回前一个网页的unload事件发生时的Unix时间戳</td></tr><tr><td>unloadEventEnd</td><td>前网页与当前网页同属一个域名时，返回前一个网页unload事件的回调函数结束时的Unix时间戳</td></tr><tr><td>redirectStart</td><td>返回第一个HTTP跳转开始时的Unix时间戳</td></tr><tr><td>redirectEnd</td><td>返回最后一个HTTP跳转结束时的Unix时间戳</td></tr><tr><td>fetchStart</td><td>返回浏览器准备使用HTTP请求读取文档等资源时的Unix时间戳，在网页查询本地缓存之前发生</td></tr><tr><td>domainLookupStart</td><td>返回域名查询开始时的Unix时间戳。如果使用持久连接，或者信息是从本地缓存获取的，则返回值等同于fetchStart属性的值</td></tr><tr><td>domainLookupEnd</td><td>返回域名查询结束时的Unix毫秒时间戳。如果使用持久连接，或者信息是从本地缓存获取的，则返回值等同于fetchStart属性的值</td></tr><tr><td>connectStart</td><td>返回HTTP请求开始向服务器发送时的Unix毫秒时间戳。如果使用持久连接（persistent connection），则返回值等同于fetchStart属性的值</td></tr><tr><td>connectEnd</td><td>返回浏览器与服务器之间的连接建立时的Unix毫秒时间戳。如果建立的是持久连接，则返回值等同于fetchStart属性的值。连接建立指的是所有握手和认证过程全部结束</td></tr><tr><td>secureConnectionStart</td><td>返回浏览器与服务器开始安全链接的握手时的Unix毫秒时间戳。如果当前网页不要求安全连接，则返回0</td></tr><tr><td>requestStart</td><td>返回浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的Unix毫秒时间戳</td></tr><tr><td>responseStart</td><td>返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的Unix毫秒时间戳</td></tr><tr><td>responseEnd</td><td>返回浏览器从服务器收到（或从本地缓存读取）最后一个字节时（如果在此之前HTTP连接已经关闭，则返回关闭时）的Unix毫秒时间戳</td></tr><tr><td>domLoading</td><td>返回当前网页DOM结构开始解析时（即Document.readyState属性变为“loading”、相应的readystatechange事件触发时）的Unix毫秒时间戳</td></tr><tr><td>domInteractive</td><td>返回当前网页DOM结构结束解析、开始加载内嵌资源时（即Document.readyState属性变为“interactive”、相应的readystatechange事件触发时）的Unix毫秒时间戳</td></tr><tr><td>domContentLoadedEventStart</td><td>返回当前网页DOMContentLoaded事件发生时（即DOM结构解析完毕、所有脚本开始运行时）的Unix毫秒时间戳</td></tr><tr><td>domContentLoadedEventEnd</td><td>返回当前网页所有需要执行的脚本执行完成时的Unix毫秒时间戳</td></tr><tr><td>domComplete</td><td>返回当前网页DOM结构生成时（即Document.readyState属性变为“complete”，以及相应的readystatechange事件发生时）的Unix毫秒时间戳</td></tr><tr><td>loadEventStart</td><td>返回当前网页load事件的回调函数开始时的Unix毫秒时间戳。如果该事件还没有发生，返回0</td></tr><tr><td>loadEventEnd</td><td>返回当前网页load事件的回调函数运行结束时的Unix毫秒时间戳。如果该事件还没有发生，返回0</td></tr></tbody></table><h2 id="核心指标计算"><a href="#核心指标计算" class="headerlink" title="核心指标计算"></a>核心指标计算</h2><h3 id="白屏时间"><a href="#白屏时间" class="headerlink" title="白屏时间"></a>白屏时间</h3><p>白屏时间代表的是，用户从点击链接打开页面开始，到页面上有内容展示的时间长度。这个过程包括dns查询、建立tcp连接、发送首个http请求（如果使用https还要介入TLS的验证时间）、返回html文档、html文档head解析完毕。</p><p>domLoading 代表浏览器开始解析html文档的时间节点。我们知道IE浏览器下的document有readyState属性，domLoading的值就等于readyState改变为loading的时间节点；</p><p>domInteractive 为在主文档的解析器结束工作，即 Document.readyState 改变为 ‘interactive’ 并且相当于 readystatechange 事件被触发之时的 Unix毫秒时间戳。</p><pre><code class="javascript">// 在不支持getEntriesByType()的情况下，使用timingvar whiteScreenTime = performance.timing.domInteractive - performance.timing.navigationStart// 支持getEntriesByType()，没有domLoading时机，所以实用domInteractiveif (performance.getEntriesByType &amp;&amp; performance.getEntriesByType(&#39;paint&#39;).length) &#123;  const paintList = performance.getEntriesByType(&#39;paint&#39;)  paintList.map((item) =&gt; &#123;    if (item.name === &#39;first-contentful-paint&#39;) &#123;      whiteScreenTime = item.startTime    &#125;  &#125;)&#125;</code></pre><h3 id="首屏时间"><a href="#首屏时间" class="headerlink" title="首屏时间"></a>首屏时间</h3><p>首屏时间的统计目前没有标准的方法，而且每个不同类型的页面都有不同的评判标准，所以较为复杂，而且会涉及图片、iframe 等多种元素的异步加载和渲染。但是为了这个方案更加通用、方便，所以我们以下面两个原则做为基本原则导向。</p><ul><li><strong>首屏时间计算模块不耦合业务</strong>，作为一个单独运行的 js 脚本文件进行单独引用，尽量不对外暴露 API 接口给开发者使用，所有采集任务都有模块内部实现完成。</li><li><strong>性能和准确性的权衡</strong>，业界通过指定时间间隔，进行 canvas 截屏（即 canvas2Html），计算像素点的前后像素点的的差别。准确性是很高，但是在性能方面就差强人意了。</li></ul><p>并结合我们现有业务，发现其实最大的影响因素还是在加载图片上面，所以计算首屏的规则大致可以分成两种情况：</p><ul><li><strong>首屏有图片</strong>，计算在首屏的所有图片，全部加载完成的时间<pre><code class="javascript">let time = 首屏图片加载完成时间 - performance.timing.navigationStart;// 浏览器地址栏输入url回车之后，或用户点击打开href的时间</code></pre></li></ul><ul><li><strong>首屏没有图片，</strong>使用dom加载完成时间<pre><code class="javascript">let time = 页面处于稳定状态前最后一次 dom 变化的时刻 - window.performance.timing.navigationStart</code></pre></li></ul><h4 id="图片加载时间"><a href="#图片加载时间" class="headerlink" title="图片加载时间"></a>图片加载时间</h4><ol><li>从进入页面开始，每隔500ms，对 html 上的 dom 元素进行遍历8次，保证再接口返回后，找到在首屏展示的图片，并绑定 onload 和 onerror 事件<ul><li>（1. 绑定时做判断，不要重复绑定，2.绑定时判断图片是否相同，相同不需要重复绑定）</li></ul></li><li>统计图片 onload 事件的图片完成加载时间戳，计算对比出最后加载完成的时间</li><li>计算出首屏加载时间</li></ol><p>具体的实现流程如下：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/174505/1606911141516-87bdd941-4b09-4478-9376-3f4e6144ba21.png#align=left&display=inline&height=908&margin=%5Bobject%20Object%5D&name=%E9%A6%96%E5%B1%8F%E6%97%B6%E9%97%B4%E8%AE%A1%E7%AE%97.png&originHeight=911&originWidth=721&size=88579&status=done&style=none&width=719" alt="首屏时间计算.png"></p><h4 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h4><p><strong>开发过程中的问题</strong></p><ol><li>performance API 浏览器支持程度不同<strong>（已解决）</strong></li><li>需要获取background-image的图片加载时间<strong>（已解决）</strong><ul><li>background-image 如何监听加载时间，是否准确</li><li>background-image 获取定位位置，判断是否为首屏</li></ul></li><li>在首屏但是不在可视范围内的图片，如swiper<strong>（已解决）</strong></li><li>dom 加载时机不同，onload 之后接口返回数据 dom 变化<strong>（已解决）</strong><ul><li>多次循环遍历所有图片资源，限制最终节点</li></ul></li><li>为什么 allLoadedTime 时间会比 fistPageLoadTime 时间还要长<strong>（已解决）</strong><ul><li>因为会在代码开始后的 2s 中内循环去查到 dom 节点，所有在接口还未请求回来之前，loaded 时间就已经触发了，所以 firstPageLoadTime 会比 loaded 时间还长</li></ul></li><li>监听事件重复添加<strong>（已解决）</strong></li></ol><p><strong>优化点</strong></p><ul><li><p>与客户端结合，可以监控上传一些客户端信息</p><pre><code class="javascript">// 需要客户端提供的字段nativeLoadData: &#123;  webviewInit // webview 初始化的时机  isCache     // 是否存在缓存  orginalUrl  // 原始链接  completeUrl // 最终链接&#125;// 触发时机，是否可以是有值就塞进去</code></pre></li><li><p>上传时机有问题，选择更好的时机上报</p></li><li><p>上报方式有问题，结合 sendbeacon 方式，需要向下兼容</p></li><li><p>查找 dom 算法可以优化</p></li><li><p>需要考虑内嵌iframe的情况</p></li></ul><h3 id="完全加载时间"><a href="#完全加载时间" class="headerlink" title="完全加载时间"></a>完全加载时间</h3><pre><code class="javascript">var onLoadTime = performance.timing.loadEventEnd - performance.timing.navigationStart  // onload时间// 完全加载时间var fullScreenTime = 页面有图片 ? 页面内所有图片加载完成的时间 - performance.timing.navigationStart : onLoadTime</code></pre><p>页面内所有图片加载完成的时间有两种方式可以获得：</p><ul><li>通过上面循环获取图片，监听最后一张图片加载完的时间</li><li>通过<code>performance.getEntriesByType(&#39;resource&#39;)</code>方式获取资源加载时间，筛选出最后一张图片加载完成的时间</li></ul><pre><code class="javascript">if (performance.getEntriesByType &amp;&amp; performance.getEntriesByType(&#39;navigation&#39;).length &amp;&amp; performance.getEntriesByType(&#39;resource&#39;).length) &#123;  const timging2 = performance.getEntriesByType(&#39;navigation&#39;)[0] // 返回的是相对时间  const resourceList = performance.getEntriesByType(&#39;resource&#39;)  let lastItem = &#123;&#125;  resourceList.map((item) =&gt; &#123;    // 判断onload 之前发起的图片请求，排除用户交互之后的图片加载    if (item.initiatorType === &#39;img&#39; &amp;&amp; item.startTime &lt; timging2.loadEventEnd) &#123; // 可以增加特定的筛选逻辑      if (item.responseEnd &gt; lastItem.responseEnd) &#123;        lastItem = JSON.parse(JSON.stringify(item))      &#125;    &#125;  &#125;)  obj.fullScreenTime = lastItem.responseEnd &gt;= timging2.loadEventEnd ? lastItem.responseEnd : timging2.loadEventEnd&#125;</code></pre><h3 id="其他时间"><a href="#其他时间" class="headerlink" title="其他时间"></a>其他时间</h3><pre><code class="javascript">var redirectTime = performance.timing.redirectEnd - performance.timing.redirectStart// 重定向时间var dnsTime = performance.timing.domainLookupEnd - performance.timing.domainLookupStart// DNS解析时间var tcpTime = performance.timing.connectEnd - performance.timing.connectStart// TCP完成握手时间var ajaxTime = performance.timing.responseEnd - performance.timing.requestStart// HTTP请求响应完成时间var domTime = performance.timing.domComplete - performance.timing.domLoading// DOM加载完成时间var whiteScreenTime = performance.timing.domLoading - performance.timing.navigationStart// DOM开始加载前所花费时间var ttfbTime = performance.timing.responseStart - performance.timing.navigationStart// TTFB 读取页面第一个字节的时间</code></pre><p>关于其他一些时间的计算，可以查看<a target="_blank" rel="noopener" href="https://www.dynatrace.com/support/help/how-to-use-dynatrace/real-user-monitoring/basic-concepts/user-actions/">这篇文章</a></p><h2 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h2><h3 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h3><p>单页面应用要怎么办？怎么去监听每个页面变化后的加载时间呢？</p><p><code>window.performance</code> API 是有缺点的，在 SPA 切换路由时，<code>window.performance.timing</code> 的数据不会更新。所以我们需要另想办法来统计切换路由到加载完成的时间。拿 Vue 举例，一个可行的办法就是切换路由时，在路由的全局前置守卫 <code>beforeEach</code> 里获取开始时间，在组件的 <code>mounted</code> 钩子里执行 <code>vm.$nextTick</code> 函数来获取组件的渲染完毕时间。</p><pre><code>router.beforeEach((to, from, next) =&gt; &#123; store.commit(&#39;setPageLoadedStartTime&#39;, new Date())&#125;)</code></pre><pre><code>mounted() &#123; this.$nextTick(() =&gt; &#123;  this.$store.commit(&#39;setPageLoadedTime&#39;, new Date() - this.$store.state.pageLoadedStartTime) &#125;)&#125;</code></pre><p>除了性能和错误监控，其实我们还可以收集更多的信息。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/Dxa8aM44oz*Lukk5Ufhy">蚂蚁金服如何把前端性能监控做到极致?</a></li><li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1061844">关于首屏时间采集自动化的解决方案</a></li><li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/44933789?utm_source=com.yinxiang&utm_medium=social&utm_oi=58504207400960">阿里云ARMS前端监控 - 首屏统计的前世今生</a></li><li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tugenhua0707/p/10982332.html">Performance — 前端性能监控</a></li><li><a target="_blank" rel="noopener" href="http://fex.baidu.com/blog/2014/05/build-performance-monitor-in-7-days/">7 天打造前端性能监控系统</a></li><li><a target="_blank" rel="noopener" href="https://github.com/shaozj/blog/issues/19">前端性能量化标准</a></li><li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/caizhenbo/p/7993533.html">如何计算首屏加载时间？</a></li><li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904152317820935">前端性能优化指南[6]–Web 性能标准</a></li><li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904153869713416">前端性能优化指南[7]–Web 性能指标</a></li><li><a target="_blank" rel="noopener" href="https://github.com/hoperyy/auto-compute-first-screen-time">https://github.com/hoperyy/auto-compute-first-screen-time</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过ESLint和Prettier统一团队代码规范.</title>
      <link href="/2020-06/%E9%80%9A%E8%BF%87eslint%E5%92%8Cprettier%E7%BB%9F%E4%B8%80%E5%9B%A2%E9%98%9F%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
      <url>/2020-06/%E9%80%9A%E8%BF%87eslint%E5%92%8Cprettier%E7%BB%9F%E4%B8%80%E5%9B%A2%E9%98%9F%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<p>随着业务的需求的增加，前端项目也越来越多，项目之间的代码风格也不尽相同。如果一个项目涉及多个同学维护的话，那这个项目的代码风格就会比较糟糕了。而且有的同学本地可能用了格式化插件，所以保存之后会造成整个文件的代码被格式化，其实可能只修改了一行代码。这样在做合并代码 review 时，很容易就会被忽略，也失去了 review 的意义。</p><span id="more"></span><p>另外每个项目的创建时间不同，所以也造成了各个项目之间的 eslint 规范配置也不同。有的项目验证了结尾带“;”，有的项目验证了使用单引号，所以同一个人在开发不同项目时也很难使用一些快捷的格式化插件。还有因为有的项目 eslint 的缺失，也隐藏了很多低级错误在代码中。这无形之中给项目埋下了不定时炸弹。</p><p>其实之前也做过一次代码规范统一的事情，其实只是做了一些配置的改变，没有做到一些限制的措施，这样其实提高了开发同学的开发成本，也很难通过开发同学自觉遵守规范，而做到比较好的效果。</p><p>接下来我会从以下几个方面来讲讲：</p><ol><li>eslint 包之间的依赖介绍</li><li>怎么解决，通过 prettier 美化代码格式，通过 eslint 规范代码风格，避免低级 bug</li><li>eslint 版本规范选择，各类项目(vue/vue cli3、rn、react)需要的 eslint 依赖和插件，eslintrc 的配置</li><li>如何降低各个项目配置 eslint 成本？</li><li>vscode 配置，支持保存时自动格式化</li><li>避免未格式化代码被提交到代码库，提交前自动执行 fix 和校验</li></ol><h2 id="ESLint-生态依赖包"><a href="#ESLint-生态依赖包" class="headerlink" title="ESLint 生态依赖包"></a>ESLint 生态依赖包</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul><li><p>eslint: lint 代码的主要工具，所以的一切都是基于此包</p><ul><li>eslint 可以安装在当前项目中，局部安装：<code>npm install eslint --save-dev</code>，使用<code>./node_modules/.bin/eslint *.js</code>命令本地运行，插件安装在项目目录（推荐）</li><li>eslint 可以安装在根目录下，全局安装：<code>npm install eslint --global</code>，使用<code>eslint *.js</code> 命令全局运行，所有的插件都是要安装在根目录</li></ul></li></ul><h3 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h3><ul><li>Esprima</li><li>Babel-ESLint - 一个对 Babel 解析器的包装，使其能够与 ESLint 兼容。</li><li>@typescript-eslint/parser - 将 TypeScript 转换成与 estree 兼容的形式，以便在 ESLint 中使用。</li></ul><h3 id="扩展的配置"><a href="#扩展的配置" class="headerlink" title="扩展的配置"></a>扩展的配置</h3><ul><li><p>eslint-config-airbnb: 该包提供了所有的 Airbnb 的 ESLint 配置，作为一种扩展的共享配置，你是可以修改覆盖掉某些不需要的配置的，该工具包包含了 react 的相关 Eslint 规则(eslint-plugin-react 与 eslint-plugin-jsx-a11y)，所以安装此依赖包的时候还需要安装刚才提及的两个插件</p></li><li><p>eslint-config-airbnb-base: 与上一个包的区别是，此依赖包不包含 react 的规则，一般用于服务端检查。</p></li><li><p>eslint-config-prettier: 将会禁用掉所有那些非必须或者和 prettier 冲突的规则。这让您可以使用您最喜欢的 shareable 配置，而不让它的风格选择在使用 Prettier 时碍事。请注意该配置只是将规则 off 掉,所以它只有在和别的配置一起使用的时候才有意义。</p></li><li><p>eslint-config-standard: 是一个标准配置，旨在让所有开发者不需要维护 .eslintrc, .jshintrc, or .jscsrc</p></li></ul><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><ul><li><p>eslint-plugin-babel: 和 babel-eslint 一起用的一款插件.babel-eslint 在将 eslint 应用于 Babel 方面做得很好，但是它不能更改内置规则来支持实验性特性。eslint-plugin-babel 重新实现了有问题的规则，因此就不会误报一些错误信息</p></li><li><p>eslint-plugin-import: 该插件想要支持对 ES2015+ (ES6+) import/export 语法的校验, 并防止一些文件路径拼错或者是导入名称错误的情况</p></li><li><p>eslint-plugin-promise：promise 规范写法检查插件，附带了一些校验规则。</p></li><li><p>eslint-plugin-jsx-a11y: 该依赖包专注于检查 JSX 元素的可访问性。</p></li><li><p>eslint-import-resolver-webpack: 可以借助 webpack 的配置来辅助 eslint 解析，最有用的就是 alias，从而避免 unresolved 的错误</p></li><li><p>eslint-import-resolver-typescript：和 eslint-import-resolver-webpack 类似，主要是为了解决 alias 的问题</p></li><li><p>eslint-plugin-react: React 专用的校验规则插件.</p></li><li><p>eslint-plugin-jest: Jest 专用的 Eslint 规则校验插件.</p></li><li><p>eslint-plugin-prettier: 该插件辅助 Eslint 可以平滑地与 Prettier 一起协作，并将 Prettier 的解析作为 Eslint 的一部分，在最后的输出可以给出修改意见。这样当 Prettier 格式化代码的时候，依然能够遵循我们的 Eslint 规则。如果你禁用掉了所有和代码格式化相关的 Eslint 规则的话，该插件可以更好得工作。所以你可以使用 eslint-config-prettier 禁用掉所有的格式化相关的规则(如果其他有效的 Eslint 规则与 prettier 在代码如何格式化的问题上不一致的时候，报错是在所难免的了)</p></li><li><p>@typescript-eslint/eslint-plugin：Typescript 辅助 Eslint 的插件。</p></li></ul><h3 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h3><ul><li>prettier：是一个代码格式化工具，相比于 ESLint 中的代码格式规则，它提供了更少的选项，但是却更加专业。</li></ul><p>几个工具之间的关系是：prettier 是最基础的，然后你需要用 eslint-config-prettier 去禁用掉所有和 prettier 冲突的规则，这样才可以使用 eslint-plugin-prettier 去以符合 eslint 规则的方式格式化代码并提示对应的修改建议。</p><h3 id="辅助优化流程"><a href="#辅助优化流程" class="headerlink" title="辅助优化流程"></a>辅助优化流程</h3><ul><li><p>Husky 能够帮你阻挡住不好的代码提交和推送。是一个 git 钩子工具，我们这里主要用 pre-commit 钩子。通俗点讲就是 husky 可以在你 commit 之前帮你做一些事情。</p></li><li><p>lint-staged：在你提交的文件中，执行自定义的指令。自定义指令可以是你 eslint 相关，也可以是其他命令</p></li></ul><pre><code class="bash">npm i -D husky lint-staged</code></pre><p>注： 安装的时候要注意下版本，本人就是没有注意版本，在安装 0.14.3 的 husky，造成一直不能成功调用，配置文件信息。后来才发现，husky 之后的版本才可以用，之前的版本是使用 script 配置中的 percommit 来调用的。</p><ul><li>配置 husky、lint-staged，在<code>package.json</code>文件中添加如下配置：</li></ul><pre><code class="json">&quot;husky&quot;: &#123;  &quot;hooks&quot;: &#123;    &quot;pre-commit&quot;: &quot;lint-staged&quot;  &#125;&#125;,&quot;lint-staged&quot;: &#123;  &quot;**/*&quot;: [    &quot;eslint --fix&quot;,    &quot;git add&quot;  ]&#125;</code></pre><p>然后就可以修改一个文件，再去 commit 代码。这个时候在 commit 之前，命令行就会执行 lint-staged 指令，去 eslint –fix 刚刚修改的文件。</p><p>注：这里也要注意，只会修改你当前发生修改的文件，没有发生修改的文件是不会执行 eslint –fix 命令的。 再安装后，想首次全部 eslint –fix，那只能先手动执行<code>./node_modules/.bin/eslint --fix --ext .js ./src</code></p><p>问题记录：按照上述步骤安装完之后，发现还是执行不成功。不会根据配置文件完成预定目标。</p><p>后来找了很久才发现，是因为他的原理造成的。</p><p>通过查看源码可以看到，在安装 husky 的时候，husky 会根据 package.json 里的配置，在.git/hooks 目录生成所有的 hook 脚本（如果你已经自定义了一个 hook 脚本，husky 不会覆盖它）问题就出在这里，因为我之前安装过老版本的 husky，所以在 .git/hooks/ 文件夹内保留了之前的 hooks 配置。</p><p>这里有两个办法解决：</p><ol><li>通过 <code>npm uninstall -D husky</code> 卸载后，重新安装 <code>npm i -D husky</code></li><li>手动删除 .git/hooks/* 目录下的所有文件，在重新安装 <code>npm i -D husky</code></li></ol><h2 id="ESLint-配置说明"><a href="#ESLint-配置说明" class="headerlink" title="ESLint 配置说明"></a>ESLint 配置说明</h2><p>使用 JavaScript、JSON 或者 YAML 文件为整个目录（处理你的主目录）和它的子目录指定配置信息。可以配置一个独立的 .eslintrc.js 文件，或者直接在 package.json 文件里的 eslintConfig 字段指定配置，ESLint 会查找和自动读取它们，再者，你可以在命令行运行时指定一个任意的配置文件。</p><h3 id="env"><a href="#env" class="headerlink" title="env"></a>env</h3><p>指定脚本的运行环境。每种环境都有一组特定的预定义全局变量。</p><ul><li>browser - 浏览器环境中的全局变量。</li><li>node - Node.js 全局变量和 Node.js 作用域。</li><li>commonjs - CommonJS 全局变量和 CommonJS 作用域 (用于 Browserify/WebPack 打包的只在浏览器中运行的代码)。</li><li>shared-node-browser - Node.js 和 Browser 通用全局变量。</li><li>es6 - 启用除了 modules 以外的所有 ECMAScript 6 特性（该选项会自动设置 ecmaVersion 解析器选项为 6）。</li></ul><p>更多配置：<a target="_blank" rel="noopener" href="https://cn.eslint.org/docs/user-guide/configuring#specifying-environments">specifying-environments</a></p><h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><p>用于指定需要配置文件的路径、可配置模块的名称、 eslint:recommended 或 eslint:all</p><p>ESLint 递归地扩展配置，因此基本配置也可以具有 extends 属性。extends 属性值可以省略包名的前缀 <code>eslint-config-</code>。</p><p>可配置模块 是一个 npm 包，它输出一个配置对象。要确保这个包安装在 ESLint 能请求到的目录下。</p><h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><p>插件 是一个 npm 包，通常输出规则。一些插件也可以输出一个或多个命名的 配置。要确保这个包安装在 ESLint 能请求到的目录下。</p><p>plugins 属性值 可以省略包名的前缀 <code>eslint-plugin-</code>。</p><h3 id="parser"><a href="#parser" class="headerlink" title="parser"></a>parser</h3><p>默认 ESlint 使用 Espree 作为解析器，但是一旦我们使用 babel 的话，我们需要用 babel-eslint。</p><h3 id="parserOptions"><a href="#parserOptions" class="headerlink" title="parserOptions"></a>parserOptions</h3><p>ESLint 允许你指定你想要支持的 JavaScript 语言选项。默认情况下，ESLint 支持 ECMAScript 5 语法。</p><p>可用的选项有：</p><ul><li>ecmaVersion - 默认设置为 3，5（默认）， 你可以使用 6、7、8、9 或 10 来指定你想要使用的 ECMAScript 版本。你也可以用使用年份命名的版本号指定为 2015（同 6），2016（同 7），或 2017（同 8）或 2018（同 9）或 2019 (same as 10)</li><li>sourceType - 设置为 “script” (默认) 或 “module”（如果你的代码是 ECMAScript 模块)。</li><li>ecmaFeatures - 这是个对象，表示你想使用的额外的语言特性:<ul><li>globalReturn - 允许在全局作用域下使用 return 语句</li><li>impliedStrict - 启用全局 strict mode (如果 ecmaVersion 是 5 或更高)</li><li>jsx - 启用 JSX</li><li>experimentalObjectRestSpread - 启用实验性的 object rest/spread properties 支持。(重要：这是一个实验性的功能,在未来可能会有明显改变。 建议你写的规则 不要 依赖该功能，除非当它发生改变时你愿意承担维护成本。)</li></ul></li></ul><h3 id="rules"><a href="#rules" class="headerlink" title="rules"></a>rules</h3><p>自定义规则，可以覆盖掉 extends 的配置。</p><ul><li>“off” 或 0 - 关闭规则</li><li>“warn” 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出)</li><li>“error” 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)</li></ul><h3 id="globals"><a href="#globals" class="headerlink" title="globals"></a>globals</h3><p>当访问当前源文件内未定义的变量时，no-undef 规则将发出警告。如果你想在一个源文件里使用全局变量，推荐你在 ESLint 中定义这些全局变量，这样 ESLint 就不会发出警告了。你可以使用注释或在配置文件中定义全局变量。</p><h2 id="不同项目配置"><a href="#不同项目配置" class="headerlink" title="不同项目配置"></a>不同项目配置</h2><h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><p>因为我们使用 prettier 作为默认格式化工具，所以每种项目都需要安装 prettier 相关依赖：</p><pre><code>npm i -D -E prettier eslint-plugin-prettier  eslint-config-prettier</code></pre><ul><li>推荐配置项，新建 <code>.prettierrc.js</code> 文件</li></ul><pre><code class="js">module.exports = &#123;  // 一行最多 200 字符  printWidth: 200,  // 使用 2 个空格缩进  tabWidth: 2,  // 不使用缩进符，而使用空格  useTabs: false,  // 行尾不需要分号  semi: false,  // 使用单引号  singleQuote: true,  // 对象的 key 仅在必要时用引号  quoteProps: &quot;as-needed&quot;,  // jsx 不使用单引号，而使用双引号  jsxSingleQuote: false,  // 末尾不需要逗号  trailingComma: &quot;none&quot;,  // 大括号内的首尾需要空格  bracketSpacing: true,  // jsx 标签的反尖括号不需要换行  jsxBracketSameLine: true,  // 箭头函数，只有一个参数的时候，也需要括号  arrowParens: &quot;always&quot;,  // 每个文件格式化的范围是文件的全部内容  rangeStart: 0,  rangeEnd: Infinity,  // 不需要写文件开头的 @prettier  requirePragma: false,  // 不需要自动在文件开头插入 @prettier  insertPragma: false,  // 使用默认的折行标准  proseWrap: &quot;preserve&quot;,  // 根据显示样式决定 html 要不要折行  htmlWhitespaceSensitivity: &quot;css&quot;,  // 换行符使用 lf  endOfLine: &quot;lf&quot;,&#125;;</code></pre><p>执行 <code>npx prettier --write src/index.js</code> 测试是否可用</p><p>因为这里我们选择统一为 standard 规范，所以需要安装 standard 相关依赖</p><ul><li>安装 eslint standard 相关</li></ul><pre><code>npm i -D eslint babel-eslint eslint-config-standard eslint-plugin-standard eslint-plugin-import eslint-plugin-node eslint-plugin-promise</code></pre><h3 id="react-native-项目"><a href="#react-native-项目" class="headerlink" title="react-native 项目"></a>react-native 项目</h3><ul><li>安装 eslint 相关</li></ul><pre><code>npm i -D eslint-plugin-jsx-a11y eslint-plugin-react eslint-plugin-react-native</code></pre><ul><li>eslint 配置</li></ul><pre><code class="json">module.exports = &#123;  &quot;env&quot;: &#123;    &quot;browser&quot;: true,    &quot;es6&quot;: true,    &quot;amd&quot;: true  &#125;,  &quot;extends&quot;: [&quot;eslint:recommended&quot;, &quot;standard&quot;, &quot;plugin:prettier/recommended&quot;, &quot;plugin:react-native/all&quot;],  &quot;parser&quot;: &quot;babel-eslint&quot;,  &quot;parserOptions&quot;: &#123;    &quot;ecmaFeatures&quot;: &#123;      &quot;experimentalObjectRestSpread&quot;: true,      &quot;jsx&quot;: true    &#125;,    &quot;sourceType&quot;: &quot;module&quot;  &#125;,  &quot;plugins&quot;: [    &quot;react&quot;,    &quot;react-native&quot;  ],  &quot;rules&quot;: &#123;    &#39;no-prototype-builtins&#39;: 0,    &#39;prefer-promise-reject-errors&#39;: 0,    &#39;no-async-promise-executor&#39;: 0,    &#39;no-misleading-character-class&#39;: 0,    &#39;no-useless-catch&#39;: 0,    &quot;no-console&quot;: 0,    &quot;react/jsx-uses-react&quot;: 0,    &quot;react/jsx-uses-vars&quot;: 0,    &quot;react-native/no-inline-styles&quot;: 0,    &quot;react-native/sort-styles&quot;: 0  &#125;&#125;;</code></pre><h3 id="Vue-项目"><a href="#Vue-项目" class="headerlink" title="Vue 项目"></a>Vue 项目</h3><ul><li>安装 eslint 相关</li></ul><pre><code>npm i -D  eslint-plugin-vue</code></pre><ul><li>eslint 配置</li></ul><pre><code class="json">&quot;eslintConfig&quot;: &#123;  &quot;root&quot;: true,  &quot;env&quot;: &#123;    &quot;node&quot;: true,    &quot;browser&quot;: true,    &quot;es6&quot;: true,  &#125;,  &quot;extends&quot;: [    // 顺序有关系，层层覆盖    &quot;eslint:recommended&quot;,    &quot;plugin:vue/strongly-recommended&quot;,    &quot;standard&quot;,    &quot;plugin:prettier/recommended&quot;  ],  &quot;rules&quot;: &#123;    &quot;vue/max-attributes-per-line&quot;: 0,    &quot;vue/singleline-html-element-content-newline&quot;: 0,    &quot;vue/html-self-closing&quot;: 0,    &quot;no-console&quot;: 0,    &quot;no-undef&quot;: 0  &#125;,  &quot;parserOptions&quot;: &#123;    &quot;parser&quot;: &quot;babel-eslint&quot;  &#125;&#125;</code></pre><h2 id="配置-VSCode"><a href="#配置-VSCode" class="headerlink" title="配置 VSCode"></a>配置 VSCode</h2><ol><li><p>安装插件 Prettier - Code formatter</p></li><li><p>修改配置项</p></li></ol><pre><code class="json">&quot;[javascript]&quot;: &#123; &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;&#125;,&quot;[vue]&quot;: &#123; &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;&#125;,&quot;editor.codeActionsOnSave&quot;: null,&quot;editor.formatOnSave&quot;: true</code></pre><ol start="3"><li>这样就可以在保存代码时，进行自动格式化了</li></ol><h2 id="排除特定文件"><a href="#排除特定文件" class="headerlink" title="排除特定文件"></a>排除特定文件</h2><p>有时候我们还是会存在一些文件是不需要格式化和 eslint 验证的，比如外部 js 文件，图片文件，其他静态资源文件。</p><p>这样大家可以在文件目录下添加 ignore 文件：</p><p>.prettierignore</p><pre><code>src/assets/*</code></pre><p>.eslintignore</p><pre><code>src/assets/*</code></pre><h2 id="Vue-项目-统一配置方式"><a href="#Vue-项目-统一配置方式" class="headerlink" title="Vue 项目 统一配置方式"></a>Vue 项目 统一配置方式</h2><pre><code class="bash">npm i -D -E prettier eslint-plugin-prettier  eslint-config-prettiernpm i -D eslint babel-eslint eslint-config-standard eslint-plugin-standard eslint-plugin-import eslint-plugin-node eslint-plugin-promise eslint-plugin-vue husky lint-staged</code></pre><pre><code class="json"> &quot;eslintConfig&quot;: &#123;    &quot;root&quot;: true,    &quot;env&quot;: &#123;       &quot;node&quot;: true,       &quot;browser&quot;: true,       &quot;es6&quot;: true,    &#125;,    &quot;extends&quot;: [      &quot;eslint:recommended&quot;,      &quot;plugin:vue/strongly-recommended&quot;,      &quot;standard&quot;,      &quot;plugin:prettier/recommended&quot;    ],    &quot;rules&quot;: &#123;      &quot;vue/max-attributes-per-line&quot;: 0,      &quot;vue/singleline-html-element-content-newline&quot;: 0,      &quot;vue/html-self-closing&quot;: 0,      &quot;no-console&quot;: 0,      &quot;no-undef&quot;: 0    &#125;,    &quot;parserOptions&quot;: &#123;      &quot;parser&quot;: &quot;babel-eslint&quot;    &#125;  &#125;,  &quot;prettier&quot;: &#123;    &quot;printWidth&quot;: 200,    &quot;tabWidth&quot;: 2,    &quot;useTabs&quot;: false,    &quot;semi&quot;: false,    &quot;singleQuote&quot;: true,    &quot;quoteProps&quot;: &quot;as-needed&quot;,    &quot;jsxSingleQuote&quot;: false,    &quot;trailingComma&quot;: &quot;none&quot;,    &quot;bracketSpacing&quot;: true,    &quot;jsxBracketSameLine&quot;: true,    &quot;arrowParens&quot;: &quot;always&quot;,    &quot;requirePragma&quot;: false,    &quot;insertPragma&quot;: false,    &quot;proseWrap&quot;: &quot;preserve&quot;,    &quot;htmlWhitespaceSensitivity&quot;: &quot;css&quot;,    &quot;endOfLine&quot;: &quot;lf&quot;  &#125;,  &quot;husky&quot;: &#123;    &quot;hooks&quot;: &#123;      &quot;pre-commit&quot;: &quot;lint-staged&quot;    &#125;  &#125;,  &quot;lint-staged&quot;: &#123;    &quot;src/**/*&quot;: [      &quot;prettier --write&quot;,      &quot;eslint --fix&quot;,      &quot;git add&quot;    ]  &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端如何调试页面</title>
      <link href="/2020-05/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E9%A1%B5%E9%9D%A2/"/>
      <url>/2020-05/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E9%A1%B5%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<p>前端的环境太多，很多问题并不是在浏览器上就能查出来，所以就需要掌握各个环境的调试技巧。</p><span id="more"></span><h3 id="网页调试"><a href="#网页调试" class="headerlink" title="网页调试"></a>网页调试</h3><ul><li>window 环境下，点击 F12，即可开启调试模式</li><li>mac 环境下，Command+Shift+I 或者  Command+Shift+J，即可开启调试模式</li></ul><h3 id="Android-APP-调试"><a href="#Android-APP-调试" class="headerlink" title="Android APP 调试"></a>Android APP 调试</h3><blockquote><p>要求：Android&gt;4.0，Chrome&gt;32</p></blockquote><ol><li>打开手机内的开发者模式，开启 USB 调试功能</li><li>把手机连接上你的电脑，允许弹窗内容，信任相关设备</li><li>打开 chrome，输入 chrome://inspect/#devices 就会出现如下页面</li></ol><p><img src="https://cdn.leoao.com/blog/1590560265090-f69bc3fa-9b8b-4bcc-af31-1f349767734c.png?imageslim"></p><ol><li>点击相应的<code>inspect</code>，即可以开始调试了。</li></ol><p><img src="https://cdn.leoao.com/blog/1590560264898-79d6ba01-f3ff-4ea2-b48a-dbef1d3e8214.png?imageslim"></p><p>注意：使用 Chrome Inspect 查看页面时，Chrome 需要从 <a target="_blank" rel="noopener" href="https://chrome-devtools-frontend.appspot.com/">https://chrome-devtools-frontend.appspot.com</a> 加载资源，如果你得到的调试界面是一片空白，那你可能需要科学上网。</p><h3 id="IOS-APP-调试"><a href="#IOS-APP-调试" class="headerlink" title="IOS APP 调试"></a>IOS APP 调试</h3><p>如果使用真机，由于 iOS 有签名校验机制，正式包不允许 safari debug，所以安装在真机上的包必须是测试签名打的包。</p><ol><li>开启 iOS 设备的调试功能，打开“设置”程序，进入“Safari”-&gt;“高级”页面开启“Web 检查器”：</li></ol><p><img src="https://cdn.leoao.com/blog/1590560264861-dfb06023-8d0d-428d-80ed-b56f9b024324.png?imageslim"></p><ol><li>开启 Safari 的调试功能</li><li>打开“开发者”菜单，运行 Safari,点击“Safari”菜单下面的“偏好设置（Preferences…）”，切换到“高级选项（Advanced）”</li><li>勾选“在菜单栏显示”开发”菜单（Show Develop menu in menu bar）”，关闭偏好设置。</li></ol><p><img src="https://cdn.leoao.com/blog/1590561577192-0a8a45fe-3b94-4542-959f-3a41e81b9323.png?imageslim" alt="image.png"></p><ol start="3"><li>设备连接 Mac，打开 safari，点击开发（Develop）弹出菜单会出现设备名称项，进入后显示设备上所有打开的“HTML 页面”列表。</li></ol><p><img src="https://cdn.leoao.com/blog/1590560264892-31df6587-85d6-4e28-b68a-0c85dbc0f817.png?imageslim"></p><ol start="3"><li>点击对应的页面就可以进行调试了。</li></ol><p><img src="https://cdn.leoao.com/blog/1590560264838-542a5399-6a27-42e5-8905-d4836ec6448a.png?imageslim"></p><h3 id="微信环境"><a href="#微信环境" class="headerlink" title="微信环境"></a>微信环境</h3><p>在实际开发中，在微信环境下会碰到一些棘手的 bug，想看看到底哪里出了问题。这个时候这个方法应该可以帮到你。</p><ol><li>在微信环境下打开， <a target="_blank" rel="noopener" href="http://debugx5.qq.com/">http://debugx5.qq.com/</a> ，也可以直接扫下面的二维码</li></ol><p><img src="https://cdn.leoao.com/blog/1590560264826-71484436-5629-4029-9d9e-5f34e04078d9.png?imageslim"></p><ol><li>然后在“信息栏”内，勾选如下图选项</li></ol><p><img src="https://cdn.leoao.com/blog/1590560265031-c743bdf0-b96b-4889-b734-c6850ae2cb9f.jpg?imageslim"></p><ol><li>下载，安装 <a target="_blank" rel="noopener" href="https://x5.tencent.com/tbs/guide/debug/download.html">TBS Studio</a></li></ol><p><img src="https://cdn.leoao.com/blog/1590560264946-e636049c-ef47-4ff5-908d-bff757938825.png?imageslim"></p><ol><li>开启手机的开发者模式和 USB 调试，微信内打开需要调试的页面，手机连接电脑</li></ol><p><img src="https://cdn.leoao.com/blog/1590560264867-ed2d5407-49a3-4f3a-b6a4-0bd86de85924.png?imageslim"></p><ol><li>最后先将手机后台其他应用进程都杀掉，只保留微信，然后点击启动调试，看到如下弹窗，点击确定</li></ol><p><img src="https://cdn.leoao.com/blog/1590560264932-b2517952-aade-4b66-923b-bb9322822bac.png?imageslim"></p><ol start="6"><li>接下来，就可以看到熟悉的调试页面了</li></ol><p><img src="https://cdn.leoao.com/blog/1590560265067-54aba694-ef7e-42f2-9155-a731ae726ce4.png?imageslim"></p><p><img src="https://cdn.leoao.com/blog/1590560264902-9f705d96-89e9-4507-9fde-fe79d13194c6.png?imageslim"></p><h3 id="钉钉微应用"><a href="#钉钉微应用" class="headerlink" title="钉钉微应用"></a>钉钉微应用</h3><h4 id="本地开发"><a href="#本地开发" class="headerlink" title="本地开发"></a>本地开发</h4><ol><li>可以直接在本地浏览器上打开，修改浏览器 UA</li></ol><p><img src="https://cdn.leoao.com/blog/1590560264882-902d7337-665c-4527-90b5-35fb80c54bc9.png?imageslim"></p><ol start="2"><li>这样基本可以完成 90%的页面开发需求，剩下的就需要真机调试完成</li></ol><h4 id="真机调试"><a href="#真机调试" class="headerlink" title="真机调试"></a>真机调试</h4><ol><li>下载安装 Android 开发版，版本：4.5.15 <a target="_blank" rel="noopener" href="https://cdn.leoao.com/dingtalk-dev-4.5.15.apk">https://cdn.leoao.com/dingtalk-dev-4.5.15.apk</a></li><li>打开钉钉 Android 开发版，选择：我的 -&gt; 设置 -&gt; 通⽤ -&gt; 开发者选项 -&gt; 微应⽤调试（置于打开状态，如下图）</li></ol><p><img src="https://cdn.leoao.com/blog/1590560264902-9f705d96-89e9-4507-9fde-fe79d13194c6.png?imageslim"></p><ol><li>根据上面描述的 Android 调试方式操作，连接电脑，打开 chrome 调试工具页面，就可以正常调试了</li></ol><p><img src="https://cdn.leoao.com/blog/1590560264898-79d6ba01-f3ff-4ea2-b48a-dbef1d3e8214.png?imageslim"></p><h3 id="远程调试工具"><a href="#远程调试工具" class="headerlink" title="远程调试工具"></a>远程调试工具</h3><h4 id="spy-debugger"><a href="#spy-debugger" class="headerlink" title="spy-debugger"></a><a target="_blank" rel="noopener" href="https://github.com/wuchangming/spy-debugger">spy-debugger</a></h4><blockquote><p>一站式页面调试、抓包工具。远程调试任何手机浏览器页面，任何手机移动端 webview（如：微信，HybridApp 等）。支持 HTTP/HTTPS，无需 USB 连接设备。</p></blockquote><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="Weinre-调试工具"><a href="#Weinre-调试工具" class="headerlink" title="Weinre 调试工具"></a><a target="_blank" rel="noopener" href="http://people.apache.org/~pmuellr/weinre/docs/latest/Running.html">Weinre 调试工具</a></h4><blockquote><p>Weinre 是 Apache 基础工程之一，是 WEb INspector REmote 的缩写。在技术上 weinre 其实是一个以 node.js 为基础的 Http Server，利用了 Web 即时通讯的技巧，将某个已经挂上 Target JavaScript 的 Browser ，透过背景将 DOM 信息传递到 Debugging Tools 中。</p></blockquote><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h4 id="Eruda"><a href="#Eruda" class="headerlink" title="Eruda"></a><a target="_blank" rel="noopener" href="https://github.com/liriliri/eruda/blob/master/doc/README_CN.md">Eruda</a></h4><blockquote><p>Eruda 是一个专为前端<strong>移动端</strong>、<strong>移动端</strong>设计的调试面板，类似<code>Chrome DevTools</code> 的迷你版（没有 chrome 强大 这个是可以肯定的），其主要功能包括：捕获 <code>console</code> 日志、检查元素状态、显示性能指标、捕获 XHR 请求、显示<code>本地存储</code>和 <code>Cookie</code>信息、浏览器特性检测等等。</p></blockquote><h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><h4 id="Mobile-Debug"><a href="#Mobile-Debug" class="headerlink" title="Mobile Debug"></a><a target="_blank" rel="noopener" href="https://www.mobiledebug.com/">Mobile Debug</a></h4><blockquote><p>代理抓包/移动端 H5 调试/debugger/请求劫持/HTTPS 支持/Hosts 管理/WebSocket 数据捕获/跨平台免费使用<br>不过个人使用下来发现代理速度比较慢，打开页面需要等很久</p></blockquote><ol><li>下载 安装<a target="_blank" rel="noopener" href="https://www.mobiledebug.com/">MOBILE DEBUG</a></li><li>打开工具，根据软件操作步骤，手机连接上代理</li></ol><p><img src="https://cdn.leoao.com/blog/1590560264872-ec3c8d8d-6d28-4342-b587-d8ee6071feb8.png?imageslim"></p><ol><li>安装 https 证书，就可以开始调试了，不过功能会少一些，速度会慢一些</li></ol><p><img src="https://cdn.leoao.com/blog/Snipaste_2020-05-27_16-25-24.png?imageslim"></p><p><img src="https://cdn.leoao.com/blog/1590560264857-95135243-f222-40b4-9af3-569f1d08ba81.png?imageslim"></p><blockquote></blockquote><h3 id="React-native"><a href="#React-native" class="headerlink" title="React native"></a>React native</h3><p>相关调试方式，可以查看官网： <a target="_blank" rel="noopener" href="https://reactnative.cn/docs/debugging.html">https://reactnative.cn/docs/debugging.html</a></p><p><img src="https://cdn.leoao.com/blog/1590562837789-ec10160c-e0d7-4244-a24a-a4a65cc0a2ca.png?imageslim" alt="image.png"></p><p>参考链接：<a target="_blank" rel="noopener" href="https://aotu.io/notes/2017/02/24/Mobile-debug/index.html">https://aotu.io/notes/2017/02/24/Mobile-debug/index.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac软件推荐</title>
      <link href="/2019-07/mac%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
      <url>/2019-07/mac%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<p>用了多年 Mac，收集了一些 Mac 软件，用来跟大家分享一下</p><span id="more"></span><h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><p>以下神器就不多介绍了。</p><ol><li><p>SublimeText(Windows/Mac)可以长期免费试用</p></li><li><p>Atom (Windows/Mac)免费</p></li><li><p>VsCode (Windows/Mac)免费</p></li><li><p>Vim (Windows/Mac)免费</p></li></ol><h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><ol><li>iTerm(Mac)免费</li></ol><p>它是 OS X 下一款开源免费的的终端工具，直接替代自带的 Terminal。这个可是 Mac 下最好用的终端工具了，没有之一，堪称神器，尚方宝剑。官网在这里：<a target="_blank" rel="noopener" href="http://www.iterm2.com/">http://www.iterm2.com</a>，它的特性太多了，如智能查找、切分屏幕、标签变色、智能选中、命令自动补齐、查看命令历史、全屏展示所有的 tab 等等。作为一个前端开发工程师，其实你慢慢的发现终端工具你使用越来越频繁了，所以你需要一个趁手的工具来高效完成你的工作。</p><ol start="2"><li>oh my zsh(Mac)</li></ol><p>简直就是神器，详细内容：<a href="http://lion1ou.tech/2016/07/09/">原文地址</a></p><h2 id="数据库客户端"><a href="#数据库客户端" class="headerlink" title="数据库客户端"></a>数据库客户端</h2><ol><li><a target="_blank" rel="noopener" href="https://robomongo.org/">Robomongo</a>(Windows/Linux/Mac)可以免费使用</li></ol><p>Robomongo 是一个开源的，基于 Shell 的 MongoDB 图形化客户端管理软件，主要由 C++语言编写成，可运行在 Windows，Linux 和 Mac OS X 系统上。由于它内置了 JavaScript 引擎，所以在 MongoShell 中执行的任何操作都可以同样的在 Robomongo 的 Shell 中执行，最值得一提的是，它支持直接对数据以 json 方式浏览和修改，非常方便。官网在这里：<a target="_blank" rel="noopener" href="https://robomongo.org/">https://robomongo.org/</a></p><ol start="2"><li><a target="_blank" rel="noopener" href="https://www.navicat.com.cn/products/navicat-premium/">Navicat Premium</a>(Win/Mac)</li></ol><p>是一个可多重连线资料库的管理工具，它可以让你以单一程式同时连线到 MySQL、SQLite、Oracle 及 PostgreSQL 资料库，让管理不同类型的资料库更加的方便。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><ul><li><a target="_blank" rel="noopener" href="http://sketchcn.com/index.html">sketch</a>(Mac)</li></ul><p>Sketch 是一款适用于所有设计师的矢量绘图应用。矢量绘图也是目前进行网页，图标以及界面设计的最好方式。但除了矢量编辑的功能之外，我们同样添加了一些基本的位图工具，比如模糊和色彩校正。</p><h2 id="开发实用工具"><a href="#开发实用工具" class="headerlink" title="开发实用工具"></a>开发实用工具</h2><ul><li><a target="_blank" rel="noopener" href="http://brew.sh/">Homebrew</a>(Mac)开源免费－－OS X 不可或缺的套件管理器</li></ul><p>安装命令行：</p><pre><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></pre><p>可以理解为 Ubuntu 上的 apt-get，用这个软件可以轻松的装其他的 Mac 上的软件。主要是服务程序员的，这是一个非常重要的对于程序员来说不可或缺的 Mac 软件。官网在这里：<a target="_blank" rel="noopener" href="http://brew.sh/">http://brew.sh</a></p><ul><li><a target="_blank" rel="noopener" href="https://www.cakebrew.com/">Cakebrew</a>(Mac)开源免费</li></ul><p>Cakebrew 是 Mac OS X 平台上的 Homebrew GUI 应用。主要特性：搜索公式 、安装，卸载，升级、更新 Homebrew、运行 brew 清理工具</p><ul><li><a target="_blank" rel="noopener" href="http://www.browsersync.cn/">Browsersync</a>：省时的浏览器同步测试工具</li></ul><p>Browsersync 能让浏览器实时、快速响应您的文件更改（html、js、css、sass、less 等）并自动刷新页面。更重要的是 Browsersync 可以同时在 PC、平板、手机等设备下进项调试。</p><ul><li><a target="_blank" rel="noopener" href="https://kapeli.com/dash">Dash</a>(Mac)</li></ul><p>Dash 是一个 API 文档浏览器（ API Documentation Browser），以及代码片段管理工具（Code Snippet Manager），Dash 在 Mac App Store 里面免费提供下载。</p><ul><li><a target="_blank" rel="noopener" href="http://www.getmarkman.com/">Mark Man</a>(Win/Mac)</li></ul><p>高效的设计稿标注、测量工具，在没有 UI 支持的时候，需要对一些设计稿进行标注时异常好用</p><ul><li><a target="_blank" rel="noopener" href="https://xclient.info/s/charles.html">charles</a>(Win/Mac)</li></ul><p>是在 PC 端常用的网络封包截取工具，在做移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。 除了在做移动开发中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。 配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。</p><ul><li><a target="_blank" rel="noopener" href="https://www.mobiledebug.com/">Mobile Debug</a>(Win/Mac)</li></ul><p>代理抓包/移动端 H5 调试/debugger/请求劫持/HTTPS 支持/Hosts 管理/WebSocket 数据捕获/跨平台免费使用</p><ul><li><a target="_blank" rel="noopener" href="https://x5.tencent.com/tbs/guide/debug/download.html">TBS_Studio</a>(Win/Mac)</li></ul><p>腾讯出品的调试工具，可用与调试微信页面</p><h2 id="其他软件"><a href="#其他软件" class="headerlink" title="其他软件"></a>其他软件</h2><ul><li><a target="_blank" rel="noopener" href="https://u.tools/">uTools</a>(Win/Mac/Linux)</li></ul><p>让用户插件化定制属于自己的工具集，让生产过程一步到位。</p><ul><li><a target="_blank" rel="noopener" href="https://www.mediaatelier.com/CheatSheet/">CheatSheet</a>(Mac)</li></ul><p>是一款 Mac 上的非常实用的快捷键快速提醒工具，你只需要按住 Command 键，就会弹出当前应用的所有快捷键列表，所以你记不住一些软件的快捷键没有关系，只需要使用 CheatSheet，随时提醒你当前软件的所有快捷键，比如 Safari、Finder、Photoshop，简单实用并且完全免费，支持中文，非常不错！</p><ul><li><a target="_blank" rel="noopener" href="http://www.cockos.com/licecap/">licecap</a>(Windows/Mac)可以免费使用</li></ul><p>是一款屏幕录制工具，支持导出 GIF 动画图片格式，轻量级、使用简单，录制过程中可以随意改变录屏范围，本文中 Gif 图片就是这个软件生产出来的。官网：<a target="_blank" rel="noopener" href="http://www.cockos.com/licecap/">http://www.cockos.com/licecap/</a></p><ul><li>Moom(Mac)</li></ul><p>一款专为 Mac 准备的窗口管理工具,它能够让您移动和缩放窗口</p><ul><li><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/PicGo">picGo</a>(Mac)</li></ul><p>图床工具，一键上传图片，生成图片链接，支持 Markdown</p><ul><li><a target="_blank" rel="noopener" href="https://github.com/gee1k/uPic">upic</a>(Mac)</li></ul><p>也是一个图床工具，一键上传图片，生成图片链接，支持 Markdown</p><ul><li><a target="_blank" rel="noopener" href="https://github.com/kyleduo/TinyPNG4Mac">TinyPNG4Mac</a>(Mac)</li></ul><p>基于 tinyPng 的图片压缩软件，非常便捷</p><ul><li><a target="_blank" rel="noopener" href="https://xclient.info/s/istat-menus-for-mac.html">istat Menus</a>(Mac)</li></ul><p>iStat Menus for mac 是一款免费的 Mac OS 电脑硬件信息检测软件,安装完成后它位于“系统偏好设定”的应用程序面板，让您从选单列监测系统的各项丰富资讯，又不会占用使用者太大的桌面空间，提供的信息包括 CPU 使用情形、内存用量、硬盘使用情形、网络传输、机器温度、风扇转速等等。</p><ul><li><a target="_blank" rel="noopener" href="https://www.smartisan.com/apps/#/home">HandShaker</a>(Mac)</li></ul><p>锤子手机团队开发的，安装手机和 Mac 文件传输、管理软件。HandShaker 按文件类型智能为您整理您手机中的照片、音乐和视频，您还可以通过它对手机中的内容进行编辑操作。</p><ul><li><a target="_blank" rel="noopener" href="https://zh.snipaste.com/">snipaste</a>(Win/Mac)</li></ul><p>截图 + 贴图，Snipaste 是一个简单但强大的截图工具，也可以让你将截图贴回到屏幕上！下载并打开 Snipaste，按下 F1 来开始截图，再按 F3，截图就在桌面置顶显示了。就这么简单！</p><ul><li><a target="_blank" rel="noopener" href="https://ezip.awehunt.com/">eZip</a>(Mac)</li></ul><p>专为 MacOS 而设计的压缩软件</p><ul><li><a target="_blank" rel="noopener" href="https://www.xmind.cn/">XMind</a>(Win/Mac)</li></ul><p>生产力工具，XMind 是一个全功能的思维导图和头脑风暴软件，为激发灵感和创意而生。</p><ul><li><a target="_blank" rel="noopener" href="http://xclient.info/">破解软件下载</a>(Win/Mac)</li></ul><p>一个 MacOS 破解软件下载网站</p>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReactNative之入门全解</title>
      <link href="/2018-12/reactnative%E4%B9%8B%E5%85%A5%E9%97%A8%E5%85%A8%E8%A7%A3/"/>
      <url>/2018-12/reactnative%E4%B9%8B%E5%85%A5%E9%97%A8%E5%85%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>上手 RN 开发也有一段时间了，为了让团队其他同学也能快速上手，也算是对自己学习过程的一个记录。 这里整理了一下整个开发过程需要注意的点，因为是面向大前端所有同学，所以也包括了前端、android、ios 的相关知识。主要分成几个部分：环境搭建、基础知识（RN 基础、前端基础）、学习资源</p><span id="more"></span><h2 id="环境搭建和运行"><a href="#环境搭建和运行" class="headerlink" title="环境搭建和运行"></a>环境搭建和运行</h2><h3 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h3><p>按照官网<a target="_blank" rel="noopener" href="https://reactnative.cn/docs/0.51/getting-started.html">https://reactnative.cn/docs/0.51/getting-started.html</a>的教程一步一步来，不过还是遇坑无数，这里记录一下遇到的坑。</p><ol><li><p><a target="_blank" rel="noopener" href="https://cdn.leoao.com/jdk-8u131-macosx-x64.dmg">jDK 1.8 下载</a>困难，这里放到我们自己服务器了。</p></li><li><p>安装完 SDK 后，再安装 android studio，出现如下错误</p><p><img src="http://cdn.chuyunt.com/uPic/006tNc79gy1fruoitlzesj30ym0hiaco.jpg"></p><p><code>Unable to access Android SDK add-on list</code></p><p>第一次安装 Android studio 时候弹出 unable to access android sdk add-on list</p><p>原因：是你电脑没有 SDK 而且你下载的 android studio 又是不带 SDK 的；</p><p><strong>解决方法：</strong> 在自己安装的目录下找到：bin\idea.properties 打开这个文件末尾添加一行 disable.android.first.run=true 就行了，如果打不开这个文件，可以下载安装 EditPlus 工具或者 sublime_text 工具，用工具打开修改即可；如果这都嫌麻烦的话，那就用 txt 打开再简单不过了。但是并没有从根本上解决这个问题。</p></li><li><p>进入 android studio 后，安装项无法选择，android SDK 无法下载。</p><p><img src="http://cdn.chuyunt.com/uPic/006tNc79gy1fruoirrs0tj31a80lk41x.jpg"></p><p>原因：开启了 shadowsocks ，系统访问外部的 SDK 资源，但还是未下载成功。</p><p><strong>解决办法：</strong> 在打开 android Studio 时，先关闭 shadowsocks，等待进入 sdk 下载页面时，再开启 shadowsocks</p></li></ol><h3 id="安装测试"><a href="#安装测试" class="headerlink" title="安装测试"></a>安装测试</h3><pre><code class="bash">react-native init AwesomeProjectcd AwesomeProjectreact-native run-ios# 或者 react-native run-android</code></pre><blockquote><p>提示：</p></blockquote><ol><li>如果<code>run-ios</code>无法正常运行，请使用 Xcode 运行来查看具体错误（<code>run-ios</code>的报错没有任何具体信息），命令行执行<code>react-native start</code>，双击 ios/AwesomeProject.xcodeproj 文件，然后在 Xcode 中点击 Run 按钮。</li><li>你可以使用<code>--version</code>参数（注意是两个杠，版本号必须精确到两个小数点）创建指定版本的项目。例如<code>react-native init MyApp --version 0.44.3</code></li></ol><h3 id="运行调试"><a href="#运行调试" class="headerlink" title="运行调试"></a><a target="_blank" rel="noopener" href="https://reactnative.cn/docs/0.51/debugging.html#content">运行调试</a></h3><p>到这里你已经成功运行了项目，我们可以开始尝试动手改一改了：</p><ul><li>使用你喜欢的编辑器打开 App.js 并随便改上几行。</li><li>在 iOS Emulator 中按下 ⌘+R 就可以刷新 APP 并看到你的最新修改！</li><li>在 Android 上可以双击 R，可以刷新 APP 并看到你的最新修改</li></ul><h4 id="开启调试框"><a href="#开启调试框" class="headerlink" title="开启调试框"></a>开启调试框</h4><ul><li>在 iOS 模拟器中运行，还可以按下 Command⌘ + D 快捷键，Android 模拟器对应的则是 Command⌘ + M（windows 上可能是 F1 或者 F2）</li><li>使用真机时，摇晃手机，会弹出调试框。（android 需要开启悬浮框权限，才会弹出调试框）</li></ul><p><img src="https://cdn.leoao.com/blog/RN%E8%B0%83%E8%AF%95%E7%95%8C%E9%9D%A2.jpg?imageslim"></p><h4 id="刷新-JavaScript"><a href="#刷新-JavaScript" class="headerlink" title="刷新 JavaScript"></a>刷新 JavaScript</h4><ul><li>在 iOS 模拟器中按下 Command⌘ + R ，Android 模拟器上对应的则是按两下 R。</li><li>选择开发菜单中的”Enable Live Reload”可以开启自动刷新。(增加了新的资源(比如给 iOS 的 Images.xcassets 或是 Andorid 的 res/drawable 文件夹添加了图片)<br>更改了任何的原生代码)</li></ul><h4 id="应用内报错"><a href="#应用内报错" class="headerlink" title="应用内报错"></a>应用内报错</h4><ul><li>红屏或黄屏提示都只会在开发版本中显示，正式的离线包中是不会显示的。</li><li>可以通过在代码中执行<code>console.disableYellowBox = true;</code>，手动关闭警告</li><li>可以通过指定警告类型，来指定性关闭<code>console.ignoredYellowBox = [&#39;Warning: ...&#39;];</code></li></ul><h4 id="访问控制台日志"><a href="#访问控制台日志" class="headerlink" title="访问控制台日志"></a>访问控制台日志</h4><ul><li>可以在终端上执行<code>react-native log-ios</code>，或者在 iOS 模拟器的菜单中选择 Debug → Open System Log…来查看。</li><li>可以在终端上执行<code>react-native log-android</code>，或者在 Android 模拟器或是真机上，都可以通过在终端命令行里运行<code>adb logcat *:S ReactNative:V ReactNativeJS:V</code>命令来查看。</li></ul><h4 id="Chrome-开发者工具"><a href="#Chrome-开发者工具" class="headerlink" title="Chrome 开发者工具"></a>Chrome 开发者工具</h4><ul><li>在开发者菜单中选择”Debug JS Remotely”选项，即可以开始在 Chrome 中调试 JavaScript 代码。点击这个选项的同时会自动打开调试页面 <a target="_blank" rel="noopener" href="http://localhost:8081/debugger-ui">http://localhost:8081/debugger-ui</a>.</li></ul><h3 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h3><h4 id="1-ReactNative-iOS-运行出错：No-bundle-URL-present（整个页面红色）"><a href="#1-ReactNative-iOS-运行出错：No-bundle-URL-present（整个页面红色）" class="headerlink" title="1. ReactNative iOS 运行出错：No bundle URL present（整个页面红色）"></a>1. ReactNative iOS 运行出错：No bundle URL present（整个页面红色）</h4><p>此处，React Native iOS 中，iOS 模拟器运行又出现了：<code>No bundle URL present</code></p><ul><li>方法一，是由于：（shadowsocks 的）网络代理设置为了全局代理（去翻墙）</li></ul><blockquote><p>导致了之前可以正常连接到本地的 packager 的 server，由于全局网络代理，从而需要绕道国外服务器，再去连接本地，所以无法正常访问了</p></blockquote><blockquote><p>解决办法是：取消全局网络代理，改为自动模式即可。</p></blockquote><ul><li>方法二， 怀疑是因为环境被破坏了，重新安装依赖，启动环境。在 iOS 模拟器运行的情况下，在命令行内输入：</li></ul><pre><code class="bash">npm ireact-native run-ios</code></pre><h4 id="2-ReactNative-iOS-打开-WebView-出现-Error-Domain-NSURLErrorDomain-Code-1022"><a href="#2-ReactNative-iOS-打开-WebView-出现-Error-Domain-NSURLErrorDomain-Code-1022" class="headerlink" title="2. ReactNative iOS 打开 WebView 出现 Error Domain=NSURLErrorDomain Code=-1022"></a>2. ReactNative iOS 打开 WebView 出现 <code>Error Domain=NSURLErrorDomain Code=-1022</code></h4><p>原因是：iOS 开发中依然使用 http 请求，而非 https 请求，或者 https 请求内带有 http 请求。</p><p>解决方案： 修改 RN 项目中的 ios 文件夹下的项目文件内的<code>Info.plist</code>文件，如图添加下面代码</p><p><img src="http://cdn.chuyunt.com/uPic/006tNc79gy1fo99gokjf9j30w40fa3z2.jpg"></p><pre><code>&lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt;&lt;true/&gt;</code></pre><p>或者是在 Xcode 中，直接修改 Info.plist 文件</p><p><img src="http://cdn.chuyunt.com/uPic/006tNc79gy1fo99jtjtixj31cg0o4gpm.jpg"></p><h4 id="3-连接-android-真机无法成功安装"><a href="#3-连接-android-真机无法成功安装" class="headerlink" title="3. 连接 android 真机无法成功安装"></a>3. 连接 android 真机无法成功安装</h4><p>通过 命令行输入： <code>adb devices</code>，验证设备是否已连接，adb 安装如下：</p><pre><code class="bash"># 通过 Homebrew 安装brew cask install android-platform-tools# 测试是否正常安装adb devices</code></pre><p>若没有出现如下情况，说明设备还是没有成功连接，进入设备开发者模式，打开 USB 调试</p><p><img src="http://cdn.chuyunt.com/uPic/006tNc79gy1fruuv5wkh3j30rs048gm5.jpg"></p><h4 id="4-iOS-‘glog-logging-h’-file-not-found"><a href="#4-iOS-‘glog-logging-h’-file-not-found" class="headerlink" title="4. iOS: ‘glog/logging.h’ file not found"></a>4. iOS: ‘glog/logging.h’ file not found</h4><pre><code class="bash">cd node_modules/react-native/third-party/glog-0.3.4sh ../../scripts/ios-configure-glog.sh</code></pre><h4 id="5-iOS-Xcode-10-libfishhook-a-cannot-be-found"><a href="#5-iOS-Xcode-10-libfishhook-a-cannot-be-found" class="headerlink" title="5. iOS: Xcode 10 libfishhook.a cannot be found"></a>5. iOS: Xcode 10 libfishhook.a cannot be found</h4><p>先<code>-</code>libfishhook.a，再重新 <code>+</code>libfishhook.a</p><p><img src="https://cdn.leoao.com/blog/libfishhook.png?imageslim"></p><hr><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="前端知识"><a href="#前端知识" class="headerlink" title="前端知识"></a>前端知识</h3><p><strong>(针对客户端同学，前端同学可跳过)</strong></p><h4 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h4><p>前端包管理工具</p><pre><code class="bash"># 全局安装$ npm install 模块名 -g# 本地安装$ npm install 模块名# 一次性安装多个$ npm install 模块1 模块2 模块n --save# 安装运行时依赖包$ npm install 模块名 --save# 安装开发时依赖包$ npm install 模块名 --save-dev# 更新模块（包）$ npm update 模块名$ npm update 模块名 -g</code></pre><h4 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h4><h5 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h5><p><img src="https://cdn.leoao.com/blog/1669565-9b745c39f71db85f.bmp?imageslim"></p><p><img src="https://cdn.leoao.com/blog/1669565-6e0a7f2723dfe850.png?imageslim"></p><h5 id="层布局模型"><a href="#层布局模型" class="headerlink" title="层布局模型"></a>层布局模型</h5><blockquote><p>1、绝对定位(position: absolute) 2、相对定位(position: relative)</p></blockquote><ul><li>position:’relative’</li></ul><p>relative 指的是相对定位，配合 top, right, bottom, left 四个方位属性，加上 z-index 堆叠顺序来对一个元素进行相对于自己左上角为原点的定位。<br>没有脱离文档流，依然占据着原来的空间，不影响周边元素的位置，如果与其他元素相遇，按照 z-index 来觉得谁显示在“上面”而被我们看到，这个方式可以理解为“灵魂出窍”，“灵魂”展示在那里，但“窍”还占据着原有的空间。</p><ul><li>position:’absolute’</li></ul><p>绝对布局。它是相对于父级元素的左上角为原点来定位。绝对定位的元素不会占据原有的流式空间，后面的元素会“补上来”，这个和 html 的 position 也很大不一样。另外还有一个和 html 不一样的是，html 中 position:absolute 要求父容器的 position 必须是 absolute 或者 relative，如果第一层父容器 position 不是 absolute 或者 relative，在 html 会依次向上递归查询直到找到为止，然后居于找到的父容器绝对定位。</p><h5 id="样式规则"><a href="#样式规则" class="headerlink" title="样式规则"></a>样式规则</h5><blockquote><p>在 React Native 中，你并不需要学习什么特殊的语法来定义样式。我们仍然是使用 JavaScript 来写样式。所有的核心组件都接受名为 style 的属性。这些样式名基本上是遵循了 web 上的 CSS 的命名，只是按照 JS 的语法要求使用了驼峰命名法，例如将 background-color 改为 backgroundColor。</p></blockquote><ul><li>使用 StyleSheet.create 来集中定义组件的样式，如：</li></ul><pre><code class="jsx">import React, &#123; Component &#125; from &quot;react&quot;;import &#123; AppRegistry, StyleSheet, Text, View &#125; from &quot;react-native&quot;;export default class LotsOfStyles extends Component &#123;  render() &#123;    return (      &lt;View&gt;        &lt;Text style=&#123;styles.red&#125;&gt;just red&lt;/Text&gt;        &lt;Text style=&#123;styles.bigblue&#125;&gt;just bigblue&lt;/Text&gt;        &lt;Text style=&#123;[styles.bigblue, styles.red]&#125;&gt;bigblue, then red&lt;/Text&gt;        &lt;Text style=&#123;[styles.red, styles.bigblue]&#125;&gt;red, then bigblue&lt;/Text&gt;      &lt;/View&gt;    );  &#125;&#125;const styles = StyleSheet.create(&#123;  bigblue: &#123;    color: &quot;blue&quot;,    fontWeight: &quot;bold&quot;,    fontSize: 30,  &#125;,  red: &#123;    color: &quot;red&quot;,  &#125;,&#125;);AppRegistry.registerComponent(&quot;LotsOfStyles&quot;, () =&gt; LotsOfStyles);</code></pre><h5 id="flexBox"><a href="#flexBox" class="headerlink" title="flexBox"></a>flexBox</h5><p>可参考之前写过的文章：<a href="https://lion1ou.tech/2016/10/15/">css 之 flex 布局</a></p><h4 id="react"><a href="#react" class="headerlink" title="react"></a>react</h4><h5 id="jsx-的语法规则"><a href="#jsx-的语法规则" class="headerlink" title="jsx 的语法规则"></a>jsx 的语法规则</h5><ol><li>在 react 中想将 js 当作变量引入到 jsx 中需要使用{}</li><li>在 jsx 中，相邻的两个 jsx 元素 ，渲染时需要外面包裹着一层元素</li><li>{}取值表达式，取的是有返回值的结果， 可以放 JS 的执行结果</li></ol><pre><code class="js">import React, &#123; Component &#125; from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;function build(str) &#123;  return (    &lt;div&gt;      &#123;/*这是注释*/&#125;      &lt;h1&gt;&#123;str.name&#125;建立学校&lt;/h1&gt;      &lt;h1&gt;&#123;str.name&#125;建立学校&lt;/h1&gt;    &lt;/div&gt;  );&#125;// let el = &lt;div&gt;&#123;build(&#39;哈喽&#39;)&#125;&lt;/div&gt;;let el = &lt;div&gt;&#123;build(&#123; name: &quot;哈喽&quot; &#125;)&#125;&lt;/div&gt;;ReactDOM.render(el, document.getElementById(&quot;root&quot;));</code></pre><h5 id="循环数组的列子"><a href="#循环数组的列子" class="headerlink" title="循环数组的列子"></a>循环数组的列子</h5><pre><code class="js">import React, &#123; Component &#125; from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;let lessons = [  &#123; name: &quot;vue&quot;, price: 800 &#125;,  &#123; name: &quot;react&quot;, price: 1000 &#125;,];function toLesson(item) &#123;  return `当前课程是$&#123;item.name&#125; 价格是$&#123;item.price&#125;`;&#125;// 数组方法 find map filter reducelet ele = (  &lt;ul&gt;    &#123;lessons.map((item, index) =&gt;      // null在react中也是一个合法的元素 表示不存在，没有      item.price &lt; 1000 ? null : &lt;li key=&#123;index&#125;&gt;&#123;toLesson(item)&#125;&lt;/li&gt;    )&#125;  &lt;/ul&gt;);ReactDOM.render(ele, window.root);// window.root 直接取id</code></pre><h5 id="组件的两种定义方式"><a href="#组件的两种定义方式" class="headerlink" title="组件的两种定义方式"></a>组件的两种定义方式</h5><p>声明组件的方式有两种：函数声明（名字开头必须大写,没有生命周期、状态、this）和类声明（有生命周期： componentDidMount 渲染完成，componentWillUnmount 组件将要卸载,有状态和 this）</p><ul><li>第一种方式是函数声明</li></ul><pre><code class="js">import React,&#123;Component&#125; from &#39;react&#39;;import ReactDOM,&#123;render&#125; from &#39;react-dom&#39;;let school1 = &#123;name:&#39;张三&#39;,age:8&#125;;let school2 = &#123;name:&#39;李四&#39;,age:0&#125;;function Build(props) &#123;    return &lt;p&gt;&#123;props.name&#125;&#123;props.age&#125;&lt;/p&gt;&#125;render(&lt;div&gt;    &#123;/*&lt;Build name=&#123;school1.name&#125; age=&#123;school1.age&#125;/&gt;*/&#125;    &#123;/*&lt;Build name=&#123;school2.name&#125; age=&#123;school2.age&#125;/&gt;*/&#125;    &#123;/*将对象中的内容解构出来传递给Build组件  不用一个个取出来传递*/&#125;    &lt;Build name=&#123;...school1&#125;/&gt;    &lt;Build name=&#123;...school2&#125;/&gt;&lt;/div&gt;,window.root)</code></pre><ul><li>第二种方式是类声明</li></ul><pre><code class="js">import React, &#123; Component &#125; from &quot;react&quot;;import ReactDOM, &#123; render &#125; from &quot;react-dom&quot;;import PropTypes from &quot;prop-types&quot;; // 属性校验的包// 1、属性是由外界传递的，外面不能改属性，只有状态是属于组件自己的class School extends Component &#123;  // Component提供了列如this.setState()方法  static propType = &#123;    // 静态属性 es7,es6只支持静态函数    age: PropTypes.string,  &#125;;  static defaultProps = &#123;    // 校验默认属性    age: &quot;100&quot;,  &#125;;  // 类上有自己的构造函数constructor()，super()子类继承父类私有属性,extends继承的是公有  constructor(props) &#123;    super(props);  &#125;  render() &#123;    // render组件长什么样子，render的返回值只能有一个根元素    return (      // 通过&#123;&#125;取值不能打印对象  可以转化成字符串打印      &lt;div&gt;&#123;JSON.stringify(this.props)&#125;&lt;/div&gt;    );  &#125;&#125;// School.prototype = &#123;age:PropTypes.string&#125;;// render将虚拟dom装换成真实domrender(&lt;School name=&#123;&quot;珠峰&quot;&#125; age=&#123;8&#125; /&gt;, window.root);</code></pre><h5 id="组件内数据"><a href="#组件内数据" class="headerlink" title="组件内数据"></a>组件内数据</h5><blockquote><p>组件的数据来源有两个地方, props 外界传递过来的(默认属性，属性校验); state 状态是自己的,改变状态唯一的方式就是 setState</p></blockquote><ul><li>修改 state</li></ul><pre><code class="js">this.setState(&#123;  // 改变状态唯一的方式就是setState  count: &#123; number: this.state.count.number + 1 &#125;,&#125;);this.setState(  &#123;    // setState是异步的，依赖设置值 就需要在回调中执行    count: &#123; number: this.state.count.number + 1 &#125;,  &#125;,  () =&gt; &#123;    this.setState(&#123;      count: &#123; number: this.state.count.number + 1 &#125;,    &#125;);  &#125;);</code></pre><ul><li>组件通讯</li></ul><pre><code class="js">// 父传子class Panel extends Component &#123;  render() &#123;    let &#123; header, body &#125; = this.props;    return (      &lt;div className=&quot;container&quot; style=&#123;&#123; color: "red" &#125;&#125;&gt;        &lt;div className=&quot;panel-default panel&quot;&gt;          &lt;Header header=&#123;header&#125; /&gt;          &lt;Body body=&#123;body&#125; /&gt;        &lt;/div&gt;      &lt;/div&gt;    );  &#125;&#125;class Header extends Component &#123;  render() &#123;    return &lt;div className=&quot;panel-heading&quot;&gt;&#123;this.props.header&#125;&lt;/div&gt;;  &#125;&#125;class Body extends Component &#123;  render() &#123;    return &lt;div className=&quot;panel-body&quot;&gt;&#123;this.props.body&#125;&lt;/div&gt;;  &#125;&#125;</code></pre><pre><code class="js">// 子传父class Panel extends Component &#123;  constructor() &#123;    super();    this.state = &#123; color: &quot;primary&quot; &#125;;  &#125;  changColor = (color) =&gt; &#123;    // 到时候儿子传递一个颜色    this.setState(&#123; color: color &#125;);  &#125;;  render() &#123;    return (      &lt;div className=&quot;container&quot; style=&#123;&#123; color: "red" &#125;&#125;&gt;        &lt;div className=&#123;&quot;panel-&quot; + this.state.color + &quot; panel&quot;&#125;&gt;          &lt;Header header=&#123;this.props.header&#125; change=&#123;this.changColor&#125; /&gt;        &lt;/div&gt;      &lt;/div&gt;    );  &#125;&#125;class Header extends Component &#123;  handleClick = () =&gt; &#123;    this.props.change(&quot;danger&quot;);  &#125;;  render() &#123;    return (      &lt;div className=&quot;panel-heading&quot;&gt;        &#123;this.props.header&#125;        &lt;button className=&quot;btn btn-danger&quot; onClick=&#123;this.handleClick&#125;&gt;          改颜色        &lt;/button&gt;      &lt;/div&gt;    );  &#125;&#125;</code></pre><h5 id="组件声明周期"><a href="#组件声明周期" class="headerlink" title="组件声明周期"></a>组件声明周期</h5><pre><code class="js">class Counter extends React.Component &#123;  // 他会比较两个状态相等就不会刷新视图 PureComponent是浅比较  static defaultProps = &#123;    name: &quot;名字&quot;,  &#125;;  constructor(props) &#123;    super();    this.state = &#123; number: 0 &#125;;    console.log(&quot;1.constructor构造函数&quot;);  &#125;  componentWillMount() &#123;    // 取本地的数据 同步的方式：采用渲染之前获取数据，只渲染一次    console.log(&quot;2.组件将要加载 componentWillMount&quot;);  &#125;  componentDidMount() &#123;    console.log(&quot;4.组件挂载完成 componentDidMount&quot;);  &#125;  handleClick = () =&gt; &#123;    this.setState(&#123; number: this.state.number + 1 &#125;);  &#125;;  // react可以shouldComponentUpdate方法中优化 PureComponent 可以帮我们做这件事  shouldComponentUpdate(nextProps, nextState) &#123;    // 代表的是下一次的属性 和 下一次的状态    console.log(&quot;5.组件是否更新 shouldComponentUpdate&quot;);    return nextState.number % 2;    // return nextState.number!==this.state.number; //如果此函数种返回了false 就不会调用render方法了  &#125; //不要随便用setState 可能会死循环  componentWillUpdate() &#123;    console.log(&quot;6.组件将要更新 componentWillUpdate&quot;);  &#125;  componentDidUpdate() &#123;    console.log(&quot;7.组件完成更新 componentDidUpdate&quot;);  &#125;  render() &#123;    console.log(&quot;3.render&quot;);    return (      &lt;div&gt;        &lt;p&gt;&#123;this.state.number&#125;&lt;/p&gt;        &#123;this.state.number &gt; 3 ? null : &lt;ChildCounter n=&#123;this.state.number&#125; /&gt;&#125;        &lt;button onClick=&#123;this.handleClick&#125;&gt;+&lt;/button&gt;      &lt;/div&gt;    );  &#125;&#125;class ChildCounter extends Component &#123;  componentWillUnmount() &#123;    console.log(&quot;组件将要卸载componentWillUnmount&quot;);  &#125;  componentWillMount() &#123;    console.log(&quot;child componentWillMount&quot;);  &#125;  render() &#123;    console.log(&quot;child-render&quot;);    return &lt;div&gt;&#123;this.props.n&#125;&lt;/div&gt;;  &#125;  componentDidMount() &#123;    console.log(&quot;child componentDidMount&quot;);  &#125;  componentWillReceiveProps(newProps) &#123;    // 第一次不会执行，之后属性更新时才会执行    console.log(&quot;child componentWillReceiveProps&quot;);  &#125;  shouldComponentUpdate(nextProps, nextState) &#123;    return nextProps.n % 3; //子组件判断接收的属性 是否满足更新条件 为true则更新  &#125;&#125;// defaultProps// constructor// componentWillMount// render// componentDidMount// 状态更新会触发的// shouldComponentUpdate nextProps,nextState=&gt;boolean// componentWillUpdate// componentDidUpdate// 属性更新// componentWillReceiveProps newProps// 卸载// componentWillUnmount</code></pre><h3 id="iOS-知识"><a href="#iOS-知识" class="headerlink" title="iOS 知识"></a>iOS 知识</h3><p><strong>（针对前端同学，ios 同学可跳过）</strong></p><p>在使用 react-native 的时候，安装 ios 依赖时经常就会使用到 cocoapods，这里我们介绍一下 cocoaPods。</p><h4 id="什么是-CocoaPods"><a href="#什么是-CocoaPods" class="headerlink" title="什么是 CocoaPods"></a>什么是 CocoaPods</h4><p>CocoaPods 是 OS X 和 iOS 下的一个第三类库管理工具，通过 CocoaPods 工具我们可以为项目添加被称为“Pods”的依赖库（这些类库必须是 CocoaPods 本身所支持的），并且可以轻松管理其版本。</p><ol><li><p>在引入第三方库时它可以自动为我们完成各种各样的配置，包括配置编译阶段、连接器选项、甚至是 ARC 环境下的-fno-objc-arc 配置等。</p></li><li><p>使用 CocoaPods 可以很方便地查找新的第三方库，这些类库是比较“标准的”，而不是网上随便找到的，这样可以让我们找到真正好用的类库。</p></li></ol><h4 id="cocoapods-的安装"><a href="#cocoapods-的安装" class="headerlink" title="cocoapods 的安装"></a>cocoapods 的安装</h4><ol><li>gem 简介</li></ol><p>Gem 是一个管理 Ruby 库和程序的标准包，它通过 Ruby Gem（如 <a target="_blank" rel="noopener" href="http://rubygems.org/">http://rubygems.org/</a> ）源来查找、安装、升级和卸载软件包，非常的便捷。</p><blockquote><p>常用命令</p></blockquote><ul><li>查看 gem 版本 gem –version</li><li>更新 gem update –system</li><li>查看数据源 gem source</li><li>安装软件包 gem install 软件包名称</li><li>卸载安装包 gem uninstall</li></ul><ol start="2"><li>使用 gem 安装 cocoapods</li></ol><pre><code class="bash">sudo gem install cocoapods</code></pre><h4 id="使用-cocoapods-集成第三方"><a href="#使用-cocoapods-集成第三方" class="headerlink" title="使用 cocoapods 集成第三方"></a>使用 cocoapods 集成第三方</h4><p>1.检索第三方框架</p><p><code>pod search 框架关键字</code></p><p>内部原理：从本地缓存的”第三方框架描述信息” 生成的检索文件中检索到 相关框架的信息</p><p>常见错误：unable to find….</p><p>删除 cocoapods 索引文件</p><p>2.安装第三方框架</p><p>创建 Podfile 文件, 到自己工程内(一级目录)</p><p>Podfile 文件作用：其实就是使用 ruby 语法编写的 “框架依赖描述文件”; 就是告诉 cocoapods 需要下载集成哪些框架</p><p>创建命令: <code>pod init</code></p><p>3.安装框架</p><p>安装命令 <code>pod install</code></p><p>原理：直接就是根据 Podfile 文件从本地索引库中找到框架信息, 然后下载集成<br>找不到目标框架</p><p>更新本地框架信息源信息: pod install –no-repo-update (快速)</p><p>生成的重要文件 Podfile.lock</p><p>作用: 记录着上一次下载的框架最新版本</p><ul><li>pod install 和 pod update 区别</li></ul><p><code>pod install</code>: 如果 Podfile.lock 文件存在, 直接从此文件中读取框架信息下载安装, 如果不存在, 依然会读取 Podfile 文件内的框架信息,下载好之后, 再根据下载好的框架信息, 生成 Podfile.lock 文件</p><p><code>pod update</code> 不管 Podfile.lock 是否存在, 都会读取 Pod file 文件的的框架信息去下载。主要区别在于, Podfile 文件内的框架信息, 版本描述没有指定具体版本</p><h3 id="Android-知识"><a href="#Android-知识" class="headerlink" title="Android 知识"></a>Android 知识</h3><p><strong>（针对前端同学，android 同学可跳过）</strong></p><p>android 开发环境中，ADB 是我们进行 android 开发经常要用的调试工具，它的使用当然是我们 Android 开发者必须要掌握的；</p><p>Android Debug Bridge，Android 调试桥接器，简称 ADB，是用于管理模拟器或真机状态的万能工具，通俗一点讲 adb 就是 pc 和移动设备通信的桥梁，它采用了 c/s 模型，包括三个部分：</p><p>1、客户端部分，运行在开发用的电脑上，可以在命令行中运行 adb 命令来调用该客户端，像 ADB 插件和 DDMS 这样的 Android 工具也可以调用 adb 客户端，需要说明的是客户端与手机或者模拟器是一对多的关系，也就是说不管连接多少设备客户端就只有唯一的一个实例存在。</p><p>2、服务端部分，是运行在开发用电脑上的后台进程，用于管理客户端与运行在模拟器或真机的守护进程通信。</p><p>3、守护进程部分，运行于模拟器或手机的后台（简称 adb daemon）。</p><h4 id="常用的-ADB-命令"><a href="#常用的-ADB-命令" class="headerlink" title="常用的 ADB 命令"></a>常用的 ADB 命令</h4><p>1：<code>adb devices/adb get-serialno</code> 作用：列举当前连接的设备（可以是多个设备）；</p><p>执行结果如下所示：</p><pre><code class="bash">Listof devices attachedemulator-5554deviceemulator-5556deviceemulator-5558device</code></pre><blockquote><p>adb get-serialno 只能当连接一个设备时使用，并拿到设备的序列号；</p></blockquote><p>2：<code>adb -s / －e / -d</code> 作用：指定对某个连接成功的设备执行命令；</p><pre><code class="bash">adb -s emulator-5556  install helloWorld.apk</code></pre><p>这条命令就是往 emulator-5556 模拟器安装 apk 文件；</p><p>-s: 指定要操作的设备;</p><p>-e: 默认操作模拟器；</p><p>-d:默认操作硬件设备；</p><p>3：<code>adb install -r/-s</code> 作用：使用 adb install 命令可以从开发用电脑中复制应用程序并且安装到模拟器或手机上，adb install 命令必须指定待安装的.apk 文件的路径；</p><p>-r:保留数据和缓存文件，重新安装 apk</p><p>-s:安装 apk 到 sd 卡</p><p>4：<code>adb uninstall [-k] &#123;package&#125;</code> 作用：卸载指定包名的 apk 文件，(-k:不删除程序运行所产生的数据和缓存目录)</p><p>5：<code>adb pull [-a] &#123;remote-path&#125; &#123;local-path&#125;</code> 作用：从模拟器或手机拷贝文件或文件夹(包括文件夹的子目录)到电脑(-a:保留文件时间戳及属性)，remote-path 为手机端文件路径，local-path 为文件复制到的路径；</p><p>6：<code>adb push &#123;loacal-path&#125; &#123;remote-path&#125;</code> 作用：将文件或文件夹(包括文件夹的子目录)拷贝到模拟器或手机;</p><p>比如，我想把桌面的 log.txt 复制到手机的 dev 目录下，则命令如下：</p><pre><code class="bash">adb push /Users/littlejie/Desktop/log.txt  /dev</code></pre><p>7:  <code>adb kill-server</code> 和 <code>adb start-server</code> 作用：在某些情况下需要重启 adb 服务来解决问题，比如 adb 无响应，这时你可以通过 adb kill-server 来实现这一操作，之后，通过 adb start-server 命令来重启 adb 服务；</p><p>8:  <code>adb help</code> 作用：调出 adb 命令提示；</p><p>9:  <code>adb reboot</code> 作用：重启连接成功的设备。</p><p>如果连接了多个设备可以指定重启其中一个设备，命令如下</p><pre><code class="bash">adb -s xxx reboot</code></pre><p>10:  <code>adb shell cat /sys/class/net/wlan0/address</code> 作用：获取机器 mac 地址；</p><p>说明：adb shell 命令表示进入设备或模拟器的 shell 环境中，在这个 Linux Shell 中，你可以执行各种 Linux 的命令;</p><p>adb shell netcfg  //查看当前连接成功手机的 ip 地址；</p><p>11:  <code>adb shell am start -n &#123;packagename&#125;</code> 作用：启动指定包名的应用</p><p>12:  <code>adb shell ps</code> 作用 ：列出当前运行的进程；</p><p>13:  <code>adb shell mkdir path/foldelname</code> 作用：新建文件夹；</p><p><code>adb shell chmod777 &#123;folder&#125;</code>设置文件的权限;</p><p><code>adb shell cat &#123;folder/file&#125;</code> 查看文件内容；</p><h3 id="RN-基础知识"><a href="#RN-基础知识" class="headerlink" title="RN 基础知识"></a>RN 基础知识</h3><h4 id="样式-1"><a href="#样式-1" class="headerlink" title="样式"></a>样式</h4><blockquote><p>在 React Native 中，你并不需要学习什么特殊的语法来定义样式。我们仍然是使用 JavaScript 来写样式。所有的核心组件都接受名为 style 的属性。这些样式名基本上是遵循了 web 上的 CSS 的命名，只是按照 JS 的语法要求使用了驼峰命名法，例如将 background-color 改为 backgroundColor。</p></blockquote><ul><li>使用 StyleSheet.create 来集中定义组件的样式，如：</li></ul><blockquote><p>可以直接写在 style 上，也可以创建对象，相当于前端的 css 类</p></blockquote><blockquote><p>RN 布局主要使用 flexbox 布局，几乎所有样式都可以使用</p></blockquote><pre><code class="js">import React, &#123; Component &#125; from &quot;react&quot;;import &#123; AppRegistry, StyleSheet, Text, View &#125; from &quot;react-native&quot;;export default class LotsOfStyles extends Component &#123;  render() &#123;    return (      &lt;View&gt;        &lt;Text style=&#123;&#123; color: "red" &#125;&#125;&gt;just red&lt;/Text&gt;        &lt;Text style=&#123;styles.bigblue&#125;&gt;just bigblue&lt;/Text&gt;        &lt;Text style=&#123;[styles.bigblue, styles.red]&#125;&gt;bigblue, then red&lt;/Text&gt;        &lt;Text style=&#123;[styles.red, styles.bigblue]&#125;&gt;red, then bigblue&lt;/Text&gt;      &lt;/View&gt;    );  &#125;&#125;const styles = StyleSheet.create(&#123;  bigblue: &#123;    color: &quot;blue&quot;,    fontWeight: &quot;bold&quot;,    fontSize: 30,  &#125;,  red: &#123;    color: &quot;red&quot;,  &#125;,&#125;);AppRegistry.registerComponent(&quot;LotsOfStyles&quot;, () =&gt; LotsOfStyles);</code></pre><ul><li><code>&lt;Text&gt;</code> 元素布局不同于其他组件</li></ul><p>在 Text 内部的元素不再使用 flexbox 布局，而是采用文本布局。这意味着<code>&lt;Text&gt;</code>内部的元素不再是一个个矩形，而可能会在行末进行折叠。</p><ul><li>样式继承限制</li></ul><p>在 CSS 中，我们可以在 html 上设置可继承样式（font-size），浏览器在渲染每个节点，会在渲染树上，一路向上查询，直到根节点。但在 RN 中，第一，你必须把你的文本节点放在<code>&lt;Text&gt;</code>组件内，不能直接在<code>&lt;View&gt;</code>下放置文本。第二，不能设置全局的可继承样式，可使用组件和全局样式来实现。第三，只有在文本标签的子节点，才可以继承样式。</p><pre><code class="js">&lt;Text style=&#123;&#123; fontWeight: "bold" &#125;&#125;&gt;  I am bold  &lt;Text style=&#123;&#123; color: "red" &#125;&#125;&gt;and red&lt;/Text&gt;&lt;/Text&gt;</code></pre><ul><li>不同设备样式尺寸样式兼容，使用封装的方法对设计稿的尺寸进行转换</li></ul><pre><code class="js">const UIBaseWidth = 750; // 设计稿基础尺寸const px2dp = (UIPx) =&gt;  Math.floor(((UIPx * screenWidth) / UIBaseWidth) * 10) / 10; // 根据设计稿转换，向下取整保留一位小数// 具体使用&lt;View  style=&#123;&#123;    height: px2dp(222),    marginHorizontal: px2dp(32),    paddingVertical: px2dp(12),    backgroundColor: baseColor.veinsColorF5F5F5,    borderRadius: px2dp(8),    marginBottom: px2dp(80),  &#125;&#125;&gt;&lt;/View&gt;;</code></pre><ul><li>zIndex 调整层级无效(绝对定位的同级元素)</li></ul><p>实际在使用 zIndex 属性的时候发现根本没有效果，跟 web 的 z-index 所呈现的效果完全不一样</p><p><strong>解决方法：</strong></p><p>改变元素的顺序，而不使用 zIndex。默认情况下，使用了<code>position: &#39;absolute&#39;</code>后，在后面的元素会覆盖在前面的元素之上</p><ul><li>常用的样式</li></ul><p>详见之前写过的内容：<a href="http://lion1ou.tech/2018/05/29/">样式手册</a></p><h4 id="高度与宽度"><a href="#高度与宽度" class="headerlink" title="高度与宽度"></a>高度与宽度</h4><h5 id="弹性宽高"><a href="#弹性宽高" class="headerlink" title="弹性宽高"></a>弹性宽高</h5><ul><li>使用<code>flex: 1</code>来指定某个组件扩张以撑满所有剩余空间</li><li>多个并列子组件使用<code>flex: 1</code>，则这几个组件平分父组件剩余空间，如果数值不同比例也相应不同</li><li>前提是父组件的尺寸不为零（设置固定的 width，height，或 flex）</li></ul><pre><code class="html">&lt;View style=&quot;&#123;&#123;flex:" 1&#125;&#125;&gt;  &lt;View style=&quot;&#123;&#123;flex:" 2&#125;&#125;&gt;&lt;/View&gt;  &lt;View style=&quot;&#123;&#123;flex:" 1&#125;&#125;&gt;&lt;/View&gt;&lt;/View&gt;</code></pre><h5 id="Dimensions"><a href="#Dimensions" class="headerlink" title="Dimensions"></a>Dimensions</h5><p>本模块用于获取设备屏幕的宽高。</p><ul><li>初始的尺寸信息应该在 runApplication 之后被执行，这样才可以在任何其他的 require 被执行之前使用。不过在稍后可能还会更新。</li></ul><p>注意：尽管尺寸信息立即就可用，但它可能会在将来被修改（譬如设备的方向改变），所以基于这些常量的渲染逻辑和样式应当每次 render 之后都调用此函数，而不是将对应的值保存下来。（举例来说，你可能需要使用内联的样式而不是在 StyleSheet 中保存相应的尺寸）。</p><p>示例： <code>var &#123;height, width&#125; = Dimensions.get(&#39;window&#39;);</code></p><h4 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h4><p><a target="_blank" rel="noopener" href="https://reactnative.cn/docs/0.51/handling-touches.html#content">官方文档</a></p><blockquote><p>在 React Native 上处理点击等常见的触摸手势，不像在 web 上直接在标签上绑定相应的手势事件就好了。需要在对应的标签外包裹一个手势组件，再使用相应的事件进行触发。</p></blockquote><p>点击、长按事件，可以使用”Touchable”开头的一系列组件。这些组件通过<code>onPress</code>属性接受一个点击事件的处理函数，使用<code>onLongPress</code>属性来实现长按事件。默认以冒泡形式调用，可以通过处理代码，达到捕获形式调用。</p><pre><code class="js">class MyButton extends Component &#123;  _onPressButton() &#123;    console.log(&quot;You tapped the button!&quot;);  &#125;  render() &#123;    return (      &lt;TouchableHighlight onPress=&#123;this._onPressButton&#125;&gt;        &lt;View&gt;          &lt;Text&gt;Button&lt;/Text&gt;        &lt;/View&gt;      &lt;/TouchableHighlight&gt;    );  &#125;&#125;</code></pre><ul><li>TouchableHighlight: 背景会在用户手指按下时变暗</li><li>TouchableNativeFeedback: 在用户手指按下时形成类似墨水涟漪的视觉效果(在 Android)</li><li>TouchableOpacity: 在用户手指按下时降低按钮的透明度，而不会改变背景的颜色</li><li>TouchableWithoutFeedback: 在处理点击事件的同时不显示任何视觉反馈</li></ul><p>如果你想实现视图的拖拽，或是实现自定义的手势，那么请参阅 <a target="_blank" rel="noopener" href="https://reactnative.cn/docs/0.51/panresponder.html">PanResponder API</a> 或是手势识别系统的文档。</p><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><p><a target="_blank" rel="noopener" href="https://reactnative.cn/docs/0.51/network.html#content">官方文档</a></p><ul><li>Fetch</li></ul><blockquote><p>React Native 提供了和 web 标准一致的 Fetch API，用于满足开发者访问网络的需求。如果你之前使用过 XMLHttpRequest(即俗称的 ajax)或是其他的网络 API，那么 Fetch 用起来将会相当容易上手。</p></blockquote><pre><code class="js">fetch(&quot;https://mywebsite.com/endpoint/&quot;, &#123;  method: &quot;POST&quot;,  headers: &#123;    Accept: &quot;application/json&quot;,    &quot;Content-Type&quot;: &quot;application/json&quot;,  &#125;,  body: JSON.stringify(&#123;    firstParam: &quot;yourValue&quot;,    secondParam: &quot;yourOtherValue&quot;,  &#125;),&#125;);</code></pre><blockquote><p>注：默认情况下，iOS 会阻止所有非 HTTPS 的请求。如果你请求的接口是 http 协议，那么首先需要添加一个 App Transport Securty 的例外，或者干脆完全禁用 ATS，</p></blockquote><ul><li>使用其他的网络库（Axios）</li></ul><blockquote><p>React Native 中已经内置了 XMLHttpRequest API(也就是俗称的 ajax)。一些基于 XMLHttpRequest 封装的第三方库也可以使用，例如 frisbee 或是 axios 等，但注意不能使用 jQuery。<br>需要注意的是，安全机制与网页环境有所不同：在应用中你可以访问任何网站，没有跨域的限制。</p></blockquote><ul><li>WebSocket 支持</li></ul><blockquote><p>React Native 还支持 WebSocket，这种协议可以在单个 TCP 连接上提供全双工的通信信道。</p></blockquote><h4 id="基础-API"><a href="#基础-API" class="headerlink" title="基础 API"></a>基础 API</h4><h5 id="AppRegistry"><a href="#AppRegistry" class="headerlink" title="AppRegistry"></a>AppRegistry</h5><p>AppRegistry 负责注册运行 React Native 应用程序的入口。通过 AppRegistry.registerComponent 来注册，当注册完成后，Native 系统就会加载 jsbundle 文件并且触发 AppRegistry.runApplication 运行应用。有以下方法：</p><ol><li>registerConfig(config: Array):静态方法，注册配置。</li><li>registerComponent(appKey: string, getComponentFunc: ComponentProvider):注册入口组件。</li><li>registerRunnable(appKey: string, func: Function):注册函数监听。</li><li>getAppKeys():获取 registerRunnable 注册的监听键。</li><li>runApplication(appKey: string, appParameters: any):运行 App。</li></ol><h5 id="AsyncStorage"><a href="#AsyncStorage" class="headerlink" title="AsyncStorage"></a>AsyncStorage</h5><p>AsyncStorage 是一个简单的、具有异步特性的键值对的存储系统。相对整个 App 而言，它是全局的，应该用于替代 LocalStorage。</p><p>AsyncStorage 提供了比较安全的方法供我们使用。每个方法都有一个回调函数，而回调函数的第一个参数都是错误对象。如果发生错误该对象就会展示错误信息，否则为 null。所有的方法执行后，都会返回一个 Promise 对象。</p><h5 id="Linking"><a href="#Linking" class="headerlink" title="Linking"></a>Linking</h5><p>Linking 提供了一个通用的接口来与传入和传出的 App 链接进行交互。可以简单的理解为，跟其他 APP 的通讯。</p><ul><li>被外部链接打开(仅用在原生代码的项目, 本节仅适用于使用 react-native init 或使用 Create React Native App 创建的项目，这些项目已经弹出。 有关”弹出”的详细信息，请参阅 Create React Native App 代码库中的指南。)</li></ul><p>如果你的应用被其注册过的外部 url 调起，则可以在任何组件内这样获取和处理它：</p><pre><code class="js">componentDidMount() &#123;  Linking.getInitialURL().then((url) =&gt; &#123;    if (url) &#123;      console.log(&#39;Initial url is: &#39; + url);    &#125;  &#125;).catch(err =&gt; console.error(&#39;An error occurred&#39;, err));&#125;</code></pre><ul><li>打开外部链接</li></ul><p>要启动一个链接相对应的应用（打开浏览器、邮箱或者其它的应用），只需调用：</p><pre><code class="js">Linking.openURL(url).catch((err) =&gt; console.error(&quot;An error occurred&quot;, err));</code></pre><p>如果想在打开链接前先检查是否安装了对应的应用，则调用以下方法：</p><pre><code class="js">Linking.canOpenURL(url)  .then((supported) =&gt; &#123;    if (!supported) &#123;      console.log(&quot;Can&#39;t handle url: &quot; + url);    &#125; else &#123;      return Linking.openURL(url);    &#125;  &#125;)  .catch((err) =&gt; console.error(&quot;An error occurred&quot;, err));</code></pre><h5 id="PixelRatio"><a href="#PixelRatio" class="headerlink" title="PixelRatio"></a>PixelRatio</h5><p>PixelRatio 类提供了访问设备的像素密度的方法。</p><h5 id="AppState"><a href="#AppState" class="headerlink" title="AppState"></a>AppState</h5><p><a target="_blank" rel="noopener" href="https://reactnative.cn/docs/0.51/appstate.html#content">官方文档</a></p><p>APP 状态有三种：</p><ul><li>active - 应用正在前台运行。</li><li>background - 应用正在后台运行。用户既可能在别的应用中，也可能在桌面。</li><li>inactive - 此状态表示应用正在前后台的切换过程中，或是处在系统的多任务视图，又或是处在来电状态中。</li></ul><p>要获取当前的状态，你可以使用 AppState.currentState，这个变量会一直保持更新。不过在启动的过程中，currentState 可能为 null，直到 AppState 从原生代码得到通知为止。</p><h5 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h5><p>React Native 也没有完全做到说真正的跨平台使用，所以我们有时候会针对不同的平台做一些事情，使用 Platform.OS 可以获取到当前的设备平台：</p><pre><code class="js">import &#123; Text, Platform &#125; from &quot;react-native&quot;;&lt;Text&gt;  当前平台是：&#123;Platform.OS&#125;, Version: &#123;Platform.Version&#125;&lt;/Text&gt;;</code></pre><p>Platform.OS 在 iOS 上会返回 ios，而在 Android 设备或模拟器上则会返回 android。</p><p>还有个实用的方法是 Platform.select()，它可以以 Platform.OS 为 key，从传入的对象中返回对应平台的值，见下面的示例：</p><pre><code class="js">import &#123; Platform, StyleSheet &#125; from &quot;react-native&quot;;var styles = StyleSheet.create(&#123;  container: &#123;    flex: 1,    ...Platform.select(&#123;      ios: &#123;        backgroundColor: &quot;red&quot;,      &#125;,      android: &#123;        backgroundColor: &quot;blue&quot;,      &#125;,    &#125;),  &#125;,&#125;);</code></pre><h4 id="常用组件"><a href="#常用组件" class="headerlink" title="常用组件"></a>常用组件</h4><h5 id="View，ScrollView，FlatList"><a href="#View，ScrollView，FlatList" class="headerlink" title="View，ScrollView，FlatList"></a>View，ScrollView，FlatList</h5><p>ScrollView 和 FlatList 应该如何选择？ScrollView 会简单粗暴地把所有子元素一次性全部渲染出来。其原理浅显易懂，使用上自然也最简单。然而这样简单的渲染逻辑自然带来了性能上的不足。想象一下你有一个特别长的列表需要显示，可能有好几屏的高度。创建和渲染那些屏幕以外的 JS 组件和原生视图，显然对于渲染性能和内存占用都是一种极大的拖累和浪费。</p><p>这就是为什么我们还有专门的 FlatList 组件。FlatList 会惰性渲染子元素，只在它们将要出现在屏幕中时开始渲染。这种惰性渲染逻辑要复杂很多，因而 API 在使用上也更为繁琐。除非你要渲染的数据特别少，否则你都应该尽量使用 FlatList，哪怕它们用起来更麻烦。</p><h5 id="TextInput"><a href="#TextInput" class="headerlink" title="TextInput"></a>TextInput</h5><p>TextInput 是一个允许用户在应用中通过键盘输入文本的基本组件。本组件的属性提供了多种特性的配置，譬如自动完成、自动大小写、占位文字，以及多种不同的键盘类型（如纯数字键盘）等等。</p><h5 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h5><p>一个用于显示文本的 React 组件，并且它也支持嵌套、样式，以及触摸处理。</p><p>在下面的例子里，嵌套的标题和正文文字会继承来自 styles.baseText 的 fontFamily 字体样式，不过标题上还附加了它自己额外的样式。标题和文本会在顶部依次堆叠，并且被代码中内嵌的换行符分隔开。</p><pre><code class="js">// ...render() &#123;  return (    &lt;Text style=&#123;styles.baseText&#125;&gt;      &lt;Text style=&#123;styles.titleText&#125; onPress=&#123;this.onPressTitle&#125;&gt;        &#123;this.state.titleText&#125;      &lt;/Text&gt;      &lt;Text numberOfLines=&#123;5&#125;&gt;        &#123;this.state.bodyText&#125;      &lt;/Text&gt;    &lt;/Text&gt;  );&#125;const styles = StyleSheet.create(&#123;  baseText: &#123;    fontFamily: &#39;Cochin&#39;,  &#125;,  titleText: &#123;    fontSize: 20,    fontWeight: &#39;bold&#39;,  &#125;,&#125;);</code></pre><h5 id="Image-ImageBackground"><a href="#Image-ImageBackground" class="headerlink" title="Image, ImageBackground"></a>Image, ImageBackground</h5><p>用于显示多种不同类型图片的 React 组件，包括网络图片、静态资源、临时的本地图片、以及本地磁盘上的图片（如相册）等。</p><h5 id="KeyboardAvoidingView"><a href="#KeyboardAvoidingView" class="headerlink" title="KeyboardAvoidingView"></a>KeyboardAvoidingView</h5><p><a target="_blank" rel="noopener" href="https://reactnative.cn/docs/keyboardavoidingview.html">官方文档</a></p><p>本组件用于解决一个常见的尴尬问题：手机上弹出的键盘常常会挡住当前的视图。本组件可以自动根据键盘的位置，调整自身的 position 或底部的 padding，以避免被遮挡。</p><p>用法：</p><pre><code>import &#123; KeyboardAvoidingView &#125; from &#39;react-native&#39;;&lt;KeyboardAvoidingView style=&#123;styles.container&#125; behavior=&quot;padding&quot; enabled&gt;  ... 在这里放置需要根据键盘调整位置的组件 ...&lt;/KeyboardAvoidingView&gt;</code></pre><p><img src="https://cdn.leoao.com/Mar-24-2019%2019-05-25.gif"></p><h5 id="Modal"><a href="#Modal" class="headerlink" title="Modal"></a>Modal</h5><p><a target="_blank" rel="noopener" href="https://reactnative.cn/docs/modal.html">官方文档</a></p><p>Modal 组件是一种简单的覆盖在其他视图之上显示内容的方式。</p><h5 id="RefreshControl"><a href="#RefreshControl" class="headerlink" title="RefreshControl"></a>RefreshControl</h5><p>此组件用在 ScrollView 及其衍生组件的内部，用于添加下拉刷新的功能。</p><h3 id="两端兼容"><a href="#两端兼容" class="headerlink" title="两端兼容"></a>两端兼容</h3><h4 id="TextInput-1"><a href="#TextInput-1" class="headerlink" title="TextInput"></a>TextInput</h4><blockquote><ul><li>iOS 下的 textAlign 取值 auto left right center justify</li><li>android 下的 textAlign 取值为 start center end</li><li>安卓平台有黑色边框和选中黄框，可通过设置 underlineColorAndroid=’rgba(0,0,0,0)’去掉</li><li>安卓平台无清除按钮，可以使用 react-native-textinput 来兼容双平台</li></ul></blockquote><h4 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h4><blockquote><ul><li>iOS 下 resizeMode 可以写在行间属性，也可以写在 style，后者覆盖前者</li><li>android 下 resizeMode 只可以写在行间，写在 style 无效</li></ul></blockquote><pre><code class="js">//android&lt;Image resizeMode=&#123;&#39;stretch&#39;&#125;&gt;&lt;/Image&gt;//ios, style中的cover会覆盖掉stretch&lt;Image resizeMode=&#123;&#39;stretch&#39;&#125; style=&#123;&#123;'resizeMode': 'cover'&#125;&#125;&gt;&lt;/Image&gt;</code></pre><h4 id="Text-1"><a href="#Text-1" class="headerlink" title="Text"></a>Text</h4><blockquote><ul><li>allowFontScaling，控制字体是否要根据系统的“字体大小”辅助选项来进行缩放。默认值为 true。</li><li>textAlign: enum(‘auto’, ‘left’, ‘right’, ‘center’, ‘justify’)，指定文本的对齐方式。其中’justify’值仅 iOS 支持，在 Android 上会变为 left。</li></ul></blockquote><h4 id="style-position-‘absolute’"><a href="#style-position-‘absolute’" class="headerlink" title="style position: ‘absolute’"></a>style position: ‘absolute’</h4><blockquote><ul><li>iOS 下正常</li><li>android 下，position: ‘absolute’ 超过父节点高宽部分，会隐藏掉。</li></ul></blockquote><blockquote><p>解决办法：当需要用 position: ‘absolute’的时候，恰巧要求：子节点定位超出父节点高或宽，放弃使用，改用别的布局，或者将子节点放到于父节点同级，再定位。</p></blockquote><h4 id="picker-完全不一致"><a href="#picker-完全不一致" class="headerlink" title="picker 完全不一致"></a>picker 完全不一致</h4><blockquote><ul><li>iOS 组件是一个滚动的滚轮样式，</li><li>android 组件是一个下拉选框的样式</li></ul></blockquote><h4 id="有关屏幕的高度-Dimensions-get-‘window’-height"><a href="#有关屏幕的高度-Dimensions-get-‘window’-height" class="headerlink" title="有关屏幕的高度 Dimensions.get(‘window’).height"></a>有关屏幕的高度 Dimensions.get(‘window’).height</h4><blockquote><ul><li>两个平台都是整个屏幕的高度(包含 statusBar, 安卓端不包含虚拟按键)</li><li>iOS 平台的布局是从 statusBar 的顶端开始</li><li>android 平台的布局是从 statusBar 的底端开始(设置 translucent: true 后也从 statusBar 顶端开始)</li></ul></blockquote><p>如果设置 view 的高度是 Dimensions.get(‘window’).height，然后设置 position: ‘absolute’, top: 0，会发现 android 平台 view 的底端被遮住了一小部分，这一小部分正好就是 android 平台 statusBar 的高度<br>安卓端 statusBar 通常是 25dp，虚拟按键通常是 48dp</p><p>解决方法有四：</p><ul><li>设置 view 的高度是整屏的高度减去 statusBar 的高度</li><li>设置 top 值为负的 statusBar 的高度</li><li>设置 bottom: -Dimensions.get(‘window’).height 替代 top: 0</li><li>在每一个 Navigator 的入口设置&lt; StatusBar translucent={true}/ &gt;</li></ul><p>大坑: 有些手机通过上述方法获取到的屏幕高度竟然包含了虚拟按键的高度，如魅族 pro4，只能引入 react-native-device-info 这个库来 hack 一下了</p><h4 id="zIndex-层级问题"><a href="#zIndex-层级问题" class="headerlink" title="zIndex 层级问题"></a>zIndex 层级问题</h4><p>shadow（阴影）开头样式可以在 iOS 上应用，但在安卓中是不生效的，而 Android 上对应的属性是 elevation。设置 elevation 属性就等价于使用原生的 elevation API，因而也有同样的限制（比如最明显的就是需要 Android 5.0 以上版本）。此外还会影响到层叠视图在空间 z 轴上的顺序，结论：</p><ul><li><p>对于 Android，两个同一层级的定位组件（position：“absolute”）</p><p>1、 既没有 ZIndex 属性，又没有 elevation 属性时，在 z 轴的层叠关系由其摆放位置决定的，放在下面的组件会在上层；<br>2、 两个组件只有 zIndex 没有 elevation 属性时，zIndex 大的在上层<br>3、 两个组件有 elevation 属性时，elevation 大的在上层<br>4、 两个组件既有 zIndex 属性 elevation 属性时，以 elevation 为准</p></li><li><p>对于 IOS，同层级的组件，z 轴的层叠关系只与摆放顺序与 zIndex 有关，与 elevation 无关</p></li></ul><h3 id="外部组件库"><a href="#外部组件库" class="headerlink" title="外部组件库"></a>外部组件库</h3><h4 id="IconFont"><a href="#IconFont" class="headerlink" title="IconFont"></a>IconFont</h4><p><a href="http://lion1ou.tech/2018/11/17/">具体使用详情</a></p><h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><ol><li>分为两个一级页面组件，每个组件独立维护一套自己的路由地址</li><li>通过默认页面的路由重置，实现 RN 页面和 Native 页面的跳转</li></ol><p><img src="https://cdn.leoao.com/blog/coach-page-test.png?imageslim"></p><h2 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h2><h3 id="ES6-语法"><a href="#ES6-语法" class="headerlink" title="ES6 语法"></a>ES6 语法</h3><ul><li>阮一峰 ECMAScript 6 入门 <a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/">http://es6.ruanyifeng.com/</a></li></ul><h3 id="React-js"><a href="#React-js" class="headerlink" title="React.js"></a>React.js</h3><ul><li><p>react.js 入门教程(gitbook) <a target="_blank" rel="noopener" href="https://hulufei.gitbooks.io/react-tutorial/content/introduction.html">https://hulufei.gitbooks.io/react-tutorial/content/introduction.html</a></p></li><li><p><strong>react.js 快速入门教程 - 阮一峰</strong> <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2015/03/react.html">http://www.ruanyifeng.com/blog/2015/03/react.html</a></p></li><li><p>react.js 视频教程  <a target="_blank" rel="noopener" href="http://react-china.org/t/reactjs/584">http://react-china.org/t/reactjs/584</a></p></li><li><p>React Native 之 React 速学教程<a target="_blank" rel="noopener" href="https://github.com/crazycodeboy/RNStudyNotes/tree/master/React%20Native%E4%B9%8BReact%E9%80%9F%E5%AD%A6%E6%95%99%E7%A8%8B">https://github.com/crazycodeboy/RNStudyNotes/tree/master/React%20Native%E4%B9%8BReact%E9%80%9F%E5%AD%A6%E6%95%99%E7%A8%8B</a></p></li></ul><h3 id="React-Native"><a href="#React-Native" class="headerlink" title="React-Native"></a>React-Native</h3><ul><li><p>react-native 官方 api 文档  <a target="_blank" rel="noopener" href="http://facebook.github.io/react-native/docs/getting-started.html">http://facebook.github.io/react-native/docs/getting-started.html</a></p></li><li><p>react-native 中文文档(react native 中文网，人工翻译，官网完全同步) <a target="_blank" rel="noopener" href="http://react-native.cn/docs/getting-started.html">http://react-native.cn/docs/getting-started.html</a></p></li><li><p>react-native 中文文档(极客学院) <a target="_blank" rel="noopener" href="http://wiki.jikexueyuan.com/project/react-native/">http://wiki.jikexueyuan.com/project/react-native/</a></p></li><li><p>React Native 布局篇  <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000002658374">https://segmentfault.com/a/1190000002658374</a></p></li><li><p>React Native 基础练习指北（一） <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000002645929">https://segmentfault.com/a/1190000002645929</a></p></li><li><p>React Native 基础练习指北（二） <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000002647733">https://segmentfault.com/a/1190000002647733</a></p></li></ul><h3 id="进阶内容"><a href="#进阶内容" class="headerlink" title="进阶内容"></a>进阶内容</h3><ul><li><p><strong>React-native 组件库</strong>（比较全的组件库，可以直接搜索） <a target="_blank" rel="noopener" href="https://js.coach/">https://js.coach/</a></p></li><li><p><strong>最佳轮播类组件</strong> <a target="_blank" rel="noopener" href="https://github.com/leecade/react-native-swiper">https://github.com/leecade/react-native-swiper</a></p></li><li><p>选择器  <a target="_blank" rel="noopener" href="https://github.com/beefe/react-native-picker">https://github.com/beefe/react-native-picker</a></p></li><li><p>导航器 <a target="_blank" rel="noopener" href="https://github.com/react-navigation/react-navigation">https://github.com/react-navigation/react-navigation</a></p></li></ul><h3 id="资源网站"><a href="#资源网站" class="headerlink" title="资源网站"></a>资源网站</h3><ul><li><p>React-native 官网  <a target="_blank" rel="noopener" href="http://facebook.github.io/react-native/">http://facebook.github.io/react-native/</a></p></li><li><p><strong>React-China 社区</strong> <a target="_blank" rel="noopener" href="http://react-china.org/">http://react-china.org/</a></p></li><li><p><strong>React Native 中文社区</strong> <a target="_blank" rel="noopener" href="http://bbs.react-native.cn/">http://bbs.react-native.cn/</a></p></li><li><p><strong>React-native 组件库</strong>（比较全的组件库） <a target="_blank" rel="noopener" href="http://react.parts/">http://react.parts/</a></p></li><li><p><strong>React Native Modules</strong> <a target="_blank" rel="noopener" href="http://reactnativemodules.com/">http://reactnativemodules.com/</a></p></li><li><p><strong>Use React Native 资讯站</strong>(使用技巧及新闻) <a target="_blank" rel="noopener" href="http://www.reactnative.com/">http://www.reactnative.com/</a></p></li><li><p>React Native Tools <a target="_blank" rel="noopener" href="http://www.rntools.co/">http://www.rntools.co/</a></p></li><li><p>11 款 React Native 开源移动 UI 组件  <a target="_blank" rel="noopener" href="http://www.oschina.net/news/61214/11-react-native-ui-components">http://www.oschina.net/news/61214/11-react-native-ui-components</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReactNative之iconfont使用</title>
      <link href="/2018-11/reactnative%E4%B9%8Biconfont%E4%BD%BF%E7%94%A8/"/>
      <url>/2018-11/reactnative%E4%B9%8Biconfont%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>iconfont 显示成图形图标的字体，因为字体是矢量化图形，具有分辨率无关的特性，在任何分辨率和 ppi 下面，都可以做到完美缩放，不像传统位图如：png，jpg 一样，放大后会有锯齿或者模糊。<br>为什么使用 iconfont 对比图片大小来说容量更小，支持样式修改(大小，颜色)，适应多分辨率，网上有很多现成的 iconfont 资源可以使用。</p><span id="more"></span><h3 id="在-RN-中使用-iconfont"><a href="#在-RN-中使用-iconfont" class="headerlink" title="在 RN 中使用 iconfont"></a>在 RN 中使用 iconfont</h3><p>简单介绍完 iconfont，现在说说在 RN 中整么用它。这里推荐使用 react-native-vector-icons，它会把字体文件转换成相应的 iconSets 在 RN 供我们使用。</p><ul><li>安装 react-native-vector-icons</li></ul><pre><code class="bash">npm i --save react-native-vector-icons</code></pre><h3 id="ios-下配置"><a href="#ios-下配置" class="headerlink" title="ios 下配置"></a>ios 下配置</h3><p>用 XCode 打开项目目录下的 ios，为了管理字体，我们新建一个 fonts 目录，字体文件统一放在里面，把字体文件拖进这个文件夹。会有弹框提示并且记得 Add to targets 选中当前项目。</p><p><img src="http://cdn.chuyunt.com/ios-icon1.png"></p><p>确保 Build Phases 的 Copy Bundle REsources 中有字体文件</p><p><img src="http://cdn.chuyunt.com/ios-icon2.png"></p><p>接着修改 info.plist，在 information Property List 下新增 Fonts provided by application，在 Fonts provided by application 下在增加字体文件，到这里 ios 就配置好了。</p><p><img src="http://cdn.chuyunt.com/ios-icon3.png"></p><h3 id="android-配置"><a href="#android-配置" class="headerlink" title="android 配置"></a>android 配置</h3><p>安卓下会从 android/app/src/main/assets/fonts 目录读取字体文件，所以我们需要把字体文件<code>*.ttf</code>放在这个目录下，然后在 android/app/build.gradle 文件中按需增加下面的配置。</p><pre><code class="java">//使用内置的iconSetsapply from: &quot;../../node_modules/react-native-vector-icons/fonts.gradle&quot;//使用自定义iconSetsproject.ext.vectoricons = [   iconFontNames: [ &#39;iconfont.ttf&#39;] // Name of the font files you want to copy]</code></pre><p>使用内置的 iconSets</p><pre><code class="java">import Icon from &#39;react-native-vector-icons/FontAwesome&#39;;&lt;Icon name=&#39;rocket&#39; size=&#123;60&#125; color=&quot;#4F8EF7&quot; /&gt;</code></pre><p>上面的方式引用的是 react-native-vector-icons 内置的一种 iconSets, 除了 FontAwesome 还有其他 iconSets，可以到<a target="_blank" rel="noopener" href="https://github.com/oblador/react-native-vector-icons">react-native-vector-icons</a>查看</p><p>虽然内置了很多 iconSets 给我们使用，但往往我们做项目时一般都会使用自己的 iconfont，整么使用自己的 iconfont 呢？</p><p>react-native-vector-icons/FontAwesome 这个返回的是一个 iconSets，简单理解这个 iconSets 是一个可以帮我们显示字体图标的组件。其中 name 对应图标在 glyphMap.json 文件中对应的 key。</p><p>看 react-native-vector-icons/FontAwesome 的源码</p><pre><code class="java">/** * FontAwesome icon set component. * Usage: &lt;FontAwesome name=&quot;icon-name&quot; size=&#123;20&#125; color=&quot;#4F8EF7&quot; /&gt; */import createIconSet from &#39;./lib/create-icon-set&#39;;import glyphMap from &#39;./glyphmaps/FontAwesome.json&#39;;const iconSet = createIconSet(glyphMap, &#39;FontAwesome&#39;, &#39;FontAwesome.ttf&#39;);export default iconSet;</code></pre><p>createIconSet(glyphMap, fontFamily, fontFile)</p><p>参数说明：</p><ul><li>glyphMap: json 对象(key 是图标的 name, value 是图标对应的 10 进制数)</li><li>fontFamily: 字体库对应的 fontFamily</li><li>fontFile：字体文件名称(注意这里只声明字体库名称，字体库路径分平台配置)</li></ul><p>看 glyphMap 对应的 glyphmaps/FontAwesome.json</p><pre><code class="json">&#123;  &quot;glass&quot;: 61440,  &quot;music&quot;: 61441,  &quot;search&quot;: 61442,  &quot;envelope-o&quot;: 61443,  &quot;heart&quot;: 61444,  &quot;star&quot;: 61445&#125;</code></pre><p>总结一下：</p><p>就是根据字体文件(.ttf|.otf)和 glyphMap.json 创建对应的 IconSets，所以要想使用自定义的 iconfont 我们需要准备这两样东西。</p><h3 id="使用自定义的-iconSets"><a href="#使用自定义的-iconSets" class="headerlink" title="使用自定义的 iconSets"></a>使用自定义的 iconSets</h3><p>看完上面的源码分析，我们开始自定义 iconSets，先准备一套 iconfont，作者习惯使用阿里巴巴矢量图标库，这里就拿这个来作为栗子。选取你需要的图标，添加为一个项目，如下：</p><p>项目默认的 fontFamily 为 iconfont，还记得上面创建 iconSets 函数的第二个参数吗，每次对应的就是这个，这里我修改一下。</p><p>下载项目，里面的 iconfont.ttf 就是我们需要的 iconfont 了。</p><p>回想一下，创建 createIconSet 需要的东西，还少了 glyphMap，glyphMap 整么来呢。看这里</p><p>其中 e69b 是图标对应的 16 进制 unicode 我们需要的是 10 进制，所以把它转换一下， 下面使用的是 js</p><pre><code class="js">parseInt(&quot;e69b&quot;, 16);59035;</code></pre><p>每个图标都需要转换一次很麻烦，所以基于阿里巴巴图标矢量库下载的文件，我用 js 写了一个生成 json 的工具类。把刚下载下来的 iconfont.css，iconfont.json, genJson.js 放在同一目录。�node 执行 genJson.js，所需要的 json 对象就被写入 iconfont.json 中了。</p><pre><code class="css">/*iconfont.css*//* ...省略... */.ica &#123;  font-family: &quot;ica&quot; !important;  font-size: 16px;  font-style: normal;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;&#125;.icon-all:before &#123;  content: &quot;\e696&quot;;&#125;.icon-back:before &#123;  content: &quot;\e697&quot;;&#125;.icon-cart:before &#123;  content: &quot;\e698&quot;;&#125;.icon-category:before &#123;  content: &quot;\e699&quot;;&#125;.icon-close:before &#123;  content: &quot;\e69a&quot;;&#125;.icon-comments:before &#123;  content: &quot;\e69b&quot;;&#125;</code></pre><pre><code class="js">/*genJson.js*/const path = require(&quot;path&quot;);const oldPath = path.resolve(__dirname, &quot;iconfont.css&quot;);const newPath = path.resolve(__dirname, &quot;iconfont.json&quot;);var gen = (module.exports = function () &#123;  const readline = require(&quot;readline&quot;);  const fs = require(&quot;fs&quot;);  const fRead = fs.createReadStream(oldPath);  const fWrite = fs.createWriteStream(newPath, &#123;    flags: &quot;w+&quot;,    defaultEncoding: &quot;utf8&quot;,  &#125;);  const objReadLine = readline.createInterface(&#123;    input: fRead,  &#125;);  var ret = &#123;&#125;;  objReadLine.on(&quot;line&quot;, (line) =&gt; &#123;    line = line &amp;&amp; line.trim();    if (!line.includes(&quot;:before&quot;) || !line.includes(&quot;content&quot;)) return;    var keyMatch = line.match(/\.(.*?):/);    var valueMatch = line.match(/content:.*?\\(.*?);/);    var key = keyMatch &amp;&amp; keyMatch[1];    var value = valueMatch &amp;&amp; valueMatch[1];    value = parseInt(value, 16);    key &amp;&amp; value &amp;&amp; (ret[key] = value);  &#125;);  objReadLine.on(&quot;close&quot;, () =&gt; &#123;    console.log(&quot;readline close&quot;);    fWrite.write(JSON.stringify(ret), &quot;utf8&quot;);  &#125;);&#125;);gen();</code></pre><p>创建 iconSets 需要的东西都准备好了，开始创建吧。</p><pre><code class="js">／*iconfont.json*／&#123;  &quot;icon-comments&quot;:  59035,  &quot;icon-close&quot;: 59034&#125;/*iconSets.js*/import createIconSet from &#39;react-native-vector-icons/lib/create-icon-set&#39;;import glyphMap from &#39;./assets/fonts/iconfont.json&#39;;const iconSet = createIconSet(glyphMap, &quot;ica&quot;, &#39;iconfont.ttf&#39;);export default iconSet;/* componet.js*/...import Icon from &#39;./iconSets&#39;;&lt;Icon name=&#39;icon-comments&#39; size=&#123;60&#125; color=&quot;#4F8EF7&quot; /&gt;</code></pre><p>运行一下，看字体显示出来了</p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReactNative之导航器使用</title>
      <link href="/2018-07/reactnative%E4%B9%8B%E5%AF%BC%E8%88%AA%E5%99%A8%E4%BD%BF%E7%94%A8/"/>
      <url>/2018-07/reactnative%E4%B9%8B%E5%AF%BC%E8%88%AA%E5%99%A8%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>主要是介绍了 react-navigation 的相关配置和样式设置，以及 react-navigation 内的 navigation 属性。navigator 主要分为以下三种类型：StackNavigator、TabNavigator、DrawerNavigator，每种类型都有其相应的使用场景和配置项。</p><span id="more"></span><h2 id="navigator-类型"><a href="#navigator-类型" class="headerlink" title="navigator 类型"></a>navigator 类型</h2><h3 id="StackNavigator"><a href="#StackNavigator" class="headerlink" title="StackNavigator"></a>StackNavigator</h3><p>StackNavigator 组件采用堆栈式的页面导航来实现各个界面跳转。它的构造函数：</p><pre><code class="js">StackNavigator(RouteConfigs, StackNavigatorConfig);</code></pre><p>有 RouteConfigs 和 StackNavigatorConfig 两个参数。</p><h5 id="RouteConfigs"><a href="#RouteConfigs" class="headerlink" title="RouteConfigs"></a>RouteConfigs</h5><p>表示各个页面路由配置，类似于前端路由配置页，它是让导航器知道需要导航的路由对应的页面。</p><pre><code class="js">const RouteConfigs = &#123;  Home: &#123;    screen: HomePage,    navigationOptions: (&#123; navigation &#125;) =&gt; (&#123;      title: &quot;首页&quot;,    &#125;),  &#125;,  Find: &#123;    screen: FindPage,    navigationOptions: (&#123; navigation &#125;) =&gt; (&#123;      title: &quot;发现&quot;,    &#125;),  &#125;,  Mine: &#123;    screen: MinePage,    navigationOptions: (&#123; navigation &#125;) =&gt; (&#123;      title: &quot;我的&quot;,    &#125;),  &#125;,&#125;;</code></pre><p>这里给导航器配置了三个页面，Home、Find、Mine 为路由名称，screen 属性值 HomePage、FindPage、MinePage 为对应路由的页面。</p><h5 id="navigationOptions"><a href="#navigationOptions" class="headerlink" title="navigationOptions"></a>navigationOptions</h5><blockquote><p>上述代码中的 navigationOptions 是配置对应路由页面的一些属性。</p></blockquote><ul><li>title：标题，可当作 headerTitle 的备用的字符串，不推荐使用</li><li>header：可以设置一些导航的属性，如果隐藏顶部导航栏只要将这个属性设置为 null</li><li>headerTitle：设置导航栏标题，推荐</li><li>headerTitleAllowFontScaling：标题栏中字体是否根据字体大小自动缩放设置。 默认为 true。</li><li>headerBackTitle：iOS 上的返回按钮的文字使用的字符串，或者使用 null 来禁用。默认为上一个页面的 headerTitle。</li><li>headerTruncatedBackTitle：设置当上个页面标题不符合返回箭头后的文字时（一般是因为文字太多），默认改成”返回”</li><li>headerRight：设置导航条右侧。可以是按钮或者其他视图控件</li><li>headerLeft：设置导航条左侧。可以是按钮或者其他视图控件</li><li>headerStyle：设置导航条的样式。背景色，宽高等</li><li>headerTitleStyle：设置导航栏文字样式</li><li>headerBackTitleStyle：设置导航栏‘返回’文字样式</li><li>headerTintColor：设置导航栏颜色</li><li>headerPressColorAndroid：安卓独有的设置颜色纹理，需要安卓版本大于 5.0</li><li>gesturesEnabled：是否支持滑动返回手势，iOS 默认支持，安卓默认关闭</li><li>gestureResponseDistance：触发滑动返回手势的属性<ul><li>horizontal - 数值型 - 水平方向的距离，默认值 25</li><li>vertical - 数值型 - 垂直方向的距离，默认值 135.</li></ul></li><li>gestureDirection：用来设置关闭页面的手势方向，默认 default 是从做往右，inverted 是从右往左</li></ul><h5 id="StackNavigatorConfig"><a href="#StackNavigatorConfig" class="headerlink" title="StackNavigatorConfig"></a>StackNavigatorConfig</h5><blockquote><p>可以通过设置 StackNavigatorConfig，来全局设置 navigator 页面的基本样式和属性</p></blockquote><pre><code class="js">const StackNavigatorConfig = &#123;  initialRouteName: &quot;Home&quot;,  initialRouteParams: &#123; initPara: &quot;初始页面参数&quot; &#125;,  navigationOptions: &#123;    title: &quot;标题&quot;,    headerTitleStyle: &#123; fontSize: 18, color: &quot;#666666&quot; &#125;,    headerStyle: &#123; height: 48, backgroundColor: &quot;#fff&quot; &#125;,  &#125;,  paths: &quot;page/main&quot;,  mode: &quot;card&quot;,  headerMode: &quot;screen&quot;,  cardStyle: &#123; backgroundColor: &quot;#ffffff&quot; &#125;,  transitionConfig: () =&gt; (&#123;    screenInterpolator: CardStackStyleInterpolator.forHorizontal,  &#125;),  onTransitionStart: () =&gt; &#123;    console.log(&quot;页面跳转动画开始&quot;);  &#125;,  onTransitionEnd: () =&gt; &#123;    console.log(&quot;页面跳转动画结束&quot;);  &#125;,&#125;;</code></pre><ul><li>initialRouteName：设置默认的页面组件，必须是上面已注册的页面组件</li><li>initialRouteParams：初始路由参数</li><li>navigationOptions：用于页面的默认导航选项</li><li>mode：定义跳转风格<ul><li>card：使用 iOS 和安卓默认的风格</li><li>modal：iOS 独有的使屏幕从底部画出。类似 iOS 的 present 效果</li></ul></li><li>headerMode：返回上级页面时动画效果<ul><li>float：iOS 默认的效果，渲染一个放在顶部的标题栏，并在页面改变时显示动画。 这是 iOS 上的常见模式。</li><li>screen：渲染一个放在顶部的标题栏，并在页面改变时显示动画。 这是 iOS 上的常见模式。</li><li>none：无动画</li></ul></li><li>cardStyle：自定义设置跳转效果</li><li>transitionConfig： 自定义设置滑动返回的配置<ul><li>transitionProps - 新页面跳转的属性。</li><li>prevTransitionProps - 上一个页面跳转的属性</li><li>isModal - 指定页面是否为 modal。</li></ul></li><li>onTransitionStart：当转换动画即将开始时被调用的功能</li><li>onTransitionEnd：当转换动画完成，将被调用的功能</li><li>path：路由中设置的路径的覆盖映射配置，path 属性适用于其他 app 或浏览器使用 url 打开本 app 并进入指定页面。path 属性用于声明一个界面路径，例如：【/pages/Home】。此时我们可以在手机浏览器中输入：app 名称://pages/Home 来启动该 App，并进入 Home 界面。</li></ul><h5 id="页面内配置"><a href="#页面内配置" class="headerlink" title="页面内配置"></a>页面内配置</h5><p>页面的配置选项 navigationOptions 通常还可以在对应页面中去静态配置，比如在 HomePage 页面中：</p><pre><code class="js">export default class HomePage extends Component &#123;  // 配置页面导航选项  static navigationOptions = (&#123; navigation &#125;) =&gt; (&#123;    title: &quot;HOME&quot;,    titleStyle: &#123; color: &quot;#ff00ff&quot; &#125;,    headerStyle: &#123; backgroundColor: &quot;#000000&quot; &#125;,  &#125;);  render() &#123;    return &lt;View&gt;&lt;/View&gt;;  &#125;&#125;</code></pre><blockquote><p>同样地，在页面里面采用静态的方式配置 navigationOptions 中的属性，会覆盖 StackNavigator 构造函数中两个参数 RouteConfigs 和 StackNavigatorConfig 配置的 navigationOptions 里面的对应属性。navigationOptions 中属性的优先级是：页面中静态配置 &gt; RouteConfigs &gt; StackNavigatorConfig</p></blockquote><p>已经配置好导航器以及对应的路由页面了，但是要完成页面之间的跳转，还需要 navigation。</p><h5 id="navigation"><a href="#navigation" class="headerlink" title="navigation"></a>navigation</h5><p>在导航器中的每一个页面，都有 navigation 属性，该属性有以下几个属性/方法：</p><ul><li>navigate - 跳转到其他页面</li><li>state - 当前页面导航器的状态</li><li>setParams - 更改路由的参数</li><li>goBack - 返回</li><li>dispatch - 发送一个 action</li></ul><p><strong>navigete</strong></p><p>调用这个方法可以跳转到导航器中的其他页面，此方法有三个参数：</p><ul><li>routeName 导航器中配置的路由名称</li><li>params 传递参数到下一个页面</li><li>action action</li></ul><p>比如：this.props.navigation.navigate(‘Find’, {param: ‘i am the param’});</p><p><strong>state</strong></p><p>state 里面包含有传递过来的参数 params、key、路由名称 routeName，打印 log 可以看得到：</p><pre><code class="js">&#123;  params: &#123; param: &#39;i am the param&#39; &#125;,  key: &#39;id-1500546317301-1&#39;,  routeName: &#39;Mine&#39;&#125;</code></pre><p><strong>setParams</strong></p><p>更改当前页面路由的参数，比如可以用来更新头部的按钮或者标题。</p><pre><code class="js">componentDidMount() &#123;    this.props.navigation.setParams(&#123;param:&#39;i am the new param&#39;&#125;)&#125;</code></pre><p><strong>goBack</strong></p><p>回退，可以不传，也可以传参数，还可以传 null。</p><pre><code class="js">this.props.navigation.goBack(); // 回退到上一个页面this.props.navigation.goBack(null); // 回退到任意一个页面this.props.navigation.goBack(&quot;Home&quot;); // 回退到Home页面复制代码</code></pre><p><strong>dispatch</strong></p><h3 id="TabNavigator"><a href="#TabNavigator" class="headerlink" title="TabNavigator"></a>TabNavigator</h3><pre><code class="js">TabNavigator(RouteConfigs, TabNavigatorConfig);</code></pre><p>TabNavigator 配置与 StackNavigator 配置是一样的。</p><ul><li>screen：和导航的功能是一样的，对应界面名称，可以在其他页面通过这个 screen 传值和跳转。</li></ul><h5 id="navigationOptions-1"><a href="#navigationOptions-1" class="headerlink" title="navigationOptions"></a>navigationOptions</h5><ul><li>title：标题，可用作 headerTitle 和 tabBarLabel 回退标题</li><li>tabBarVisible：是否隐藏标签栏。默认不隐藏(true)</li><li>tabBarIcon：设置标签栏的图标。需要给每个都设置</li><li>tabBarLabel：设置标签栏的 title。推荐</li><li>swipeEnabled：是否允许 tab 页之间滑动切换，如果未设置，则使用 TabNavigatorConfig 的 swipeEnabled 选项</li><li>tabBarOnPress：tab 被点击时的回调函数；参数是一个对象，包含一下属性：<ul><li>previousScene: { route, index } ：正在离开的页面</li><li>scene: { route, index } 被点击的页面</li><li>jumpToIndex 执行跳转操作必须的参数</li></ul></li></ul><h5 id="TabNavigatorConfig"><a href="#TabNavigatorConfig" class="headerlink" title="TabNavigatorConfig"></a>TabNavigatorConfig</h5><ul><li>tabBarComponent - 用作渲染 tab bar 的组件，例如 TabBarBottom（这是 iOS 上的默认设置），TabBarTop（这是 Android 上的默认设置）。</li><li>tabBarPosition：设置 tabbar 的位置，iOS 默认在底部，安卓默认在顶部。（属性值：’top’，’bottom’）</li><li>swipeEnabled：是否允许在标签之间进行滑动</li><li>animationEnabled：是否在更改标签时显示动画</li><li>configureTransition - 给定 currentTransitionProps 和 nextTransitionProps 的函数，其返回一个配置对象，该对象用于描述 tab 页之间的动画</li><li>initialLayout - 可以传递包含初始 height 和 width 的可选对象，用以防止 react-native-tab-view 渲染中一个帧的延迟</li><li>tabBarOptions - Tab 配置属性，用在 TabBarTop 和 TabBarBottom 时有些属性不一致：<ul><li>用在 TabBarBottom(在 iOS 上的默认 tabBar)<ul><li>activeTintColor：label 和 icon 的前景色 活跃状态下</li><li>activeBackgroundColor：label 和 icon 的背景色 活跃状态下</li><li>inactiveTintColor：label 和 icon 的前景色 不活跃状态下</li><li>inactiveBackgroundColor：label 和 icon 的背景色 不活跃状态下</li><li>showLabel：是否显示 label，默认开启</li><li>style：tabbar 的样式</li><li>labelStyle：label 的样式安卓属性</li><li>tabStyle - tab 页的样式</li><li>allowFontScaling - 文本字体大小是否可以缩放取决于该设置，默认为 true。</li></ul></li><li>用在 TabBarTop(在 Android 上的默认 tabBar)<ul><li>activeTintColor：label 和 icon 的前景色 活跃状态下</li><li>inactiveTintColor：label 和 icon 的前景色 不活跃状态下</li><li>showIcon：是否显示图标，默认关闭</li><li>showLabel：是否显示 label，默认开启 style：tabbar 的样式</li><li>upperCaseLabel - 是否将文本转换为大小，默认是 true</li><li>pressColor - material design 中的波纹颜色(仅支持 Android &gt;= 5.0)</li><li>pressOpacity - 按下 tab bar 时的不透明度(仅支持 iOS 和 Android &lt; 5.0).</li><li>scrollEnabled - 是否允许滑动切换</li><li>tabStyle - tab 页的样式</li><li>indicatorStyle - tab 页指示符的样式 (tab 页下面的一条线).</li><li>labelStyle - tab bar 的文本样式</li><li>iconStyle - tab bar 的图标样式</li><li>style - tab bar 的样式</li><li>allowFontScaling - 文本字体大小是否可以缩放取决于该设置，默认为 true。</li></ul></li></ul></li></ul><p>几个被传递到底层的路由，用于修改导航逻辑的选项</p><ul><li>initialRouteName - 第一次加载 tab bar 时路由的 routeName</li><li>order - 定义了 tab bar 顺序的一个 routeNames 数组</li><li>paths - 提供 routeName 到 path config 的映射，它覆盖了 routeConfigs 中设置的 path。</li><li>backBehavior - 返回按钮是否会导致 tab 切换到初始 tab 页？ 如果是，则设置为 initialRoute，否则为 none。 默认为 initialRoute。</li></ul><h3 id="DrawerNavigator"><a href="#DrawerNavigator" class="headerlink" title="DrawerNavigator"></a>DrawerNavigator</h3><p>在原生 Android MD 风格里面很多 app 都会采用侧滑抽屉来做主页面的导航，利用 DrawerNavigator 在 RN 中可以很方便来实现抽屉导航。</p><pre><code class="js">DrawerNavigator(RouteConfigs, DrawerNavigatorConfig);</code></pre><p>和 DrawerNavigator 的构造函数一样，参数配置也类似。</p><p>可以手动去操作抽屉导航</p><pre><code class="js">this.props.navigation.navigate(&quot;DrawerOpen&quot;); // open drawerthis.props.navigation.navigate(&quot;DrawerClose&quot;); // close drawerthis.props.navigation.navigate(&quot;DrawerToggle&quot;); // toggle drawer</code></pre><h5 id="DrawerNavigatorConfig"><a href="#DrawerNavigatorConfig" class="headerlink" title="DrawerNavigatorConfig"></a>DrawerNavigatorConfig</h5><ul><li>drawerWidth - 抽屉的宽度</li><li>drawerPosition - 选项是左或右。 默认为左侧位置</li><li>contentComponent - 用于呈现抽屉内容的组件，例如导航项。 接收抽屉的导航。 默认为 DrawerItems</li><li>useNativeAnimations - 是否使用原生动画，默认 true.</li><li>drawerBackgroundColor - 抽屉的背景色，默认是 white.</li><li>contentOptions 用来配置抽屉内容的属性。<ul><li>items - 路由数组，可以被修改或者覆盖</li><li>activeItemKey - 当前选中页的路由的 key</li><li>activeTintColor - 选中的 DrawerItem 的文本和图标颜色</li><li>activeBackgroundColor - 选中的 DrawerItem 的背景色</li><li>inactiveTintColor - 未选中的 DrawerItem 的文本和图标颜色</li><li>inactiveBackgroundColor - 未选中的 DrawerItem 的背景色</li><li>onItemPress(route) - DrawerItem 被点击时触发的事件</li><li>itemsContainerStyle - DrawerItem 容器的样式</li><li>itemStyle - 每个 DrawerItem 的样式, 可以包含文本或图标</li><li>labelStyle - 当文本是字符串时，设置 DrawerItem 中文本的样式</li><li>iconContainerStyle - 用于覆盖 View 图标容器的样式</li></ul></li></ul><p>几个被传递到底层的路由，用于修改导航逻辑的选项</p><ul><li>initialRouteName - 初始路由的 routeName</li><li>order - 定义抽屉项目顺序的 routeNames 数组。</li><li>paths - 提供 routeName 到路径配置的映射，它覆盖 routeConfigs 中设置的路径。</li><li>backBehavior - 后退按钮是否会切换到初始路由？ 如果是，设置为 initialRoute，否则为 none。 默认为 initialRoute 行为</li></ul><h3 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h3><pre><code class="js">let _this = null;export default class WebViewPage extends Component &#123;    static navigationOptions = (&#123; navigation &#125;) =&gt; (&#123;        // ......                    onPress=&#123;() =&gt; _this.reload() &#125;&gt;        // ......        )    &#125;);   componentDidMount() &#123;       _this = this;   &#125;    _reload() &#123;        console.log(&quot;aaaaaaa&quot;);    &#125;</code></pre><h2 id="navigation-1"><a href="#navigation-1" class="headerlink" title="navigation"></a>navigation</h2><blockquote><p>应用中的每个页面组件都会自动提供 navigation prop， 该 prop 包含便捷的方法用于触发导航操作， 如下所示:</p></blockquote><ul><li>navigate -转到另一个屏幕, 计算出需要执行的操作</li><li>goBack -关闭活动屏幕并在堆栈中向后移动</li><li>addListener -订阅导航生命周期的更新</li><li>isFocused -函数返回 true 如果屏幕焦点和 false 否则。</li><li>state -当前状态/路由</li><li>setParams -对路由的参数进行更改</li><li>getParam -获取具有回退的特定参数</li><li>dispatch - 向路由发送 action</li><li>dangerouslyGetParent - 返回父级 navigator 的函数</li></ul><p>重要的是要强调 navigation prop 不传递给所有组件; 只有 screen 组件会自动收到此 prop。</p><h3 id="Navigator-dependent-functions"><a href="#Navigator-dependent-functions" class="headerlink" title="Navigator-dependent functions"></a>Navigator-dependent functions</h3><p>this.props.navigation 上有一些取决于当前 navigator 的附加函数</p><p>如果是 StackNavigator，除了 navigate 和 goBack ，还提供了如下方法：</p><ul><li>push - 推一个新的路由到堆栈</li><li>pop - 返回堆栈中的上一个页面</li><li>popToTop - 跳转到堆栈中最顶层的页面</li><li>replace - 用新路由替换当前路由</li><li>reset 操作会擦除整个导航状态，并将其替换为多个操作的结果。</li><li>dismiss - 关闭当前堆栈</li></ul><p>如果是 DrawerNavigator, 则还可以使用以下选项:</p><ul><li>openDrawer - 打开</li><li>closeDrawer - 关闭</li><li>toggleDrawer - 切换，如果是打开则关闭，反之亦然</li></ul><h3 id="通用-API-参考"><a href="#通用-API-参考" class="headerlink" title="通用 API 参考"></a>通用 API 参考</h3><p>与 navigation 到大部分操作都涉及到 navigate、goBack、state 、 setParams 和 getParams。</p><h4 id="navigate-链接到其它页面"><a href="#navigate-链接到其它页面" class="headerlink" title="navigate - 链接到其它页面"></a>navigate - 链接到其它页面</h4><p>调用此方法可跳转到应用程序中的另一个页面. 可采用以下参数:</p><pre><code class="js">navigation.navigate(&#123; routeName, params, action, key &#125;);</code></pre><p>或者</p><pre><code class="js">navigation.navigate(routeName, params, action);</code></pre><ul><li>routeName - 已在应用程序路由器中某处注册的目标 routeName</li><li>params - 合并到目标路由的参数</li><li>action -如果页面是 navigator，则是子路由中运行的子操作，有关支持的操作的完整列表，请参见 Actions Doc</li><li>key - 要导航到的路由的可选标识符。 如果已存在，将后退到此路由</li></ul><pre><code class="js">class HomeScreen extends React.Component &#123;  render() &#123;    const &#123; navigate &#125; = this.props.navigation;    return (      &lt;View&gt;        &lt;Text&gt;This is the home screen of the app&lt;/Text&gt;        &lt;Button          onPress=&#123;() =&gt; navigate(&quot;Profile&quot;, &#123; name: &quot;Brent&quot; &#125;)&#125;          title=&quot;Go to Brent&#39;s profile&quot;        /&gt;      &lt;/View&gt;    );  &#125;&#125;</code></pre><h4 id="goBack-关闭当前页面并返回上一个页面"><a href="#goBack-关闭当前页面并返回上一个页面" class="headerlink" title="goBack - 关闭当前页面并返回上一个页面"></a>goBack - 关闭当前页面并返回上一个页面</h4><p>可以选择提供一个 key, 指定要返回的路由。 默认情况下, goBack 将关闭调用该方法的页面 如果目标是在任何位置返回 <code>*</code>, 而不指定要关闭的内容, 请调用 <code>.goBack(null);</code> 注意, null 参数在嵌套 StackNavigators 的情况下很有用 如果子导航器在堆栈中已经只有一个项目, 则返回父导航器。</p><pre><code class="js">class HomeScreen extends React.Component &#123;  render() &#123;    const &#123; goBack &#125; = this.props.navigation;    return (      &lt;View&gt;        &lt;Button onPress=&#123;() =&gt; goBack()&#125; title=&quot;Go back from this HomeScreen&quot; /&gt;        &lt;Button onPress=&#123;() =&gt; goBack(null)&#125; title=&quot;Go back anywhere&quot; /&gt;        &lt;Button          onPress=&#123;() =&gt; goBack(&quot;screen-123&quot;)&#125;          title=&quot;Go back from screen-123&quot;        /&gt;      &lt;/View&gt;    );  &#125;&#125;</code></pre><p>使用 goBack 从一个指定的页面返回</p><p>请记住以下导航堆栈历史记录：</p><pre><code class="js">navigation.navigate(SCREEN_KEY_A);navigation.navigate(SCREEN_KEY_B);navigation.navigate(SCREEN_KEY_C);navigation.navigate(SCREEN_KEY_D);</code></pre><p>现在你在 <code>* screen D</code> 上，并且想要回到 <code>screen A *</code>（销毁 D、C 和 B）。 然后你需要提供一个 <code>goBack * FROM *</code> 的 key：</p><pre><code class="js">navigation.goBack(SCREEN_KEY_B); // 将从 screen B 跳转到 screen A</code></pre><p>如果，<code>* screen A *</code> 在堆栈的顶部, 你可以使用 navigation.popToTop()方法。</p><h4 id="addListener-订阅导航生命周期的更新"><a href="#addListener-订阅导航生命周期的更新" class="headerlink" title="addListener - 订阅导航生命周期的更新"></a>addListener - 订阅导航生命周期的更新</h4><p>React Navigation 将事件发送到订阅了它们的页面组件：</p><ul><li>willFocus -页面将获取焦点</li><li>didFocus - 页面已获取到焦点（如果有过渡动画，等过渡动画执行完成后响应）</li><li>willBlur - 页面将失去焦点</li><li>didFocus - 页面已获取到焦点（如果有过渡动画，等过渡动画执行完成后响应）</li></ul><pre><code class="js">const didBlurSubscription = this.props.navigation.addListener(  &quot;didBlur&quot;,  (payload) =&gt; &#123;    console.debug(&quot;didBlur&quot;, payload);  &#125;);// Remove the listener when you are donedidBlurSubscription.remove();</code></pre><p>JSON 格式的参数:</p><pre><code class="js">&#123;  action: &#123; type: &#39;Navigation/COMPLETE_TRANSITION&#39;, key: &#39;StackRouterRoot&#39; &#125;,  context: &#39;id-1518521010538-2:Navigation/COMPLETE_TRANSITION_Root&#39;,  lastState: undefined,  state: undefined,  type: &#39;didBlur&#39;,&#125;;</code></pre><p>你也可以用 <NavigationEvents/>组件 以声明的方式订阅导航事件。</p><h4 id="isFocused-查询页面是否获取到焦点"><a href="#isFocused-查询页面是否获取到焦点" class="headerlink" title="isFocused - 查询页面是否获取到焦点"></a>isFocused - 查询页面是否获取到焦点</h4><p>如果页面已获取到焦点，则返回 true 否则返回 false。</p><pre><code class="js">let isFocused = this.props.navigation.isFocused();</code></pre><p>您可能希望使用 withNavigationFocus 而不是直接使用此方法, 它将传入一个布尔型的 prop – isFocused 到你的组件。</p><h4 id="state-当前的-state-或-route"><a href="#state-当前的-state-或-route" class="headerlink" title="state - 当前的 state 或 route"></a>state - 当前的 state 或 route</h4><p>页面可以通过 this.props.navigation.state 访问其路由。每一个都将返回一个对象, 其内容如下:</p><pre><code class="js">&#123;  // the name of the route config in the router  routeName: &#39;profile&#39;,  //a unique identifier used to sort routes  key: &#39;main0&#39;,  //an optional object of string options for this screen  params: &#123; hello: &#39;world&#39; &#125;&#125;</code></pre><p>通过 <code>navigate</code> 或 <code>setParams</code> 方法传入参数。是获取页面参数最常用的方法。</p><pre><code class="js">class ProfileScreen extends React.Component &#123;  render() &#123;    return Name: &#123;this.props.navigation.state.params.name&#125;;  &#125;&#125;</code></pre><h4 id="setParams-对路由的参数进行更改"><a href="#setParams-对路由的参数进行更改" class="headerlink" title="setParams - 对路由的参数进行更改"></a>setParams - 对路由的参数进行更改</h4><p>触发<code>setParams</code>方法允许页面更改路由中的参数，这对于更新标题按钮和标题文本很有用。 <code>setParams</code> 就像 React 的 setState -他会将原来的参数与现在的参数合并</p><pre><code class="js">class ProfileScreen extends React.Component &#123;  render() &#123;    return (      &lt;Button        onPress=&#123;() =&gt; this.props.navigation.setParams(&#123; name: &quot;Lucy&quot; &#125;)&#125;        title=&quot;Set title name to &#39;Lucy&#39;&quot;      /&gt;    );  &#125;&#125;</code></pre><h4 id="getParam-获取指定的的参数，可设置获取失败的返回值"><a href="#getParam-获取指定的的参数，可设置获取失败的返回值" class="headerlink" title="getParam - 获取指定的的参数，可设置获取失败的返回值"></a>getParam - 获取指定的的参数，可设置获取失败的返回值</h4><p>过去, 当 params 未定义时, 你可能在获取 params 时遇到问题。 现在，你不必直接访问参数，可以调用 getParam 方法。</p><p>之前：</p><pre><code class="js">const &#123; name &#125; = this.props.navigation.state.params;</code></pre><p>如果 params 未定义, 则此操作失败</p><p>现在：</p><pre><code class="js">const name = this.props.navigation.getParam(&quot;name&quot;, &quot;Peter&quot;);</code></pre><p>如果 name 或 param 未定义, 则返回 Peter。</p><h3 id="Stack-Actions"><a href="#Stack-Actions" class="headerlink" title="Stack Actions"></a>Stack Actions</h3><p>下列操作将在所有 stack navigator 中起作用：</p><ul><li>Push</li></ul><p>类似于 navigate, push 将跳转到堆栈中的新的路由 与 navigate 的区别在于，如果有已经加载的页面，navigate 方法将跳转到已经加载的页面，而不会重新创建一个新的页面。 push 总是会创建一个新的页面，所以一个页面可以被多次创建</p><pre><code class="js">navigation.push(routeName, params, action);</code></pre><ul><li>routeName - 已在应用程序路由器中某处注册的目标 routeName</li><li>params - 合并到目标路由的参数</li><li>action -如果页面是 navigator，则是子路由中运行的子操作，有关支持的操作的完整列表</li><li>Pop - 返回到堆栈中的上一个页面，如果提供一个参数 n，则指定在堆栈内返回几层。</li></ul><pre><code class="js">navigation.pop(n);</code></pre><ul><li>PopToTop</li></ul><p>调用该方法将直接跳转到堆栈最顶层的路由，销毁其它所有页面。</p><p>navigation.popToTop()</p><ul><li>Replace</li></ul><p>调用该方法将使用指定的路由覆盖当前的页面，可以附带参数（params 和 sub-action）</p><p>navigation.replace(routeName, params, action)</p><ul><li>Reset</li></ul><p>操作会擦除整个导航状态，并将其替换为多个操作的结果。</p><p>navigation.reset([NavigationActions.navigate({ routeName: ‘Profile’ })], 0)</p><ul><li>Dismiss</li></ul><p>如果你想关闭整个 stack 回到父级 stack 中，调用这个方法</p><p>navigation.dismiss()</p><p>虽然 dispatch 方法并不常用，但是当使用 navigate 和 goBack 无法满足要求时，该方法会是个不错的选择。</p><ul><li>dispatch - 向路由发送 action</li></ul><p>使用 dispatch 将任何导航操作发送到路由后，该操作都将具有最高优先级。</p><p>请注意，如果您想分发 react-navigation 操作，则应使用此库中提供的操作创建者。</p><pre><code class="js">import &#123; NavigationActions &#125; from &quot;react-navigation&quot;;const navigateAction = NavigationActions.navigate(&#123;  routeName: &quot;Profile&quot;,  params: &#123;&#125;,  // navigate can have a nested navigate action that will be run inside the child router  action: NavigationActions.navigate(&#123; routeName: &quot;SubProfileRoute&quot; &#125;),&#125;);this.props.navigation.dispatch(navigateAction);</code></pre><ul><li>dangerouslyGetParent - get parent navigator</li></ul><p>例如，如果您有一个可以在多个导航器中显示的屏幕组件，则可以使用此组件根据其所在的导航器来影响其行为。</p><p>另一个很好的用例是在父路由列表中查找活动路由的索引。 因此，如果您在索引 0 处于堆栈的情况下，那么您可能不想渲染后退按钮，但如果您在列表中的其他位置，那么您将渲染后退按钮。</p><p>请务必始终检查调用是否返回有效值。</p><pre><code class="js">class UserCreateScreen extends Component &#123;  static navigationOptions = (&#123; navigation &#125;) =&gt; &#123;    const parent = navigation.dangerouslyGetParent();    const gesturesEnabled =      parent &amp;&amp;      parent.state &amp;&amp;      parent.state.routeName === &quot;StackWithEnabledGestures&quot;;    return &#123;      title: &quot;New User&quot;,      gesturesEnabled,    &#125;;  &#125;;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReactNative之样式手册</title>
      <link href="/2018-05/reactnative%E4%B9%8B%E6%A0%B7%E5%BC%8F%E6%89%8B%E5%86%8C/"/>
      <url>/2018-05/reactnative%E4%B9%8B%E6%A0%B7%E5%BC%8F%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<p>在 React Native 中，你并不需要学习什么特殊的语法来定义样式。我们仍然是使用 JavaScript 来写样式。所有的核心组件都接受名为 style 的属性。这些样式名基本上是遵循了 web 上的 CSS 的命名，只是按照 JS 的语法要求使用了驼峰命名法，例如将 background-color 改为 backgroundColor。以下备忘一下，常用的样式和用法说明。</p><span id="more"></span><h2 id="Properties-属性"><a href="#Properties-属性" class="headerlink" title="Properties 属性"></a>Properties 属性</h2><h3 id="Text-文本"><a href="#Text-文本" class="headerlink" title="Text 文本"></a>Text 文本</h3><table><thead><tr><th>属性名</th><th>取值</th><th>描述</th></tr></thead><tbody><tr><td>color</td><td><code>&lt;color&gt;</code></td><td>对应 CSS 中的 color 属性</td></tr><tr><td>fontFamily</td><td>string</td><td>对应 CSS 中的 font-family 属性</td></tr><tr><td>fontSize</td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 font-size 属性</td></tr><tr><td>fontStyle</td><td>normal, italic</td><td>对应 CSS 中的 font-style 属性，但阉割了 oblique 取值</td></tr><tr><td>fontWeight</td><td>normal, bold 100~900</td><td>对应 CSS 中的 font-weight 属性，但阉割了 bolder, lighter 取值</td></tr><tr><td>lineHeight</td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 line-height 属性</td></tr><tr><td>textAlign</td><td>auto, left, right, center, justify<code>iOS</code></td><td>对应 CSS 中的 text-align 属性，增加了 auto 取值</td></tr><tr><td>textAlignVertical<code>Android</code></td><td>auto, top, bottom, center</td><td>对应 CSS 中的 vertical-align 属性，增加了 auto 取值，center 取代了 middle，并阉割了 baseline, sub 等值</td></tr><tr><td>textShadowColor</td><td><code>&lt;color&gt;</code></td><td>对应 CSS 中的 text-shadow 属性中的颜色定义</td></tr><tr><td>textShadowOffset</td><td>{ width: <code>&lt;number&gt;</code>, height: <code>&lt;number&gt;</code> }</td><td>对应 CSS 中的 text-shadow 属性中的阴影偏移定义</td></tr><tr><td>textShadowRadius</td><td><code>&lt;number&gt;</code></td><td>在 CSS 中，阴影的圆角大小取决于元素的圆角定义，不需要额外定义</td></tr><tr><td>letterSpacing<code>iOS</code></td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 letter-spacing 属性，但取值不同</td></tr><tr><td>textDecorationColor<code>iOS</code></td><td><code>&lt;color&gt;</code></td><td>对应 CSS 中的 text-decoration-color 属性</td></tr><tr><td>textDecorationLine<code>iOS</code></td><td>none, underline, line-through, underline line-through</td><td>对应 CSS 中的 text-decoration-line 属性，但阉割了 overline, blink 取值</td></tr><tr><td>textDecorationStyle<code>iOS</code></td><td>solid, double, dotted, dashed</td><td>对应 CSS 中的 text-decoration-style 属性，但阉割了 wavy 取值</td></tr><tr><td>writingDirection<code>iOS</code></td><td>auto, ltr, rtl</td><td>对应 CSS 中的 direction 属性，增加了 auto 取值</td></tr></tbody></table><h3 id="Dimension-尺寸"><a href="#Dimension-尺寸" class="headerlink" title="Dimension 尺寸"></a>Dimension 尺寸</h3><table><thead><tr><th>属性名</th><th>取值</th><th>描述</th></tr></thead><tbody><tr><td>width</td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 width 属性</td></tr><tr><td>height</td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 height 属性</td></tr></tbody></table><h3 id="Positioning-定位"><a href="#Positioning-定位" class="headerlink" title="Positioning 定位"></a>Positioning 定位</h3><table><thead><tr><th>属性名</th><th>取值</th><th>描述</th></tr></thead><tbody><tr><td>position</td><td>absolute, relative</td><td>对应 CSS 中的 position 属性，但阉割了 static, fixed 取值</td></tr><tr><td>top</td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 top 属性</td></tr><tr><td>right</td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 right 属性</td></tr><tr><td>bottom</td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 bottom 属性</td></tr><tr><td>left</td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 left 属性</td></tr><tr><td>zIndex</td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 z-index 属性</td></tr></tbody></table><h3 id="Margin-外部白"><a href="#Margin-外部白" class="headerlink" title="Margin 外部白"></a>Margin 外部白</h3><table><thead><tr><th>属性名</th><th>取值</th><th>描述</th></tr></thead><tbody><tr><td>margin</td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 margin 属性，不同的是，只能定义一个参数，用以表示上、右、下、左 4 个方位的外补白</td></tr><tr><td>marginHorizontal</td><td><code>&lt;number&gt;</code></td><td>CSS 中没有对应的属性，相当于同时设置 marginRight 和 marginLeft</td></tr><tr><td>marginVertical</td><td><code>&lt;number&gt;</code></td><td>CSS 中没有对应的属性，相当于同时设置 marginTop 和 marginBottom</td></tr><tr><td>marginTop</td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 margin-top 属性</td></tr><tr><td>marginRight</td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 margin-right 属性</td></tr><tr><td>marginBottom</td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 margin-bottom 属性</td></tr><tr><td>marginLeft</td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 margin-left 属性</td></tr></tbody></table><h3 id="Padding-内部白"><a href="#Padding-内部白" class="headerlink" title="Padding 内部白"></a>Padding 内部白</h3><table><thead><tr><th>属性名</th><th>取值</th><th>描述</th></tr></thead><tbody><tr><td>padding</td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 padding 属性，不同的是，只能定义一个参数，用以表示上、右、下、左 4 个方位的内补白</td></tr><tr><td>paddingHorizontal</td><td><code>&lt;number&gt;</code></td><td>CSS 中没有对应的属性，相当于同时设置 paddingRight 和 paddingLeft</td></tr><tr><td>paddingVertical</td><td><code>&lt;number&gt;</code></td><td>CSS 中没有对应的属性，相当于同时设置 paddingTop 和 paddingBottom</td></tr><tr><td>paddingTop</td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 padding-top 属性</td></tr><tr><td>paddingRight</td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 padding-right 属性</td></tr><tr><td>paddingBottom</td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 padding-bottom 属性</td></tr><tr><td>paddingLeft</td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 padding-left 属性</td></tr></tbody></table><h3 id="Border-边框"><a href="#Border-边框" class="headerlink" title="Border 边框"></a>Border 边框</h3><table><thead><tr><th>属性名</th><th>取值</th><th>描述</th></tr></thead><tbody><tr><td>borderStyle</td><td>solid, dotted, dashed</td><td>对应 CSS 中的 border-style 属性，但阉割了 none, hidden, double, groove, ridge, inset, outset 取值，且无方向分拆属性</td></tr><tr><td>borderWidth</td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 border-width 属性</td></tr><tr><td>borderTopWidth</td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 border-top-width 属性</td></tr><tr><td>borderRightWidth</td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 border-right-width 属性</td></tr><tr><td>borderBottomWidth</td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 border-bottom-width 属性</td></tr><tr><td>borderLeftWidth</td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 border-left-width 属性</td></tr><tr><td>borderColor</td><td><code>&lt;color&gt;</code></td><td>对应 CSS 中的 border-color 属性</td></tr><tr><td>borderTopColor</td><td><code>&lt;color&gt;</code></td><td>对应 CSS 中的 border-top-color 属性</td></tr><tr><td>borderRightColor</td><td><code>&lt;color&gt;</code></td><td>对应 CSS 中的 border-right-color 属性</td></tr><tr><td>borderBottomColor</td><td><code>&lt;color&gt;</code></td><td>对应 CSS 中的 border-bottom-color 属性</td></tr><tr><td>borderLeftColor</td><td><code>&lt;color&gt;</code></td><td>对应 CSS 中的 border-left-color 属性</td></tr><tr><td>borderRadius</td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 border-radius 属性</td></tr><tr><td>borderTopLeftRadius</td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 border-top-left-radius 属性</td></tr><tr><td>borderTopRightRadius</td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 border-top-right-radius 属性</td></tr><tr><td>borderBottomLeftRadius</td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 border-bottom-left-radius 属性</td></tr><tr><td>borderBottomRightRadius</td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 border-bottom-right-radius 属性</td></tr><tr><td>shadowColor</td><td><code>&lt;color&gt;</code></td><td>对应 CSS 中的 box-shadow 属性中的颜色定义</td></tr><tr><td>shadowOffset</td><td>{ width: <code>&lt;number&gt;</code>, height: <code>&lt;number&gt;</code> }</td><td>对应 CSS 中的 box-shadow 属性中的阴影偏移定义</td></tr><tr><td>shadowRadius</td><td><code>&lt;number&gt;</code></td><td>在 CSS 中，阴影的圆角大小取决于元素的圆角定义，不需要额外定义</td></tr><tr><td>shadowOpacity</td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 box-shadow 属性中的阴影透明度定义</td></tr></tbody></table><h3 id="Background-背景"><a href="#Background-背景" class="headerlink" title="Background 背景"></a>Background 背景</h3><table><thead><tr><th>属性名</th><th>取值</th><th>描述</th></tr></thead><tbody><tr><td>backgroundColor</td><td><code>&lt;color&gt;</code></td><td>对应 CSS 中的 background-color 属性</td></tr></tbody></table><h3 id="Transform-转换"><a href="#Transform-转换" class="headerlink" title="Transform 转换"></a>Transform 转换</h3><table><thead><tr><th>属性名</th><th>取值</th><th>描述</th></tr></thead><tbody><tr><td>transform</td><td>[{perspective: number}, {rotate: string}, {rotateX: string}, {rotateY: string}, {rotateZ: string}, {scale: number}, {scaleX: number}, {scaleY: number}, {translateX: number}, {translateY: number}, {skewX: string}, {skewY: string}]</td><td>对应 CSS 中的 transform 属性</td></tr><tr><td>transformMatrix</td><td>TransformMatrixPropType</td><td>类似于 CSS 中 transform 属性的 matrix() 和 matrix3d() 函数</td></tr><tr><td>backfaceVisibility</td><td>visible, hidden</td><td>对应 CSS 中的 backface-visibility 属性</td></tr></tbody></table><h3 id="Flexbox-弹性盒"><a href="#Flexbox-弹性盒" class="headerlink" title="Flexbox 弹性盒"></a>Flexbox 弹性盒</h3><table><thead><tr><th>属性名</th><th>取值</th><th>描述</th></tr></thead><tbody><tr><td>flex</td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 flex 属性</td></tr><tr><td>flexDirection</td><td>row, column</td><td>对应 CSS 中的 flex-direction 属性，但阉割了 row-reverse, column-reverse 取值，默认值是 column 而不是 row</td></tr><tr><td>flexWrap</td><td>wrap, nowrap</td><td>对应 CSS 中的 flex-wrap 属性，但阉割了 wrap-reverse 取值</td></tr><tr><td>justifyContent</td><td>flex-start, flex-end, center, space-between, space-around</td><td>对应 CSS 中的 justify-content 属性，但阉割了 stretch 取值。</td></tr><tr><td>alignItems</td><td>flex-start, flex-end, center, stretch</td><td>对应 CSS 中的 align-items 属性，但阉割了 baseline 取值，默认值是 stretch 而不是 flex-start，stretch 只有在不设置尺寸的时候才生效</td></tr><tr><td>alignSelf</td><td>auto, flex-start, flex-end, center, stretch</td><td>对应 CSS 中的 align-self 属性，但阉割了 baseline 取值</td></tr></tbody></table><h3 id="Other-其他"><a href="#Other-其他" class="headerlink" title="Other 其他"></a>Other 其他</h3><table><thead><tr><th>属性名</th><th>取值</th><th>描述</th></tr></thead><tbody><tr><td>opacity</td><td><code>&lt;number&gt;</code></td><td>对应 CSS 中的 opacity 属性</td></tr><tr><td>overflow</td><td>visible, hidden</td><td>对应 CSS 中的 overflow 属性，但阉割了 scroll, auto 取值</td></tr><tr><td>elevation<code>Android</code></td><td><code>&lt;number&gt;</code></td><td>CSS 中没有对应的属性，只在 Android5.0+ 上有效</td></tr><tr><td>resizeMode</td><td>cover, contain, stretch</td><td>CSS 中没有对应的属性，可以参考 background-size 属性</td></tr><tr><td>overlayColor<code>Android</code></td><td>string</td><td>CSS 中没有对应的属性，当图像有圆角时，将角落都充满一种颜色</td></tr><tr><td>tintColor<code>iOS</code></td><td><code>&lt;color&gt;</code></td><td>CSS 中没有对应的属性，iOS 图像上特殊的色彩，改变不透明像素的颜色</td></tr></tbody></table><h2 id="Valuse-取值"><a href="#Valuse-取值" class="headerlink" title="Valuse 取值"></a>Valuse 取值</h2><h3 id="Color-颜色"><a href="#Color-颜色" class="headerlink" title="Color 颜色"></a>Color 颜色</h3><p>React-Native 支持了 CSS 中大部分的颜色类型：</p><ul><li><code>#f00 (#rgb)</code></li><li><code>#f00c (#rgba)：CSS 中无对应的值</code></li><li><code>#ff0000 (#rrggbb)</code></li><li><code>#ff0000cc (#rrggbbaa)：CSS 中无对应的值</code></li><li><code>rgb(255, 0, 0)</code></li><li><code>rgba(255, 0, 0, 0.9)</code></li><li><code>hsl(360, 100%, 100%)</code></li><li><code>hsla(360, 100%, 100%, 0.9)</code></li><li><code>transparent</code></li><li><code>Color Name</code>：支持了基本颜色关键字和拓展颜色关键字，但不支持 28 个系统颜色</li></ul><h3 id="Number-数值"><a href="#Number-数值" class="headerlink" title="Number 数值"></a>Number 数值</h3><p>在 React-Native 中，目前仅支持 Number 这一种长度取值。默认缺省了 pt 单位</p><h2 id="UI-自适应问题"><a href="#UI-自适应问题" class="headerlink" title="UI 自适应问题"></a>UI 自适应问题</h2><p>在 React-Native 中，支持百分比单位和无单位的方式，无单位即 pt 绝对长度单位，例如：</p><pre><code class="js">&lt;View style=&#123;&#123; width: 100, height: 50 &#125;&#125;&gt;&lt;/View&gt;;var styles = StyleSheet.create(&#123;  box: &#123;    width: 100,    height: 50,  &#125;,&#125;);</code></pre><p>未达到不同设备的 UI 自适应目的，我们通过等比缩放 UI 的尺寸大小，来实现不同设备的 UI 兼容问题：</p><pre><code class="js">const UiBaseWidth = 750; // 以iphone6为例等比缩放const px2dp = (UiPx) =&gt;  Math.floor(((UiPx * screenWidth) / UiBaseWidth) * 10) / 10; // 根据设计稿转换，向下取整保留一位小数</code></pre><h2 id="踩坑！！！"><a href="#踩坑！！！" class="headerlink" title=" 踩坑！！！"></a> 踩坑！！！</h2><h3 id="1-文字垂直居中-lineHeight-设置的数值实际上会离奇的多出-0-667"><a href="#1-文字垂直居中-lineHeight-设置的数值实际上会离奇的多出-0-667" class="headerlink" title="1. 文字垂直居中(lineHeight 设置的数值实际上会离奇的多出 0.667)"></a>1. 文字垂直居中(lineHeight 设置的数值实际上会离奇的多出 0.667)</h3><p>想要如下图的效果：</p><p><img src="http://cdn.chuyunt.com/lineHeight1.png" alt="lineHeight1"></p><p>想法：使用<code>lineHeight</code>实现</p><p>设置外部容器<code>height: 36</code></p><p><img src="http://cdn.chuyunt.com/lineHeight2.png" alt="lineHeight2"></p><p>想让中间字体垂直居中，扣去上下两个边框的宽度，应该设置<code>lineHeight: 34</code></p><p><img src="http://cdn.chuyunt.com/lineHeight3.png" alt="lineHeight3"></p><p> 发现底部的边框明显少了一部分，查看元素发现一个 bug：</p><p><img src="http://cdn.chuyunt.com/lineHeight4.png" alt="lineHeight4"></p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><blockquote><ol><li>如果不设置 lineHeight，Text 元素的高度也是 <code>fontSize + 0.667</code></li><li>最好的文字垂直居中方式：Text 外再包一层 View，在 View 上用<code>flex</code>布局。如下图所示：<br><img src="http://cdn.chuyunt.com/lineHeight5.png" alt="lineHeight5"></li></ol></blockquote><h3 id="2-zIndex-调整层级无效-绝对定位的同级元素"><a href="#2-zIndex-调整层级无效-绝对定位的同级元素" class="headerlink" title="2. zIndex 调整层级无效(绝对定位的同级元素)"></a>2. zIndex 调整层级无效(绝对定位的同级元素)</h3><p>实际在使用 zIndex 属性的时候发现根本没有效果，跟 web 的 z-index 所呈现的效果完全不一样</p><p>解决方法：</p><p>改变元素的顺序，而不使用 zIndex。默认情况下，使用了<code>position: &#39;absolute&#39;</code>后，在后面的元素会覆盖在前面的元素之上</p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5之离线缓存</title>
      <link href="/2018-05/html5%E4%B9%8B%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98/"/>
      <url>/2018-05/html5%E4%B9%8B%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>乐刻教练端业务是一个 Hybrid APP，通过原生 APP 提供调用原生能力的外壳，内部逻辑全部使用 H5 页面实现。 这种方式在早期产品需求快速迭代，客户端资源紧张的情况下，解决了很大一部分问题。但随着业务需要和使用人数的增加，教练端已经有点力不从心的。在 3 月份，已经对教练端进行过一次优化，主要集中在资源加载、初始数据、转场动画等。接下来，想要结合 HTML5 离线缓存机制，进行一些优化尝试。</p><span id="more"></span><h2 id="HTML5-离线缓存"><a href="#HTML5-离线缓存" class="headerlink" title="HTML5 离线缓存"></a>HTML5 离线缓存</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>HTML5 的新增了很多浏览器本地存储的技术，Application Cache（简称 AppCache）使得基于 web 的应用程序可以离线运行，似乎是为支持 Web App 离线使用而开发的缓存机制。它的缓存机制类似于浏览器的缓存（Cache-Control 和 Last-Modified）机制，都是以文件为单位进行缓存，且文件有一定更新机制。但 AppCache 是对浏览器缓存机制的补充，不是替代。</p><h3 id="有什么用"><a href="#有什么用" class="headerlink" title="有什么用"></a>有什么用</h3><ul><li>离线浏览: 用户可以在离线状态下浏览网站内容。</li><li>更快的速度: 因为数据被存储在本地，所以速度会更快。</li><li>减轻服务器的负载: 浏览器只会下载在服务器上发生改变的资源。</li></ul><h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><blockquote><p>通过在站点根目录维护一个 manifest 文件，在需要缓存的 html 页面中引入这个文件。manifest 相当于一个配置文件，配置需要缓存的文件等规则，下面会详细列出。</p></blockquote><p>假如在根目录下新建一个名为 manifest.appcache 的文件（该文件名和后缀名可以自定义），配置内容如下：</p><pre><code>CACHE MANIFEST# version 1.0.0  以 # 声明注释，浏览器根据manifest文件变化来检测是否需要重新加载新文件。# 注释：需要缓存的文件，无论在线与否，均从缓存里读取/images/cached.png/css/cached.css/js/cached.js# 需要特殊声明的缓存文件，也可以都在这里声明CACHE:/css/otherCached.css/js/otherCached.js# 注释：不缓存的文件，无论缓存中存在与否，均从新获取(如果与上面的缓存内容重复，依旧会缓存)NETWORK:*# 注释：获取不到资源时的备选路径，如index.html访问失败，则返回404页面FALLBACK:index.html 404.html</code></pre><pre><code>  1、CACHE MANIFEST — 文件开头第一行必须声明 CACHE MANIFEST 字段标识，然后紧接着声明需要缓存的文件路径，作用是标识出哪些文件需要缓存，可以是相对路径也可以是绝对路径；  2、# — #号开头的是注释，一般会在第二行写个版本号，用来在缓存的文件更新时，更改manifest的作用，可以是版本号，时间戳或者md5码等等；  3、CACHE — 我们也可以在CACHE下面声明需要缓存的资源路径；  4、NETWORK可选，这一部分是要直接读取的文件，可以使用通配符 * ；  5、FALLBACK可选，指定了一个后备页面，当资源无法访问时，浏览器会使用该页面。</code></pre><p>接下来只需要在 html 文件上，引入该配置文件即可</p><p>在文档的 <code>&lt;html&gt;</code> 标签中添加 manifest 属性，将 manifest.appcache 文件引入:</p><pre><code class="html">&lt;html manifest=&quot;manifest.appcache&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;meta      name=&quot;viewport&quot;      content=&quot;width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;    /&gt;    &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt;    &lt;title&gt;乐刻教练&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><blockquote><p>这样浏览器在读取 HTML 页面时会将 manifest.appcache 中声明的资源下载并进行离线存储，下次请求直接使用离线存储中的资源，HTTP 请求表现为：200 (from disk cache)</p></blockquote><p><strong>注意：</strong></p><p>一般情况下，manifest 文件需要在 web 服务器上配置正确的 MIME-type，即 “text/cache-manifest”，才能正常的被浏览器正常请求。</p><ul><li>webpack 自动化配置</li></ul><p>在使用 webpack 自动化构建的项目中，我们可以利用<a target="_blank" rel="noopener" href="https://github.com/lettertwo/appcache-webpack-plugin">appcache-webpack-plugin</a>这个插件轻松生成 manifest 文件，并将打包的资源路径更新到 manifest 文件中，配置如下</p><pre><code class="js">const AppCachePlugin = require(&quot;appcache-webpack-plugin&quot;);plugins: [  new AppCachePlugin(&#123;    cache: [&quot;otherAsset.png&quot;],    network: [&quot;*&quot;], // 除了声明的缓存资源其他都通过网络访问    fallback: [&quot;index.html&quot;, &quot;error.html&quot;],    settings: [&quot;prefer-online&quot;],    exclude: [&quot;file.txt&quot;, /.*\.html$/], // Exclude file.txt and all .html files    output: &quot;/manifest.appcache&quot;,  &#125;),];</code></pre><h3 id="什么效果"><a href="#什么效果" class="headerlink" title="什么效果"></a>什么效果</h3><p>浏览器离线存储缓存机制示意图：</p><p><img src="http://cdn.chuyunt.com/uPic/1120909-20170616133714306-301385248.png"></p><ul><li>用户在初次访问网站时，浏览器读取到 HTML 上的 manifest 属性声明的 mainfest.appcache 文件，根据文件内的配置项下载相应的资源进行离线缓存。在 chrome 中可以看到，被缓存的资源。（浏览器在下载 manifest 中的文件时，会一次性下载所有的文件，一旦因为某些原因某一个资源下载失败，会导致所有的资源更新失败，浏览器继续适应旧的资源。）</li></ul><p><img src="http://cdn.chuyunt.com/uPic/006tNc79gy1frs1vkgf1cj31bi0pidr5.jpg"></p><ul><li><p>已经缓存离线存储后，用户再次访问网站，浏览器（无论在线与否）将会使用已缓存的资源加载页面，然后浏览器会对比新的 manifest 文件，如果文件发生变化，就重新下载文件中的资源进行离线，如果没有变化，就不做改变。</p></li><li><p>注意：</p><ul><li>站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。</li><li>浏览器下载完新的更新资源后并不会立即使用，需要刷新页面后才有效果，解决办法：</li></ul></li></ul><pre><code class="js">var appCache = window.applicationCache;appCache.onupdateready = function (e) &#123;  appCache.swapCache();  window.location.reload();&#125;;</code></pre><ul><li><p>离线情况下，浏览器直接访问离线资源</p></li><li><p>与传统浏览器缓存的区别</p><ul><li>离线缓存是针对整个应用，浏览器缓存是单个文件。</li><li>离线缓存断网了还是可以打开页面，浏览器缓存不行。</li><li>离线缓存可以通过代码主动通知浏览器更新资源。</li></ul></li><li><p>chrome 浏览器下通过访问 <a href="chrome://appcache-internals/">chrome://appcache-internals/</a> 可以查看缓存在本地的资源文件.</p></li></ul><h2 id="API-介绍"><a href="#API-介绍" class="headerlink" title="API 介绍"></a>API 介绍</h2><h3 id="applicationCache-对象"><a href="#applicationCache-对象" class="headerlink" title="applicationCache 对象"></a>applicationCache 对象</h3><p>该对象是 window 对象的直接子对象 window.applicationCache</p><p>基类：DOMApplicationCache</p><p>事件列表</p><table><thead><tr><th>事件</th><th>接口</th><th>触发条件</th><th>后续事件</th></tr></thead><tbody><tr><td>checking</td><td>Event</td><td>用户代理检查更新或者在第一次尝试下载 manifest 文件的时候，本事件往往是事件队列中第一个被触发的</td><td>noupdate, downloading, obsolete, error</td></tr><tr><td>noupdate</td><td>Event</td><td>检测出 manifest 文件没有更新</td><td>无</td></tr><tr><td>downloading</td><td>Event</td><td>用户代理发现更新并且正在取资源，或者第一次下载 manifest 文件列表中列举的资源</td><td>progress, error, cached, updateready</td></tr><tr><td>progress</td><td>ProgressEvent</td><td>用户代理正在下载资源 manifest 文件中的需要缓存的资源</td><td>progress, error, cached, updateready</td></tr><tr><td>cached</td><td>Event</td><td>manifest 中列举的资源已经下载完成，并且已经缓存</td><td>无</td></tr><tr><td>updateready</td><td>Event</td><td>manifest 中列举的文件已经重新下载并更新成功，接下来 js 可以使用 swapCache()方法更新到应用程序中</td><td>无</td></tr><tr><td>obsolete</td><td>Event</td><td>manifest 的请求出现 404 或者 410 错误，应用程序缓存被取消</td><td>无</td></tr></tbody></table><p>另外还有一个 error 事件，触发条件如下：</p><ul><li>manifest 的请求出现 404 或者 410 错误，更新缓存的请求失败；</li><li>无 manifest 文件没有改变，但是页面引用的 manifest 文件没有被正确地下载；</li><li>在取 manifest 列举的资源的过程中发生致命的错误；</li><li>在更新过程中 manifest 文件发生变化用户代理会尝试立即再次获取文件。</li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>status 属性返回缓存的状态</p><table><thead><tr><th>可选值</th><th>匹配常量</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>appCache.UNCACHED</td><td>未缓存</td></tr><tr><td>1</td><td>appCache.IDLE</td><td>闲置</td></tr><tr><td>2</td><td>appCache.CHECKING</td><td>检查中</td></tr><tr><td>3</td><td>appCache.DOWNLOADING</td><td>下载中</td></tr><tr><td>4</td><td>appCache.UPDATEREADY</td><td>已更新</td></tr><tr><td>5</td><td>appCache.OBSOLETE</td><td>失效</td></tr></tbody></table><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>update()</td><td>发起应用程序缓存下载进程</td></tr><tr><td>abort()</td><td>取消正在进行的缓存下载</td></tr><tr><td>swapcache()</td><td>切换成本地最新的缓存环境</td></tr></tbody></table><h2 id="支持程度"><a href="#支持程度" class="headerlink" title="支持程度"></a>支持程度</h2><p><img src="http://cdn.chuyunt.com/uPic/006tNc79gy1frs2pw7xmoj30ol071jsu.jpg"></p><p>不过在 H5 标准中, Offline Web applications 部分有如下描述:</p><p><code>This feature is in the process of being removed from the Web platform. (This is a long process that takes many years.) Using any of the offline Web application features at this time is highly discouraged. Use service workers instead. [SW]</code></p><p>因此后续我将在其他文章中继续介绍 service workers.</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ol><li>首次访问时会加载所有数据，如果缓存的数据很多的话，将拖慢加载速度（只使用一个 manifest 文件，缓存少量必要文件）</li><li>有时候会出现即使 manifest 文件改变后，应用还是不能及时更新（对于业务代码不使用 manifest 缓存，只缓存一些类库文件和不经常改变的文件）</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>在教练端 APP 上加载速率上没有明显变化，且在断网情况下 APP 有默认缺省图（在 chrome 浏览器上，加载速率提升明显）</li><li>H5 离线缓存机制 Manifest 将被废除，由 PWA 技术取代</li><li>网上有讨论：会出现更新代码后，页面无法更新问题（没有复现）</li><li>结合上述现象，决定不再继续深究此方案</li></ul>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript之数组的常用操作函数</title>
      <link href="/2018-04/javascript%E4%B9%8B%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0/"/>
      <url>/2018-04/javascript%E4%B9%8B%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>字符串的操作在js中非常繁琐，但也非常重要。在使用过程中，也会经常忘记，今天就对这个进行一下整理。</p><!--more--><h2 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串 String"></a>字符串 String</h2><p>String 对象用于处理文本（字符串）。</p><pre><code>new String(s); // 返回一个新创建的 String 对象，存放的是字符串 s 或 s 的字符串表示。String(s);     // 只把 s 转换成原始的字符串，并返回转换后的值。</code></pre><h3 id="String-属性"><a href="#String-属性" class="headerlink" title="String 属性"></a>String 属性</h3><ul><li>constructor 对创建该对象的函数的引用</li><li>length  字符串的长度</li><li>prototype   允许您向对象添加属性和方法<br>prototype在面向对象编程中会经常用到，用来给对象添加属性或方法，并且添加的方法或属性在所有的实例上共享。因此也常用来扩展js内置对象，如下面的代码给字符串添加了一个去除两边空格的方法：</li></ul><pre><code class="js">String.prototype.trim = function()&#123;    return this.replace(/^\s*|\s*$/g, &#39;&#39;);&#125;</code></pre><h3 id="String-函数"><a href="#String-函数" class="headerlink" title="String 函数"></a>String 函数</h3><h4 id="获取类函数"><a href="#获取类函数" class="headerlink" title="获取类函数"></a>获取类函数</h4><ul><li>charAt()</li></ul><pre><code class="js">StringObj.charAt()</code></pre><p>charAt()方法可用来获取指定位置的字符串，index为字符串索引值，从0开始到string.leng - 1，若不在这个范围将返回一个空字符串。如：</p><pre><code class="js">var str = &#39;qwertyuiop&#39;str.charAt(3)// &quot;r&quot;str.charAt(11)// &quot;&quot;</code></pre><ul><li>charCodeAt()</li></ul><p>charCodeAt()用于返回指定位置的Unicode 编码，于charAt()使用类似。</p><pre><code class="js">var str = &#39;qwertyuiop&#39;str.charCodeAt(3)// 114str.charCodeAt(11)// NaN</code></pre><ul><li>fromCharCode()</li></ul><p>fromCharCode()可接受一个或多个Unicode值，然后返回一个字符串。另外该方法是String 的静态方法，字符串中的每个字符都由单独的数字Unicode编码指定。</p><pre><code class="js">String.fromCharCode(99, 99, 100)// &quot;ccd&quot;</code></pre><h4 id="查找类函数"><a href="#查找类函数" class="headerlink" title="查找类函数"></a>查找类函数</h4><ul><li>indexOf()</li></ul><p>indexOf()用来检索指定的字符串值在字符串中首次出现的位置。它可以接收两个参数，searchvalue表示要查找的子字符串，fromindex表示查找的开始位置，省略的话则从开始位置进行检索。lastIndexOf()，从后向前搜索字符串。</p><pre><code class="js">var str = &#39;abcdabcd&#39;str.indexOf(&#39;a&#39;)// 0str.indexOf(&#39;s&#39;)// -1str.indexOf(&#39;a&#39;, 2)// 4</code></pre><ul><li>search()</li></ul><p>search()方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。它会返回第一个匹配的子字符串的起始位置，如果没有匹配的，则返回-1。</p><pre><code class="js">var str = &#39;abcdabcd&#39;str.search(&#39;b&#39;)// 1str.search(&#39;s&#39;)// -1str.search(/d/i)// 3</code></pre><ul><li>match()</li></ul><p>match()方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。</p><p>如果参数中传入的是子字符串或是没有进行全局匹配的正则表达式，那么match()方法会从开始位置执行一次匹配，如果没有匹配到结果，则返回null。否则则会返回一个数组，该数组的第0个元素存放的是匹配文本，除此之外，返回的数组还含有两个对象属性index和input，分别表示匹配文本的起始字符索引和stringObject 的引用(即原字符串)。</p><pre><code class="js">var str = &#39;qwer23tyqwer23ty&#39;str.match(&#39;ba&#39;)// nullstr.match(&#39;y&#39;)// [&quot;y&quot;, index: 7, input: &quot;qwer23tyqwer23ty&quot;, groups: undefined]str.match(/y/)// [&quot;y&quot;, index: 7, input: &quot;qwer23tyqwer23ty&quot;, groups: undefined]str.match(/y/g)  // 正则全局匹配// [&quot;y&quot;, &quot;y&quot;, &quot;y&quot;, &quot;y&quot;]</code></pre><p>如果参数传入的是具有全局匹配的正则表达式，那么match()从开始位置进行多次匹配，直到最后。如果没有匹配到结果，则返回null。否则则会返回一个数组，数组中存放所有符合要求的子字符串，并且没有index和input属性。</p><pre><code class="js">var str = &#39;qwer23tyqwer23ty&#39;str.match(/y/g)  // 正则全局匹配// [&quot;y&quot;, &quot;y&quot;, &quot;y&quot;, &quot;y&quot;]str.match(/\d/g) // 正则全局匹配// [&quot;2&quot;, &quot;3&quot;, &quot;2&quot;, &quot;3&quot;]</code></pre><h4 id="截取类函数"><a href="#截取类函数" class="headerlink" title="截取类函数"></a>截取类函数</h4><ul><li>substring</li></ul><p>substring()是最常用到的字符串截取方法，它可以接收两个参数(参数不能为负值)，分别是要截取的开始位置和结束位置，它将返回一个新的字符串，其内容是从start处到end-1处的所有字符。若结束参数(end)省略，则表示从start位置一直截取到最后。</p><pre><code class="js">var str = &#39;qazwsxedc&#39;str.substring(1,4)// &quot;azw&quot;str.substring(3)// &quot;wsxedc&quot;str.substring(-1, 4)// &quot;qazwsxedc&quot;</code></pre><ul><li>slice()</li></ul><p>slice()方法与substring()方法非常类似，它传入的两个参数也分别对应着开始位置和结束位置。而区别在于，slice()中的参数可以为负值，如果参数是负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1 指字符串的最后一个字符。</p><pre><code class="js">var str = &#39;qazwsxedc&#39;str.slice(1,4)// &quot;azw&quot;str.slice(-1)// &quot;c&quot;str.slice(3)// &quot;wsxedc&quot;</code></pre><ul><li>substr()</li></ul><p>substr()方法可在字符串中抽取从start下标开始的<code>指定数目</code>的字符。其返回值为一个字符串，包含从 stringObject的start（包括start所指的字符）处开始的length个字符。如果没有指定 length，那么返回的字符串包含从start到stringObject的结尾的字符。另外如果start为负数，则表示从字符串尾部开始算起。</p><pre><code class="js">var str = &#39;asdfghjkl&#39;str.substr(0, 4)// &quot;asdf&quot;str.substr(-1, 9)// &quot;l&quot;</code></pre><h4 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h4><ul><li>replace()</li></ul><p>replace()方法用来进行字符串替换操作，它可以接收两个参数，前者为被替换的子字符串（可以是正则），后者为用来替换的文本。</p><p>如果第一个参数传入的是子字符串或是没有进行全局匹配的正则表达式，那么replace()方法将只进行一次替换（即替换最前面的），返回经过一次替换后的结果字符串。</p><pre><code class="js">var str = &#39;abcdeabcde&#39;str.replace(&#39;a&#39;, &#39;A&#39;)// &quot;Abcdeabcde&quot;str.replace(/\w/, &#39;Q&#39;)// &quot;Qbcdeabcde&quot;</code></pre><p>如果第一个参数传入的全局匹配的正则表达式，那么replace()将会对符合条件的子字符串进行多次替换，最后返回经过多次替换的结果字符串。</p><pre><code class="js">var str = &#39;abcdeabcde&#39;str.replace(/a/g, &#39;A&#39;)// &quot;AbcdeAbcde&quot;str.replace(/\w/g, &#39;$&#39;)// &quot;$$$$$$$$$$&quot;</code></pre><ul><li>split()</li></ul><p>split()方法用于把一个字符串分割成字符串数组。第一个参数separator表示分割位置(参考符)，第二个参数howmany表示返回数组的允许最大长度(一般情况下不设置)。</p><pre><code class="js">var str = &#39;a|b|c|d|e&#39;str.split(&#39;|&#39;)// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]str.split(&#39;&#39;)// [&quot;a&quot;, &quot;|&quot;, &quot;b&quot;, &quot;|&quot;, &quot;c&quot;, &quot;|&quot;, &quot;d&quot;, &quot;|&quot;, &quot;e&quot;]str.split(&#39;|&#39;, 3)// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code></pre><p>也可以用正则来进行分割</p><pre><code class="js">var str = &#39;a1b2c3d4e&#39;str.split(/\d/)// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</code></pre><ul><li>toLowerCase()和toUpperCase()</li></ul><p>toLowerCase()方法可以把字符串中的大写字母转换为小写，toUpperCase()方法可以把字符串中的小写字母转换为大写。</p><pre><code class="js">var str = &#39;JavaScript&#39;;str.toLowerCase()// javascriptstr.toUpperCase()// JAVASCRIPT</code></pre><h2 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 Array"></a>数组 Array</h2><p>js对数组的操作非常频繁，但是每次用到的时候都会被搞混，都需要去查相关API，感觉这样很浪费时间。为了加深印象，所以整理一下对数组的相关操作。</p><h4 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h4><p>连接两个或更多的数组，并返回结果。方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。</p><pre><code class="js">var arr1 = [1, 2, 3]var arr2 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]var arr3 = arr1.concat(arr2)console.log(arr1, arr2, arr3)// [1, 2, 3] [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] [1, 2, 3, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]var arr4 = arr1.concat(1)console.log(arr4)// [1, 2, 3, 1]</code></pre><h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><p>把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。</p><pre><code class="js">var arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]var str = arr1.join(&#39;-&#39;)console.log(str)// 1-2-3-4-5-6-7-8-9var str1 = arr1.join()console.log(str1)// 1,2,3,4,5,6,7,8,9</code></pre><h4 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h4><p>删除并返回数组的最后一个元素，pop() 方法将删除 arrayObject 的最后一个元素，把数组长度减 1，并且返回它删除的元素的值。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值。</p><pre><code class="js">var arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]var arr2 = arr1.pop()console.log(arr1, arr2)// [1, 2, 3, 4, 5, 6, 7, 8]   9var arr3 = []var arr4 = arr3.pop()console.log(arr3, arr4)// []   undefined</code></pre><h4 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h4><p>删除并返回数组的第一个元素，如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined 值。请注意，该方法不创建新数组，而是直接修改原有的 arrayObject。</p><pre><code class="js">var arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]var arr2 = arr1.shift()console.log(arr1, arr2)// [2, 3, 4, 5, 6, 7, 8, 9]   1</code></pre><h3 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h3><p>向数组的开头添加一个或更多元素，并返回新的长度。unshift() 方法将把它的参数插入 arrayObject 的头部，并将已经存在的元素顺次地移到较高的下标处，以便留出空间。unshift() 方法不创建新的创建，而是直接修改原有的数组。</p><pre><code class="js">var arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]var arr2 = arr1.unshift(0, 0, 0, 0)console.log(arr1, arr2)// [0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]     13</code></pre><h4 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h4><p>向数组的末尾添加一个或更多元素，并返回新的长度。push() 方法可把它的参数顺序添加到 arrayObject 的尾部。它直接修改 arrayObject，而不是创建一个新的数组。push() 方法和 pop() 方法使用数组提供的先进后出栈的功能。</p><pre><code class="js">var arr1 = [1, 2, 3, 4]var arr2 = [5, 6, 7, 8, 9]var arr3 = arr1.push(arr2)console.log(arr1, arr2, arr3)// [1, 2, 3, 4, [5, 6, 7, 8, 9]]   [5, 6, 7, 8, 9]   5var arr4 = [1]var arr5 = arr4.push(5, 6, 7, 8, 9)console.log(arr4, arr5)// [1, 5, 6, 7, 8, 9]  6</code></pre><h4 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h4><p>从某个已有的数组返回选定的元素，请注意，该方法并不会修改数组，而是返回一个子数组。您可使用负值从数组的尾部选取元素。</p><pre><code class="js">var arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]var arr2 = arr1.slice(-5, -2)console.log(arr1, arr2)// [1, 2, 3, 4, 5, 6, 7, 8, 9]   [5, 6, 7]var arr3 = arr1.slice(2, 8)console.log(arr3)// [3, 4, 5, 6, 7, 8]var arr4 = arr1.slice(5)console.log(arr4)// [6, 7, 8, 9]</code></pre><h4 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h4><p>删除元素，并向数组添加新元素。方法向/从数组中添加/删除项目，然后返回被删除的项目。该方法会改变原始数组。splice() 方法可删除从 index 处开始的零个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。</p><pre><code class="js">var arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]var arr2 = arr1.splice(1, 5)console.log(arr1, arr2)// [1, 7, 8, 9]   [2, 3, 4, 5, 6]var arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]var arr3 = arr1.splice(2, 3, [0, 0, 0, 0])console.log(arr1, arr3)// [1, 2, [0, 0, 0, 0], 6, 7, 8, 9]   [3, 4, 5]var arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]var arr4 = arr1.splice(2, 3, 0, 0, 0, 0)console.log(arr1, arr4)// [1, 2, 0, 0, 0, 0, 6, 7, 8, 9]   [3, 4, 5]</code></pre><h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><p>对数组的元素进行排序，规定排序顺序。参数必须是函数。对数组的引用。请注意，数组在原数组上进行排序，不生成副本。</p><p>如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。</p><p>如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：</p><p>若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。<br>若 a 等于 b，则返回 0。<br>若 a 大于 b，则返回一个大于 0 的值。</p><pre><code class="js">var arr1 = [&#39;A&#39;, &#39;VCBJN&#39;, &#39;ksjn&#39;, &#39;adf&#39;, &#39;uuu&#39;]var arr2 = arr1.sort()console.log(arr1, arr2)// [&quot;A&quot;, &quot;VCBJN&quot;, &quot;adf&quot;, &quot;ksjn&quot;, &quot;uuu&quot;]   [&quot;A&quot;, &quot;VCBJN&quot;, &quot;adf&quot;, &quot;ksjn&quot;, &quot;uuu&quot;]var arr1 = [&#39;11&#39;, &#39;2222&#39;, &#39;3&#39;, &#39;44&#39;, &#39;555&#39;]arr1.sort()console.log(arr1)// [&quot;11&quot;, &quot;2222&quot;, &quot;3&quot;, &quot;44&quot;, &quot;555&quot;]var arr1 = [&#39;11&#39;, &#39;2222&#39;, &#39;3&#39;, &#39;44&#39;, &#39;555&#39;]arr1.sort((a, b) =&gt; a-b)console.log(arr1)// [&quot;3&quot;, &quot;11&quot;, &quot;44&quot;, &quot;555&quot;, &quot;2222&quot;]</code></pre><h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h4><p>颠倒数组中元素的顺序。该方法会改变原来的数组，而不会创建新的数组。</p><pre><code class="js">var arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]var arr2 = arr1.reverse()console.log(arr1, arr2)// [9, 8, 7, 6, 5, 4, 3, 2, 1]   [9, 8, 7, 6, 5, 4, 3, 2, 1]</code></pre><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p>把数组转换为字符串，并返回结果。当数组用于字符串环境时，JavaScript 会调用这一方法将数组自动转换成字符串。但是在某些情况下，需要显式地调用该方法。arrayObject 的字符串表示。返回值与没有参数的 join() 方法返回的字符串相同。</p><pre><code class="js">var arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]var arr2 = arr1.toString()console.log(arr1, arr2)// [1, 2, 3, 4, 5, 6, 7, 8, 9]     &quot;1,2,3,4,5,6,7,8,9&quot;</code></pre><h4 id="toLocaleString-NaN"><a href="#toLocaleString-NaN" class="headerlink" title="toLocaleString()"></a>toLocaleString()</h4><p>把数组转换为本地数组，并返回结果。首先调用每个数组元素的 toLocaleString() 方法，然后使用地区特定的分隔符把生成的字符串连接起来，形成一个字符串。</p><pre><code class="js">var arr1 = [&#39;jssj&#39;, 2, 3, &#39;测试&#39;, 5, 6, 7, 8, 9]var arr2 = arr1.toLocaleString()console.log(arr1, arr2)// [&quot;jssj&quot;, 2, 3, &quot;测试&quot;, 5, 6, 7, 8, 9]     &quot;jssj,2,3,测试,5,6,7,8,9&quot;</code></pre><h4 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h4><p>valueOf() 方法返回 Array 对象的原始值。该原始值由 Array 对象派生的所有对象继承。valueOf() 方法通常由 JavaScript 在后台自动调用，并不显式地出现在代码中。</p><h4 id="toSource"><a href="#toSource" class="headerlink" title="toSource()"></a>toSource()</h4><p>返回该对象的源代码。该原始值由 Array 对象派生的所有对象继承。toSource() 方法通常由 JavaScript 在后台自动调用，并不显式地出现在代码中。只有 Gecko 核心的浏览器（比如 Firefox）支持该方法，也就是说 IE、Safari、Chrome、Opera 等浏览器均不支持该方法。</p><pre><code class="js">function employee(name,job,born) &#123;    this.name=name;    this.job=job;    this.born=born;&#125;var bill = new employee(&quot;Bill Gates&quot;,&quot;Engineer&quot;,1985);console.log(bill.toSource());//  (&#123;name:&quot;Bill Gates&quot;, job:&quot;Engineer&quot;, born:1985&#125;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学毕业后的第一个小结</title>
      <link href="/2018-04/%E5%A4%A7%E5%AD%A6%E6%AF%95%E4%B8%9A%E5%90%8E%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%BB%93/"/>
      <url>/2018-04/%E5%A4%A7%E5%AD%A6%E6%AF%95%E4%B8%9A%E5%90%8E%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>不知不觉毕业已经将近三年了，干前端也有两年多了，从刚开始的门外汉也慢慢的成为一个能独立干活的职业猿了。两三年时间经历了很多次选择，从弱电到编程，从上海到杭州，但每一次的选择似乎都让自己向上又迈了一步。</p><span id="more"></span><h2 id="选择实习"><a href="#选择实习" class="headerlink" title="选择实习"></a>选择实习</h2><p>大学毕设期间，导师给我们毕设组的同学，两个不同的毕设实习选择，一个是上海的建筑公司实习，一个是学校的实验室。我选了前者，后经导师介绍，和女票（同专业同毕设组）一起来到上海一家国营性质的建筑公司实习。对于刚出校门的我们来说，一毕业就可以来到这样稳定的国营性质单位实习，那简直是天大的好事。当时就想着跟女票在这里好好表现争取被公司留用，也不敢让公司的同事知道我们俩的关系，担心会工作不保，每天上班时都保持距离。</p><p>当时我俩被分配到同一个部门，她跟着一位资历很高的老工程师做数据分析相关的工作，而我被分配到一个看着很年轻的同事身边，跟着一起做上海中心绿色能源生态系统的课题项目。该课题主要研究上海中心大厦各个系统间的供能关系和 BIM 运维相关内容。我也是在这个项目里，第一次接触到前端。</p><h2 id="选择部门"><a href="#选择部门" class="headerlink" title="选择部门"></a>选择部门</h2><p>很快三个月的实习期结束了，我们最终也如愿留了下来。因为我们实习的部门招聘名额有限，领导找我俩商量。一个是在研发部，将来更多时跟电脑编程打交道。一个是工程部，以后更多是跟弱电施工设计打交道。最终我们俩决定，她去工程我去研发。因为我对实习阶段中接触到的编程内容很感兴趣，但她却恰恰相反，对于编程她毫无好感。</p><p>就这样，开始了各自的工作生涯。刚刚开始的一段时间里在学习 C#，准备开发一个数据管理分析系统，不过最后项目还是没有落实下来。不过，部门却接了一个要求用 H5 术实现的 HybridAPP 项目，很庆幸加入到这个项目中。正是这个项目让我真正意义上，开启了前端之路。在项目开始后，深切感受到自己的能力和经验的不足，为了弥补不足，那段时间每天下班回家后，总会学习到很晚，犀牛书也是那时候翻过一遍。</p><p>该项目主要是以 Angular 1.x 框架为基础，结合 Cordova 平台和插件，完成 H5 页面对手机蓝牙、定位等功能的调用，实现以蓝牙为硬件基础的自动导览 APP。从现在看来，这个项目有很多很多不足和需要改进的地方。比如：项目文件目录不够清晰，大量外部插件引入，在 Angular 中使用 jquery，在代码中随意操作 dom 等。不过在之后的项目中，都做了对应的优化和改进。</p><h2 id="选择跳槽"><a href="#选择跳槽" class="headerlink" title="选择跳槽"></a>选择跳槽</h2><p>由于公司性质和业务问题，上下班时间很准时，基本不需要加班，个人时间比较多，这也让我养成了回家自我学习的习惯。平常回家有空就会学一些新东西，并尝试应用到项目中去，比如 node 相关的 express 和 koa 的 TodoList demo，研究使用 apidoc 快速生成 API 文档，在项目中引入 gulp 自动化构建工具，使用 vuejs 搭建项目管理后台的尝试等。</p><p>但对于在飞速发展的前端领域来说，只是自学这些是完全不够的，一定要在实际项目中去实践，才能有更好的成长。虽然在公司很开心，同事领导也很照顾，上班相对清闲，但是总觉的不能就这样安于现状，应该突破这个舒适区。去一个有更大挑战的地方，这样才能学到更多知识，才能更好的融入前端圈，于是就开始准备简历，找工作了。</p><h2 id="选择杭州"><a href="#选择杭州" class="headerlink" title="选择杭州"></a>选择杭州</h2><p>在上海的两年时间里，从刚开始租房时小区房价 18000 左右到离开上海时同小区房价涨到了 43000 左右，由原本在上海连续交两年社保就有购房资格，到离开上海前变成了连续缴纳 5 年才能有购房资格。这些变化，让原本想在上海努力奋斗，最后扎根的希望，完全破灭。</p><p>由于女票是浙江人，而且一直听说杭州的互联网环境很好，还有阿里，网易等大公司，所以在找工作时，就把范围扩大到了杭州。自知能力有限，在投简历时，也排除了大公司，最终投了大概 6-7 个，收到 3 个面试，最终拿到两个 offer。一个是上海的，一个是杭州的。虽然上海公司给的薪资较杭州要高，但上海公司使用的技术栈还停留在 jquery 时代，相对要落后；而杭州的公司使用的是相对流行的技术栈，node（网关层） + vuejs(前端) + reactjs（后台），综合上述考虑，最终选择来了杭州。</p><h2 id="今年思考"><a href="#今年思考" class="headerlink" title="今年思考"></a>今年思考</h2><p>从今天算起，来杭州已经有一年零十天了。在过去的一年里，公司在高速发展，同时组织架构也伴随着变化，公司内各阿米巴团队解散，产品技术从归属业务线到合并组成产品技术中心，我也从入职时属于电商阿米巴团队，到现在属于产品技术部下的前端组。在这快速发展的一年里，我也在成长，从以前的一个人做项目，到现在的协同合作。从以前的不熟悉 Vuejs，到现在的能够熟练开发各业务需求。</p><p>慢着，再停下来好好想想，我应该还有其他成长的。怎么啥也想不起来呢，可能真的没有了吧。</p><p>在过去的一年里，公司高速发展的同时，业务需求也在急剧增加，每天的工作都在赶需求，每天从九点半上班到晚上八九点才回家，周末还是单双休制度，爸妈每次给我打电话时，好像都在加班。这真的是我当初离职时，想要的嘛？</p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js与jsBridge的通讯原理</title>
      <link href="/2018-04/js%E4%B8%8Ejsbridge%E7%9A%84%E9%80%9A%E8%AE%AF%E5%8E%9F%E7%90%86/"/>
      <url>/2018-04/js%E4%B8%8Ejsbridge%E7%9A%84%E9%80%9A%E8%AE%AF%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>第一次接触到混合开发应该是在一年前，当时在做 ionic 和 Cordova(PhoneGap)项目的时候，这些框架在 web 基础上包了一层 Native，然后通过 Bridge 技术使得 js 可以调用视频、位置、音频等功能。目前手上负责的项目则是一个与自家 APP 交互的混合开发项目，于是在课余时间就查了查相关的实现方案和原理。本文就是介绍这层 Bridge 的交互原理，主要描述了 js 与 ios 及 android 底层的通讯原理及 JSBridge 的封装技术及调试方法。</p><span id="more"></span><h2 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a>主要用途</h2><p>JSBridge 简单来讲，主要是 给 JavaScript 提供调用 Native 功能的接口，让混合开发中的前端部分可以方便地使用定位、摄像头、系统相册等 Native 功能。</p><p>但是 JSBridge 的用途肯定不只调用 Native 功能这么简单。实际上，JSBridge 就像其名称中的 <code>Bridge</code> 的意义一样，是 Native 和非 Native 之间的桥梁，它的核心是 构建 <code>Native</code> 和<code>非 Native</code> 间消息通信的通道，而且是 双向通信的通道。</p><p><img src="http://cdn.chuyunt.com/uPic/006tNc79gy1fq9wv29dbfj30j604n74i.jpg"></p><p>所谓 双向通信的通道:</p><p>JS 向 Native 发送消息 : 调用相关功能、通知 Native 当前 JS 的相关状态等。<br>Native 向 JS 发送消息 : 回溯调用结果、消息推送、通知 JS 当前 Native 的状态等。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>主要分为两个部分，分别是 <code>JavaScript 调用 Native</code> 和 <code>Native 调用 JavaScript</code></p><h4 id="JavaScript-调用-Native"><a href="#JavaScript-调用-Native" class="headerlink" title="JavaScript 调用 Native"></a>JavaScript 调用 Native</h4><p>主要有两种实现方案，一种是 <code>拦截 URL SCHEME</code> ，另一种是 <code>注入API让js直接调用</code></p><h5 id="拦截-URL-SCHEME"><a href="#拦截-URL-SCHEME" class="headerlink" title="拦截 URL SCHEME"></a>拦截 URL SCHEME</h5><ul><li>什么是 URL SCHEME</li></ul><p>由于苹果的 app 都是在沙盒中，相互是不能访问数据的。但是苹果还是给出了一个可以在 app 之间跳转的方法：URL Scheme。URL SCHEME：URL SCHEME 是一种类似于 url 的链接，是为了方便 iosapp 直接互相跳转设计的，形式和普通的 url 近似，主要区别是 protocol 和 host 一般是自定义的，例如: lefit://leoao/xxxx?xx=123，protocol 是 lefit，host 则是 leoao</p><ul><li>实现流程<br>在 UIWebView 内发起的所有网络请求，都可以通过 delegate 函数在 Native 层得到通知。这样，我们就可以在 UIWebView 内发起一个自定义的网络请求，拦截 URL SCHEME 的主要流程是：Web 端通过某种方式（例如 iframe.src）发送 URL Scheme 请求，之后 Native 拦截到请求并根据 URL SCHEME（包括所带的参数）进行相关操作。</li></ul><p>在实际过程中，这种方式有一定的 缺陷：</p><ul><li>使用 iframe.src 发送 URL SCHEME 会有 url 长度的隐患。</li><li>创建请求，需要一定的耗时，比注入 API 的方式调用同样的功能，耗时会较长。</li></ul><blockquote><p>但是之前为什么很多方案使用这种方式呢？因为它 支持 iOS6。而现在的大环境下，iOS6 占比很小，基本上可以忽略，所以并不推荐为了 iOS6 使用这种 并不优雅 的方式。</p></blockquote><p><strong>注 1</strong>：有些方案为了规避 url 长度隐患的缺陷，在 iOS 上采用了使用 Ajax 发送同域请求的方式，并将参数放到 head 或 body 里。这样，虽然规避了 url 长度的隐患，但是 WKWebView 并不支持这样的方式。</p><p><strong>注 2</strong>：为什么选择 iframe.src 不选择 locaiton.href ？因为通过 location.href 有个问题，就是如果我们连续多次修改 window.location.href 的值，在 Native 层只能接收到最后一次请求，前面的请求都会被忽略掉。</p><h5 id="注入-API-让-js-直接调用"><a href="#注入-API-让-js-直接调用" class="headerlink" title="注入 API 让 js 直接调用"></a>注入 API 让 js 直接调用</h5><p>注入 API 方式的主要原理是，通过 WebView 提供的接口，向 JavaScript 的 Context（window）中注入对象或者方法，让 JavaScript 调用时，直接执行相应的 Native 代码逻辑，达到 JavaScript 调用 Native 的目的。</p><h6 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h6><p>对于 iOS 的 UIWebView，实例如下：</p><pre><code class="Objective-C">JSContext *context = [uiWebView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];context[@&quot;postBridgeMessage&quot;] = ^(NSArray&lt;NSArray *&gt; *calls) &#123;    // Native 逻辑&#125;;</code></pre><p>前端调用方式：</p><pre><code class="js">window.postBridgeMessage(message);</code></pre><p>对于 iOS 的 WKWebView 可以用以下方式：</p><pre><code class="Objective-C">@interface WKWebVIewVC ()&lt;WKScriptMessageHandler&gt;@implementation WKWebVIewVC- (void)viewDidLoad &#123;    [super viewDidLoad];    WKWebViewConfiguration* configuration = [[WKWebViewConfiguration alloc] init];    configuration.userContentController = [[WKUserContentController alloc] init];    WKUserContentController *userCC = configuration.userContentController;    // 注入对象，前端调用其方法时，Native 可以捕获到    [userCC addScriptMessageHandler:self name:@&quot;nativeBridge&quot;];    WKWebView wkWebView = [[WKWebView alloc] initWithFrame:self.view.frame configuration:configuration];    // TODO 显示 WebView&#125;- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message &#123;    if ([message.name isEqualToString:@&quot;nativeBridge&quot;]) &#123;        NSLog(@&quot;前端传递的数据 %@: &quot;,message.body);        // Native 逻辑    &#125;&#125;</code></pre><p>前端调用方式：</p><pre><code class="java">window.webkit.messageHandlers.nativeBridge.postMessage(message);</code></pre><h6 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h6><p>对于 Android 可以采用下面的方式：</p><pre><code class="java">public class JavaScriptInterfaceDemoActivity extends Activity &#123;    private WebView Wv;    @Override    public void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        Wv = (WebView)findViewById(R.id.webView);        final JavaScriptInterface myJavaScriptInterface = new JavaScriptInterface(this);        Wv.getSettings().setJavaScriptEnabled(true);        Wv.addJavascriptInterface(myJavaScriptInterface, &quot;nativeBridge&quot;);        // TODO 显示 WebView    &#125;    public class JavaScriptInterface &#123;         Context mContext;         JavaScriptInterface(Context c) &#123;             mContext = c;         &#125;         public void postMessage(String webMessage)&#123;             // Native 逻辑         &#125;     &#125;&#125;</code></pre><p>前端调用方式：</p><pre><code class="js">window.nativeBridge.postMessage(message);</code></pre><p>在 4.2 之前，Android 注入 JavaScript 对象的接口是 <code>addJavascriptInterface</code>，但是这个接口有漏洞，可以被不法分子利用，危害用户的安全，因此在 4.2 中引入新的接口 <code>@JavascriptInterface</code>（上面代码中使用的）来替代这个接口，解决安全问题。所以 Android 注入对对象的方式是 有兼容性问题的。</p><p>javascript 执行以下四种行为会被 webview 监听到，箭头后面是对应触发的 Java 方法。由于 prompt 相对来说使用的很少，所以 4.2 之前很多方案都采用拦截 prompt 的方式来实现。</p><pre><code>1、window.alert =&gt; onJSAlert2、window.confirm =&gt; onJSConfirm3、window.prompt =&gt; onJsPrompt4、window.location =&gt; shouldOverrideUrlLoading</code></pre><h4 id="Native-调用-JavaScript"><a href="#Native-调用-JavaScript" class="headerlink" title="Native 调用 JavaScript"></a>Native 调用 JavaScript</h4><p>Native 调用 JavaScript，其实就是<code>执行拼接 JavaScript 字符串</code>，从外部调用 JavaScript 中的方法，因此 JavaScript 的方法必须在全局的 window 上。（闭包里的方法，JavaScript 自己都调用不了，更不用想让 Native 去调用了）</p><h6 id="iOS-1"><a href="#iOS-1" class="headerlink" title="iOS"></a>iOS</h6><p>对于 iOS 的 UIWebView，示例如下：</p><pre><code class="Objective-C">result = [uiWebview stringByEvaluatingJavaScriptFromString:javaScriptString];</code></pre><p>对于 iOS 的 WKWebView，示例如下：</p><pre><code class="Objective-C">[wkWebView evaluateJavaScript:javaScriptString completionHandler:completionHandler];</code></pre><h6 id="Android-1"><a href="#Android-1" class="headerlink" title="Android"></a>Android</h6><p>对于 Android，在 Kitkat（4.4）之前并没有提供 iOS 类似的调用方式，只能用 loadUrl 一段 JavaScript 代码，来实现：</p><pre><code class="Java">webView.loadUrl(&quot;javascript:&quot; + javaScriptString);</code></pre><p>而 Kitkat 之后的版本，也可以用 evaluateJavascript 方法实现：</p><pre><code class="Java">webView.evaluateJavascript(javaScriptString, new ValueCallback&lt;String&gt;() &#123;    @Override    public void onReceiveValue(String value) &#123;    &#125;&#125;);</code></pre><p><strong>注</strong>：使用 loadUrl 的方式，并不能获取 JavaScript 执行后的结果。</p><p>参考链接：</p><ol><li><a target="_blank" rel="noopener" href="https://blog.ymfe.org/%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84JSBridge/">移动混合开发中的 JSBridge</a></li><li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000010356403">H5 与 Native 交互之 JSBridge 技术</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Default </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VueJs之Toast插件</title>
      <link href="/2018-04/vuejs%E4%B9%8Btoast%E6%8F%92%E4%BB%B6/"/>
      <url>/2018-04/vuejs%E4%B9%8Btoast%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="插件是什么"><a href="#插件是什么" class="headerlink" title="插件是什么"></a>插件是什么</h2><p>插件通常用于为 Vue 添加全局级别的功能。Vue.js 的插件应当有一个公开方法 install 。这个方法的第一个参数是 Vue 构造器 , 第二个参数是一个可选的选项对象:</p><pre><code class="js">export default &#123;    install (Vue, options) &#123;      Vue.globalMethod = function () &#123;  // 1. 添加全局方法或属性，如: vue-custom-element        // 逻辑...      &#125;      Vue.directive(&#39;my-directive&#39;, &#123;  // 2. 添加全局资源：指令/过滤器/过渡等，如 vue-touch        bind (el, binding, vnode, oldVnode) &#123;          // 逻辑...        &#125;        ...      &#125;)      Vue.mixin(&#123;        created: function () &#123;  // 3. 通过全局 mixin方法添加一些组件选项，如: vuex          // 逻辑...        &#125;        ...      &#125;)      Vue.prototype.$myMethod = function (options) &#123;  // 4. 添加实例方法，通过把它们添加到 Vue.prototype 上实现        // 逻辑...      &#125;    &#125;&#125;</code></pre><h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><p>通过调用全局方法 Vue.use() 使用插件：</p><pre><code class="js">// 调用 `MyPlugin.install(Vue)`Vue.use(MyPlugin)</code></pre><p>可以根据情况，传入一些可选的选项：</p><pre><code class="js">Vue.use(MyPlugin, &#123; someOption: true &#125;)</code></pre><p>Vue.use 会自动阻止多次使用同一个插件，所以对于同一个插件的多次调用，将只安装一次。</p><h2 id="Toast"><a href="#Toast" class="headerlink" title="Toast"></a>Toast</h2><ul><li>在使用IOS、Android的APP时，经常会收到系统的一些简短的提示信息，在其显示1–3s后自动关闭。</li><li>特点：<ul><li>内容简短，大多数就是一句话</li><li>显示在固定且显目的位置</li><li>没有关闭按钮</li><li>1–3秒后自动关闭消失</li></ul></li></ul><h3 id="Toast-vue"><a href="#Toast-vue" class="headerlink" title="Toast.vue"></a>Toast.vue</h3><p>先实现一个Toast.vue组件，完成基本样式和内容</p><pre><code class="html">&lt;template&gt;    &lt;div class=&quot;vue-toast&quot; :class=&quot;[visible ? &#39;&#39; : &#39;hidden&#39;, position]&quot;&gt;      &lt;div class=&quot;status-icon&quot; v-if=&quot;type !== &#39;default&#39;&quot;&gt;        &lt;!-- 不同类型会有不同图标 --&gt;        &lt;i class=&quot;iconfont icon-style&quot; :class=&quot;`icon-toast-$&#123;type&#125;`&quot;&gt;&lt;/i&gt;      &lt;/div&gt;      &lt;div class=&quot;status-text&quot;&gt;&#123;&#123;text || defaultText[type]&#125;&#125;&lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data () &#123;    return &#123;      visible: true,      text: &#39;&#39;,      type: &#39;default&#39;, // success, warn, error, default      position: &#39;&#39;,      defaultText: &#123;        &#39;success&#39;: &#39;操作成功&#39;,        &#39;error&#39;: &#39;操作失败&#39;,        &#39;warn&#39;: &#39;操作警告&#39;      &#125;    &#125;  &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.top &#123;  position: absolute;  top: 1rem;  left: 0;  right: 0;  margin: auto;&#125;.middle &#123;  position: absolute;  top: 0;  bottom: 0;  left: 0;  right: 0;  margin: auto;&#125;.bottom &#123;  position: absolute;  bottom: 1rem;  left: 0;  right: 0;  margin: auto;&#125;......// 用于toast消失时的小动画.hidden&#123;  opacity: 0;  transform: scale(0);  transition: opacity .5s;&#125;&lt;/style&gt;</code></pre><p>组件很简单，就是使用vue的数据绑定，默认显示toast内容</p><h3 id="Toast-js"><a href="#Toast-js" class="headerlink" title="Toast.js"></a>Toast.js</h3><p>接下来就是写插件内容了</p><pre><code class="js">import ToastVue from &#39;./Toast.vue&#39;/** * 使用指南 * // 以下会有图标显示 * this.$toast.success()  // 操作成功 * this.$toast.warn()     // 操作警告 * this.$toast.error()    // 操作失败 * * // 默认没有图标 * this.$toast(&#123; *   text: &#39;要提示的内容&#39; * &#125;) * * 参数如下： * text: &#39;&#39;, * duration: &#39;&#39;, // 关闭延时 默认1500ms * position: &#39;&#39;, // 提示框位置 top middle bottom 默认middle * onShow: function (params) &#123; &#125;, // 钩子，显示toast前触发 * onHide: function (params) &#123; &#125;  // 钩子，toast隐藏后触发 * */export default &#123;  install(Vue, options = &#123;&#125;) &#123;    // 构造器    var ToastConstructor = Vue.extend(ToastVue)    // 用于隐藏toast    ToastConstructor.prototype.close = function () &#123;      this.visible = false      this.$el.addEventListener(&#39;transitionend&#39;, this.destroyInstance.bind(this))    &#125;    // 用于销毁toast，删除dom    ToastConstructor.prototype.destroyInstance = function (params) &#123;      this.$destroy(true)      this.$el.removeEventListener(&#39;transitionend&#39;, this.destroyInstance)      this.$el.parentNode.removeChild(this.$el)    &#125;    //     Vue.prototype.$toast = (option = &#123;&#125;, type) =&gt; &#123;        if (document.getElementsByClassName(&#39;vue-toast&#39;).length) &#123;            // 如果toast还在，则不再执行            return;        &#125;        // 通过 new 创建组件实例        let instance = new ToastConstructor(&#123;            el: document.createElement(&#39;div&#39;)        &#125;)        // 向组件内部传递参数        instance.text = typeof option === &#39;string&#39; ? option : option.text        instance.type = type || &#39;default&#39;        let duration = option.duration || options.duration || 2000        instance.position = option.position || &#39;middle&#39;        // 设置钩子        option.onShow &amp;&amp; option.onShow(instance)        // 添加dom        document.body.appendChild(instance.$el)        // 设置延时，销毁dom        setTimeout(() =&gt; &#123;            instance.close()            option.onHide &amp;&amp; option.onHide(instance)        &#125;, duration)    &#125;    // 注册多个常用方法    [&#39;success&#39;, &#39;warn&#39;, &#39;error&#39;].forEach((key) =&gt; &#123;      Vue.prototype.$toast[key] = (option = &#123;&#125;) =&gt; &#123;        return Vue.prototype.$toast(option, key)      &#125;    &#125;)  &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaScript事件详解</title>
      <link href="/2018-01/javascript%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018-01/javascript%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="事件绑定和普通事件有什么区别"><a href="#事件绑定和普通事件有什么区别" class="headerlink" title="事件绑定和普通事件有什么区别"></a>事件绑定和普通事件有什么区别</h3><p>事件绑定就是针对dom元素的事件，绑定在dom元素上。普通事件即为非针对dom元素的事件。</p><ul><li>普通事件不能同时注册多个事件</li><li>普通事件只在冒泡被调用</li></ul><pre><code class="js">// 普通事件var btn = document.getElementById(&quot;hello&quot;);btn.onclick = function()&#123;    alert(1);&#125;;btn.onclick = function()&#123;    alert(2);&#125;; //这个事件只会弹出2;// 在事件冒泡过程中被调用// 作为btn的属性绑定事件，function1会被function2覆盖而只执行function2;// 事件绑定var btn = document.getElementById(&quot;hello&quot;);btn.addEventListener(&quot;click&quot;,function()&#123;    alert(1);&#125;,false);btn.addEventListener(&quot;click&quot;,function()&#123;    alert(2);&#125;,false); //这个事件首先会弹出1，然后在弹出2;</code></pre><h3 id="IE和DOM事件流的区别-事件模型"><a href="#IE和DOM事件流的区别-事件模型" class="headerlink" title="IE和DOM事件流的区别(事件模型)"></a>IE和DOM事件流的区别(事件模型)</h3><h5 id="1-执行顺序不一样，IE采用冒泡型事件，DOM使用先捕获后冒泡型事件，Netscape使用捕获型事件"><a href="#1-执行顺序不一样，IE采用冒泡型事件，DOM使用先捕获后冒泡型事件，Netscape使用捕获型事件" class="headerlink" title="1.执行顺序不一样，IE采用冒泡型事件，DOM使用先捕获后冒泡型事件，Netscape使用捕获型事件"></a>1.执行顺序不一样，IE采用冒泡型事件，DOM使用先捕获后冒泡型事件，Netscape使用捕获型事件</h5><pre><code class="html">&lt;body&gt;    &lt;div&gt;        &lt;button&gt;点击这里&lt;/button&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><ul><li>冒泡型事件模型： button-&gt;div-&gt;body (IE事件流)</li><li>捕获型事件模型： body-&gt;div-&gt;button (Netscape事件流)</li><li>DOM事件模型： body-&gt;div-&gt;button-&gt;button-&gt;div-&gt;body (先捕获后冒泡)</li></ul><h5 id="2-事件侦听函数的区别（参数不同，事件是否”on”，this指向问题）"><a href="#2-事件侦听函数的区别（参数不同，事件是否”on”，this指向问题）" class="headerlink" title="2.事件侦听函数的区别（参数不同，事件是否”on”，this指向问题）"></a>2.事件侦听函数的区别（参数不同，事件是否”on”，this指向问题）</h5><pre><code class="js">// IE使用:[Object].attachEvent(&quot;onclick&quot;, fnHandler); //绑定函数[Object].detachEvent(&quot;onclick&quot;, fnHandler); //移除绑定// IE下利用attachEvent注册的处理函数调用时，this指向不再是先前注册事件的元素，这时的this为window对象了// DOM使用：(该方法既支持注册冒泡型事件处理，又支持捕获型事件处理)[Object].addEventListener(&quot;click&quot;, fnHandler, false/true); //绑定函数[Object].removeEventListener(&quot;click&quot;, fnHandler, false/true); //移除绑定// 第三个参数注明该处理回调函数是在事件传递过程中的捕获阶段(true)被调用还是冒泡阶段(flase)被调用// 通用方法，注册事件function addEvent(element, type, handler) &#123;    if (element.addEventListener) &#123;        //事件类型、需要执行的函数、是否捕捉        element.addEventListener(type, handler, false);    &#125; else if (element.attachEvent) &#123;        element.attachEvent(&#39;on&#39; + type, function() &#123;            handler.call(element);        &#125;);    &#125; else &#123;        element[&#39;on&#39; + type] = handler;    &#125;&#125;// 通用方法，移除事件function removeEvent(element, type, handler) &#123;    if (element.removeEventListener) &#123;        element.removeEventListener(type, handler, false);    &#125; else if (element.datachEvent) &#123;        element.detachEvent(&#39;on&#39; + type, handler);    &#125; else &#123;        element[&#39;on&#39; + type] = null;    &#125;&#125;// 通用方法，获取事件目标function getTarget(event) &#123;    return event.target || event.srcElement;&#125;</code></pre><h5 id="如何取消浏览器事件的传递"><a href="#如何取消浏览器事件的传递" class="headerlink" title="如何取消浏览器事件的传递"></a>如何取消浏览器事件的传递</h5><p>取消事件传递是指：停止捕获型事件或冒泡型事件的进一步传递。在body处理停止事件传递后，位于上层的document的事件监听器就不再收到通知，不再被处理。</p><pre><code class="js">// IE下,通过设置event对象的cancelBubble为truewindow.event.cancelBubble = true;// DOM标准情况下，通过调用event对象的stopPropagation()方法event.stopPropagation()// 通用方法function stopHandler(event) &#123;    window.event ? window.event.cancelBubble = true : event.stopPropagation();&#125;;</code></pre><h5 id="事件传递后浏览器的默认处理"><a href="#事件传递后浏览器的默认处理" class="headerlink" title="事件传递后浏览器的默认处理"></a>事件传递后浏览器的默认处理</h5><p>事件传递后的默认处理是指：通常浏览器在事件传递并处理完后会执行与该事件关联的默认动作（如果存在这样的动作）</p><pre><code class="js">// IE下通过设置event对象的returnValue为flasewindow.event.returnValue = false// DOM下调用event对象的preventDefault()方法event.preventDefault()// 通用方法function cancelHandler(event)&#123;  var event = event || window.event;  //用于IE  if(event.preventDefault) event.preventDefault();  //标准技术  if(event.returnValue) event.returnValue = false;  //IE  return false;   //用于处理使用对象属性注册的处理程序&#125;</code></pre><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><ol><li>捕获型事件传递由最不精确的祖先元素一直到最精确的事件源元素，传递方式与操作系统中的全局快捷键与应用程序快捷键相似。当一个系统组合键发生时，如果注册了系统全局快捷键监听器，该事件就先被操作系统层捕获，全局监听器就先于应用程序快捷键监听器得到通知，也就是全局的先获得控制权，它有权阻止事件的进一步传递。所以捕获型事件模型适用于作全局范围内的监听，这里的全局是相对的全局，相对于某个顶层结点与该结点所有子孙结点形成的集合范围。例如你想作全局的点击事件监听，相对于document结点与document下所有的子结点，在某个条件下要求所有的子结点点击无效，这种情况下冒泡模型就解决不了了，而捕获型却非常适合，可以在最顶层结点添加捕获型事件监听器</li><li>可以说我们平时用的都是冒泡事件模型，因为IE只支持这模型。这里还是说说，在恰当利用该模型可以提高脚本性能。在元素一些频繁触发的事件中，如onmousemove, onmouseover,onmouseout,如果明确事件处理后没必要进一步传递，那么就可以大胆的取消它。此外，对于子结点事件监听器的处理会对父层监听器处理造成负面影响的，也应该在子结点监听器中禁止事件进一步向上传递以消除影响。</li></ol><h3 id="什么是事件代理（事件委托）"><a href="#什么是事件代理（事件委托）" class="headerlink" title="什么是事件代理（事件委托）"></a>什么是事件代理（事件委托）</h3><p>当我们需要对很多元素添加事件的时候，可以通过将事件添加到它们的父节点而将事件委托给父节点来触发处理函数。这主要得益于浏览器的事件冒泡机制</p><pre><code class="html">&lt;ul id=&quot;parent-list&quot;&gt;  &lt;li id=&quot;post-1&quot;&gt;Item 1&lt;/li&gt;  &lt;li id=&quot;post-2&quot;&gt;Item 2&lt;/li&gt;  &lt;li id=&quot;post-3&quot;&gt;Item 3&lt;/li&gt;  &lt;li id=&quot;post-4&quot;&gt;Item 4&lt;/li&gt;  &lt;li id=&quot;post-5&quot;&gt;Item 5&lt;/li&gt;  &lt;li id=&quot;post-6&quot;&gt;Item 6&lt;/li&gt;&lt;/ul&gt;</code></pre><p>当我们的鼠标移到Li上的时候，需要获取此Li的相关信息并飘出悬浮窗以显示详细信息，或者当某个Li被点击的时候需要触发相应的处理事件。我们通常的写法，是为每个Li都添加一些类似onMouseOver或者onClick之类的事件监听。</p><pre><code class="js">// 获取父节点，并为它添加一个click事件document.getElementById(&quot;parent-list&quot;).addEventListener(&quot;click&quot;,function(e) &#123;  // currentTarget属性，事件绑定的对象  // 检查事件源e.targe是否为Li  if(e.target &amp;&amp; e.target.nodeName.toUpperCase == &quot;LI&quot;) &#123;    // 真正的处理过程在这里    console.log(&quot;List item &quot;,e.target.id.replace(&quot;post-&quot;),&quot; was clicked!&quot;);  &#125;&#125;);</code></pre><p>使用事件代理的好处是可以提高性能，可以大量节省内存占用，减少事件注册，比如在table上代理所有td的click事件就非常棒，还可以实现当新增子对象时无需再次对其绑定</p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>call、apply和bind的区别</title>
      <link href="/2018-01/call%E3%80%81apply%E5%92%8Cbind%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018-01/call%E3%80%81apply%E5%92%8Cbind%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>JavaScript的一大特点是，函数存在<code>定义时的上下文</code>和<code>运行时的上下文</code>以及<code>上下文是可以改变的</code>这样的概念。call、apply和bind都是为了改变某个函数运行时的上下文而存在的，换句话说，就是为了改变函数体内部this的指向。以下是三个相似点：</p><span id="more"></span><ul><li>都是用来改变函数的this对象的指向的。</li><li>第一个参数都是this要指向的对象。</li><li>都可以利用后续参数传参。</li></ul><pre><code class="js">function student () &#123;&#125;student.prototype = &#123;  age: 18,  name: &#39;小明&#39;,  say: function () &#123;    document.write(`我的名字叫$&#123;this.name&#125;,今年$&#123;this.age&#125;岁。&lt;br&gt;`)  &#125;&#125;var student1 = new student()student1.say()var student2 = &#123;  name: &#39;小红&#39;,  age: 20&#125;student1.say.call(student2)student1.say.apply(student2)student1.say.bind(student2)()</code></pre><h5 id="call-和-apply-的区别"><a href="#call-和-apply-的区别" class="headerlink" title="call 和 apply 的区别"></a>call 和 apply 的区别</h5><p>对于 apply、call 二者而言，作用完全一样，只是接受参数的方式不太一样。</p><pre><code class="js">function student () &#123;&#125;student.prototype = &#123;  age: 18,  name: &#39;小明&#39;,  say: function (school, className) &#123;    document.write(`我的名字叫$&#123;this.name&#125;,今年$&#123;this.age&#125;岁。就读于$&#123;school&#125;$&#123;className&#125;&lt;br&gt;`)  &#125;&#125;var student1 = new student()var student2 = &#123;  name: &#39;小红&#39;,  age: 12&#125;var student3 = &#123;  name: &#39;小华&#39;,  age: 15&#125;student1.say.call(student2,&#39;实验小学&#39;,&#39;五年级&#39;)   // 直接接在后面，在已经参数数量的情况下使用student1.say.apply(student3,[&#39;实验中学&#39;,&#39;初一&#39;])  // 通过数组形式，在未知参数数量时，可通过push方式，为数组添加参数// call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。</code></pre><h5 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h5><p>bind()方法与apply/call很相似，也可以改变函数内this的指向的。</p><p>MDN的解释是：bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p><pre><code class="js">var foo = &#123;  bar: 1,  eventBind : function () &#123;    document.getElementById(&#39;bind&#39;).onclick = function () &#123;      console.log(this)    &#125;  &#125;&#125;foo.eventBind() // &lt;div id=&quot;bind&quot;&gt;点击&lt;/div&gt;var foo = &#123;  bar: 1,  eventBind : function () &#123;    document.getElementById(&#39;bind&#39;).onclick = function () &#123;      console.log(this)    &#125;.bind(this)  &#125;&#125;foo.eventBind() // &#123;bar: 1, eventBind: ƒ&#125;</code></pre><h3 id="bind、call、apply-三者区别"><a href="#bind、call、apply-三者区别" class="headerlink" title="bind、call、apply 三者区别"></a>bind、call、apply 三者区别</h3><pre><code class="js">var obj = &#123;    x: 81,&#125;; var foo = &#123;    getX: function() &#123;        return this.x;    &#125;&#125; console.log(foo.getX.bind(obj)());  //81console.log(foo.getX.call(obj));    //81console.log(foo.getX.apply(obj));   //81</code></pre><ul><li>apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；</li><li>apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；</li><li>apply 、 call 、bind 三者都可以利用后续参数传参；</li><li>apply 、call 区别在于传递参数的类型，call按顺序传递可确定个数参数</li><li>bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。</li></ul><p><a target="_blank" rel="noopener" href="http://web.jobbole.com/83642/">详细参考链接：http://web.jobbole.com/83642/</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用AWS搭建一年免费的Shadowscoke</title>
      <link href="/2018-01/%E4%BD%BF%E7%94%A8aws%E6%90%AD%E5%BB%BA%E4%B8%80%E5%B9%B4%E5%85%8D%E8%B4%B9%E7%9A%84shadowscoke/"/>
      <url>/2018-01/%E4%BD%BF%E7%94%A8aws%E6%90%AD%E5%BB%BA%E4%B8%80%E5%B9%B4%E5%85%8D%E8%B4%B9%E7%9A%84shadowscoke/</url>
      
        <content type="html"><![CDATA[<p>作为一个前端开发，不能使用Google，那不就是相当于失去了左板右臂，这怎么可以？ 但是要钱的FQ服务又有点贵，不舍得花钱，那今天我们就来薅一把亚马逊爸爸的羊毛。</p><span id="more"></span><h2 id="创建服务器展开目录"><a href="#创建服务器展开目录" class="headerlink" title="创建服务器展开目录"></a>创建服务器展开目录</h2><h3 id="1-1-原理"><a href="#1-1-原理" class="headerlink" title="1.1 原理"></a>1.1 原理</h3><p>众所周知目前的网页访问基本都是 C/S 模式，而在中国由于客户机向服务器的发起的请求，如果是禁网则可以被 GWF 识别封杀，那么我们的原理就是让一个客户机（对我们来说它就是我们的代理人）在国外替我们拿到数据然后再传回来，为了防止传回的数据被 GWF 识别，我们要对数据加密，目前比较优秀的即使 shadowsocks。</p><h3 id="1-2-服务器架设"><a href="#1-2-服务器架设" class="headerlink" title="1.2 服务器架设"></a>1.2 服务器架设</h3><p>这里利用的是 AWS（Amazon Web Services)，是亚马逊提供的在线虚拟主机服务。现在 AWS 提供的基础服务免费一年，流量每月 15G，只要你不是天天上网下大文件的话，一般不会超。<br>之所以选择 AWS，首先是因为它比较稳定，并且它有东京的节点。网上很多其他主机商的节点都远在美国，距离近延迟低是铁律。<br>虽然中国人都喜欢免费的东西，但还是建议有钱的豪还是选择付费。</p><h4 id="1-2-1-申请-AWS-账号"><a href="#1-2-1-申请-AWS-账号" class="headerlink" title="1.2.1 申请 AWS 账号"></a>1.2.1 申请 AWS 账号</h4><p>如果以下任何一步中出现灰色页面一个橘黄圈圈不停在转的话，多刷新几次就好。</p><ol><li>首先搜索 “AWS”，第一个打开就是 <a target="_blank" rel="noopener" href="https://www.amazonaws.cn/">https://www.amazonaws.cn/</a></li><li>注册一个账号，如果你之前有在 Amazon 买过东西，直接用那个账号也可以。</li><li>填好邮箱密码之后会要求填一些个人信息，这里选择个人账户，姓名、地址和电话，可以照实填，乱填应该也没关系，因为我第一次填的特别详细结果进去以后全成了乱码。</li><li>接下来要填写付款信息，只支持信用卡，银联 Visa 等都可以。我自己使用的某宝的虚拟 aws EC2 信用卡。因为 AWS 采用的是基础服务免费，超出基础服务以外的部分收费。比如说一个月流量超出 15G 的话是会收钱的。收钱的时候是直接卡里扣不会通知你的。这一步目前没有发现绕过的方法，填好之后点 “继续”。 因此使用虚拟卡放心一些。</li><li>然后是身份验证部分，这里比较麻烦。国家选中国，填入手机号（推荐）或者座机号（注意区号），分机没有的话留空就好了，然后点“立刻呼叫我”。之后会出现一个页面，同时接到一个电话。电话是英文的，会让你输入 PIN 码。等对面说完话之后直接按就好。按完之后稍等一会挂掉，等待网页刷新。</li><li>点击“继续选择支持方案”。选择“基本（免费）”点“继续”。此时账号应该就创建好了，邮箱应该会收到几封邮件。</li></ol><h4 id="1-2-2-创建服务器"><a href="#1-2-2-创建服务器" class="headerlink" title="1.2.2 创建服务器"></a>1.2.2 创建服务器</h4><ol><li>进入 aws 主页，<a target="_blank" rel="noopener" href="https://www.amazonaws.cn/%E3%80%82%E5%8F%B3%E4%B8%8A%E8%A7%92%E7%82%B9%E5%87%BB">https://www.amazonaws.cn/。右上角点击</a> “我的账户”，再点击 “aws 控制台”，输入邮箱和密码。登录.</li><li>右上角用户名后面有一个地区选择，选择合适的地区。发给你的邮件中有通知你可以在哪些地区创建主机。如果你在选择其他地方创建，则会失败。</li><li>点击左上角的服务，出现一个下拉列表，选择 EC2。如果你之前填的信用卡有问题，可能会出现一个页面，提示：确保你之前的信息提供正确等，这时你就需要点解右上角用户名选择 “我的账户”，再选择 “付款方式” 更该信用卡信息。</li><li>点击 “启动实例”</li><li>找到 “Ubuntu Server 16.04 LTS(HVM)…”，点击 “选择”。请特别注意图标上 “符合条件的免费套餐” 字样。不带这个字样的都要钱。</li><li>然后，仍旧选中 “符合条件的免费套餐”，然后点击蓝色按钮 “审核和启动”。</li><li>接着直接点击 “启动”。</li><li>之后会弹出来一个创建密匙对的框，在第一个下拉框中，选择 “创建新密匙对”。在第二个框中输入你的密匙对的名字，这里取名叫“r3”。点“下载密匙对”，会下载一个叫“r3.pem”的文件，把文件保存在一个绝对安全的地方。这里的密匙相当于进入你的服务器的钥匙，只要有这把钥匙，任何人都可以进入你的服务器为所欲为。所以请好好保管。这个文件丢失的话，首先你自己的服务器就上不去了，其他的后果应该会很严重吧，所以请好好保管。你可以制作备份。</li><li>保存好之后，点“启动实例”。至此为止，你的服务器已经创建好。</li><li>点击页面中第一个绿色框里你的服务器名字，这里是“i-405c2fe5”，跳转到以下页面。这里有几个关键信息需要记下 。一个是<code>公有DNS</code>，另一个要往右边拉一下滚动条，<code>公有IP</code>，拿笔写下来。</li></ol><h2 id="远程连接服务器展开目录"><a href="#远程连接服务器展开目录" class="headerlink" title="远程连接服务器展开目录"></a>远程连接服务器展开目录</h2><h3 id="2-1-原理"><a href="#2-1-原理" class="headerlink" title="2.1 原理"></a>2.1 原理</h3><p>有计算机只是的应该懂得，远程连接服务器指的就是用一个终端（什么是终端？终端就是客户端）连接服务器，然后在服务器做一些列的操作。常用的终端 xshell，putty 都可以。</p><h3 id="2-2-连接"><a href="#2-2-连接" class="headerlink" title="2.2 连接"></a>2.2 连接</h3><h4 id="2-2-1-Windows-平台"><a href="#2-2-1-Windows-平台" class="headerlink" title="2.2.1 Windows 平台"></a>2.2.1 Windows 平台</h4><p>在 Windows 中，我们需要用到两个软件，一个叫 “putty”，一个叫 “puttygen”。putty 可以把它看做是一个连接你和服务器的超时空隧道，但是它不认识 aws 提供的钥匙（就是你刚才下载的 r3.pem），首先我们要配一把新钥匙。</p><ol><li>打开 puttygen。选中菜单栏中的 “密钥（k）”，选中下拉菜单 “SSH-2 RSA”。</li></ol><ul><li>点解 “load” 或“载入”。在打开的对话框中，选择文件类型下拉框为“All Files(.)”，然后找到前面我们保存的钥匙“r3.pem”，然后打开。</li><li>确定”。然后点击 “Load” 下面的 “Save private key” 按钮。</li><li>弹出的对话框点 “是”，保存为一个 *.ppk 文件，就把它继续命名为 “r3.ppk”。这就是我们的新钥匙啦，同样请好好保存。</li><li>接下来关闭 puttygen，打开 putty。</li><li>点击 “session” 或“会话”。右边，“Host Name(or IP address)”这里填写“ubuntu @服务器公有 DNS”，例如：<a href="mailto:&#117;&#x62;&#117;&#x6e;&#x74;&#x75;&#64;&#101;&#99;&#x32;&#x2d;&#x35;&#52;&#x2d;&#50;&#51;&#x38;&#x2d;&#50;&#x31;&#49;&#45;&#49;&#52;&#57;&#x2e;&#97;&#x70;&#x2d;&#110;&#x6f;&#114;&#116;&#104;&#101;&#x61;&#x73;&#x74;&#x2d;&#50;&#46;&#99;&#111;&#109;&#112;&#117;&#x74;&#x65;&#x2e;&#x61;&#109;&#97;&#122;&#x6f;&#x6e;&#x61;&#x77;&#115;&#46;&#99;&#x6f;&#x6d;">&#117;&#x62;&#117;&#x6e;&#x74;&#x75;&#64;&#101;&#99;&#x32;&#x2d;&#x35;&#52;&#x2d;&#50;&#51;&#x38;&#x2d;&#50;&#x31;&#49;&#45;&#49;&#52;&#57;&#x2e;&#97;&#x70;&#x2d;&#110;&#x6f;&#114;&#116;&#104;&#101;&#x61;&#x73;&#x74;&#x2d;&#50;&#46;&#99;&#111;&#109;&#112;&#117;&#x74;&#x65;&#x2e;&#x61;&#109;&#97;&#122;&#x6f;&#x6e;&#x61;&#x77;&#115;&#46;&#99;&#x6f;&#x6d;</a>。</li><li>端口保持默认的 “22”，“Connection type” 选择“SSH”。</li><li>在左边的树状目录中，展开 “Connection” 下的 “SSH”，找到“Auth” 或“认证”，点击 “Auth”，在右边点击“Browse…” 或者“浏览”，选中刚刚我们配的新钥匙“r3.ppk”，其它地方不动，然后回到刚才的“Session”。</li><li>点击右下角的 “Open” 或“打开”。</li><li>接下来会打开一个像 windows 的 cmd 命令行一样的黑框如下</li><li>弹出对话框点击 “是”</li><li>出现 ubuntu@ip-x-x-x-x:!$ 表示连接成功。</li></ul><h4 id="2-2-2-Mac-平台"><a href="#2-2-2-Mac-平台" class="headerlink" title="2.2.2 Mac 平台"></a>2.2.2 Mac 平台</h4><p>转到Mac上之后，不用在使用之前window上面的putty的方法了，可以直接用命令行SSH登录。实际在aws上面已经直接介绍了使用linux访问ec2的方法，我们只需要直接按照上面的方法做就可以了。打开aws实例，反键点击connect，选择Connect with a standalone SSH Client，可以看到：</p><ol><li><p>打开 SSH 客户端。</p></li><li><p>查找您的私有密钥文件(r3.pem)。向导会自动检测您用于启动实例的密钥。您的密钥必须不公开可见，SSH才能工作。需要使用此命令：<br><code>chmod 400 r3.pem</code></p></li><li><p>通过其 <code>公有DNS</code> 连接到您的实例:<br><code>ec2-54-238-211-149.ap-northeast-2.compute.amazonaws.com</code><br>示例：<br><code>ssh -i &quot;r3.pem&quot; ubuntu@ec2-54-238-211-149.ap-northeast-2.compute.amazonaws.com</code><br>请注意，在大多数情况下，上述用户名都是正确的，但请确保您已阅读了 AMI 使用说明以确定 AMI 所有人没有更改默认的 AMI 用户名。</p></li><li><p>出现 ubuntu@ip-x-x-x-x:!$ 表示连接成功。</p></li></ol><h2 id="搭建-shadowsocks-服务端展开目录"><a href="#搭建-shadowsocks-服务端展开目录" class="headerlink" title="搭建 shadowsocks 服务端展开目录"></a>搭建 shadowsocks 服务端展开目录</h2><h3 id="3-1-安装"><a href="#3-1-安装" class="headerlink" title="3.1 安装"></a>3.1 安装</h3><ol><li><p>连接上之后，首先要将我们当前登录的用户提升至 root 权限，输入如下代码并回车</p><p> <code>sudo -s</code></p><p> 你会发现光标前面的 “$” 变成了 “#”，并且行首的“ubuntu” 也变成了“root”。</p></li></ol><ul><li><p>接下来输入如下命令并回车</p><p>  <code>apt-get update</code></p><p>  就当作是在安装更新包吧，完成后会显示 “Reading package lists… Done”。</p></li><li><p>然后输入如下命令并回车</p><p>  <code>apt-get install python-pip</code></p><p>  安装过程中可能会让你确认［Y/n］，输入 y 然后回车就好。</p></li><li><p>安装关键程序 ShadowSocket，输入如下命令并回车</p><p>  <code>pip install shadowsocks</code></p><p>  出来一大段字后只要有显示的是 “Successfully …” 那么就表示安装成功了。</p></li></ul><h3 id="3-2-配置-shadowsokcet"><a href="#3-2-配置-shadowsokcet" class="headerlink" title="3.2 配置 shadowsokcet"></a>3.2 配置 shadowsokcet</h3><h4 id="3-2-1-主要是修改其中的一个配置文件。"><a href="#3-2-1-主要是修改其中的一个配置文件。" class="headerlink" title="3.2.1 主要是修改其中的一个配置文件。"></a>3.2.1 主要是修改其中的一个配置文件。</h4><p>输入如下命令</p><p><code>vi /etc/shadowsocks.json</code></p><p>在这个视图中有如下几个按键需要记住：</p><ul><li>“i”：按键盘上的 i 键，窗口最底下显示 “insert”，表示当前文件可编辑。</li><li>“Esc”：编辑完之后按 Esc 退出编辑模式。</li><li>“:”：半角的冒号，在非编辑模式下按键盘上的冒号（半角），可以进入输入命令的模式。</li><li>“w”：在命令模式中输入 w 并回车，窗口最下显示 “written”，表示所做的更改已保存。</li><li>“q”：在命令模式中输入 q 并回车，可以退出当前的编辑器。</li></ul><h4 id="3-2-2-单一用户配置（推荐）"><a href="#3-2-2-单一用户配置（推荐）" class="headerlink" title="3.2.2 单一用户配置（推荐）"></a>3.2.2 单一用户配置（推荐）</h4><p>按 “i” 之后输入如下代码</p><pre><code class="json">&#123;&quot;server&quot;:&quot;0.0.0.0&quot;,&quot;server_port&quot;:8989,&quot;local_address&quot;:&quot;127.0.0.1&quot;,&quot;local_port&quot;:1080,&quot;password&quot;:&quot;yourpassword&quot;,&quot;timeout&quot;:300,&quot;method&quot;:&quot;aes-256-cfb&quot;,&quot;fast_open&quot;: false&#125;</code></pre><p>这里需要注意几个地方：</p><ul><li>所有的字母，符号和数字都是在半角状态下输入的</li><li>每一个标点符号都很重要，不能多也不能少</li><li>每一行都是由左右两边组成，每一行冒号左边都是有引号的</li><li>右边的部分需要自己手动修改的只有第三行 “端口” 和第六行“密码”。其它不变</li><li>“port” 这里是没有引号的，并且需要改成一个数字。我一般习惯用8848或者11383。但是注意这个数字是不能随便乱写的。</li><li>“password” 这里可以自己填写，但要注意是有引号的</li><li>除了倒数第二行以外（大括号前一行），每一行都要以半角逗号作为结尾</li><li>首尾行的大括号不要忘记了</li></ul><p>输入完之后按 Esc 退出编辑，然后先按: wq 保存。</p><h4 id="3-2-3-多用户配置（进阶）"><a href="#3-2-3-多用户配置（进阶）" class="headerlink" title="3.2.3 多用户配置（进阶）"></a>3.2.3 多用户配置（进阶）</h4><p>如果你不介意和朋友分享的话，可以照下面的设置来添加多个用户。但不推荐太多人共享，一个原因是免费的主机内存硬盘空间都很有限，太多用户的话可能负担比较重。另一个原因流量只有 15G 哎，先确定自己够用再想别人吧。并且实际上，访问次数也有限制，只不过这个限制对于单个用户来说实在用不完。</p><p>同上一步一样，键入 “i” 然后输入如下代码</p><pre><code class="json">&#123;&quot;server&quot;:&quot;0.0.0.0&quot;,&quot;local_address&quot;:&quot;127.0.0.1&quot;,&quot;local_port&quot;:1080,&quot;port_password&quot;:&#123;    &quot;8989&quot;:&quot;password0&quot;,    &quot;9001&quot;:&quot;password1&quot;,    &quot;9002&quot;:&quot;password2&quot;,    &quot;9003&quot;:&quot;password3&quot;,    &quot;9004&quot;:&quot;password4&quot;&#125;,&quot;timeout&quot;:300,&quot;method&quot;:&quot;aes-256-cfb&quot;,&quot;fast_open&quot;: false&#125;</code></pre><blockquote><p>第三行和第六行是由另一对大括号包围起来的，这中间的部分填写端口和密码。每一对端口和密码对应一个用户，后面设置的时候会用到。多一个用户就多加一行。注意”password4” 之后因为下一行就是大括号，所以这里不用加逗号，第六行的大括号之后需要加逗号<br>上图做了一个示范，其中第一个用户使用 “11383” 的端口，密码是 “paral3”；第二个用户使用“8848” 的端口，密码是“abcdefgh”。如果要添加更多用户，就在第五行后面回车按相同的格式添加就可以了。</p></blockquote><p>完成后 “:wq” 保存退出。</p><h3 id="3-3-运行-SS"><a href="#3-3-运行-SS" class="headerlink" title="3.3 运行 SS"></a>3.3 运行 SS</h3><h4 id="3-3-1-直接输入如下命令并回车"><a href="#3-3-1-直接输入如下命令并回车" class="headerlink" title="3.3.1 直接输入如下命令并回车"></a>3.3.1 直接输入如下命令并回车</h4><p><code>ssserver -c /etc/shadowsocks.json -d start</code></p><p>完成后出来两行字，最后一个单词明明白白告诉你 “started”。</p><h4 id="3-3-2-添加开机启动项，让以后服务器重启之后-SS-会自动开始工作。"><a href="#3-3-2-添加开机启动项，让以后服务器重启之后-SS-会自动开始工作。" class="headerlink" title="3.3.2 添加开机启动项，让以后服务器重启之后 SS 会自动开始工作。"></a>3.3.2 添加开机启动项，让以后服务器重启之后 SS 会自动开始工作。</h4><p>首先键入如下命令并回车</p><p><code>vi /etc/rc.local</code></p><p>在第二行处加入一个空行，</p><p><code>ssserver -c /etc/shadowsocks.json -d start</code></p><p>把我们上面让SS开始工作的命令完整地输入进去。</p><p>然后 “:wq” 保存退出。可以把当前代码窗口关掉啦。</p><h3 id="3-4-打开服务区端口"><a href="#3-4-打开服务区端口" class="headerlink" title="3.4 打开服务区端口"></a>3.4 打开服务区端口</h3><ol><li>首先我们回到 AWS 的网站上登入。和之前一样找到 EC2 进入。</li></ol><ul><li>在右边点击 “实例”，在实例列表中，我们可以看到我们当前正在运行的主机。如果：在实例列表中找不到你的主机的话，先看看右上角区域是不是之前选择的区域。</li><li>将这个列表的滚动条往右拉，出现安全组标签。</li><li>点击我们实例的安全组 “launch-wizard-1”。进入到了实例的安全组设置中。在左下部点击 “入站” 标签页，并点击编辑。</li><li>点击 “添加规则”，添加的规则中“类型”“协议” 都不需要改动。“端口范围”这里填上我们前面设置的端口，“来源”下拉框中选择“任何位置”。</li><li>如果之前有添加多用户的话，需要在这里把所有分配出去的端口都分别添加上去</li><li>保存退出</li></ul><h2 id="客户端配置展开目录"><a href="#客户端配置展开目录" class="headerlink" title="客户端配置展开目录"></a>客户端配置展开目录</h2><p>有了运行在服务器上的服务端，还需要本地的客户端。客户端已经大牛写好了，</p><p>放在 github 上的 <a target="_blank" rel="noopener" href="https://github.com/shadowsocks/shadowsocks/wiki/Ports-and-Clients#os-x">https://github.com/shadowsocks/shadowsocks/wiki/Ports-and-Clients#os-x</a></p><p>可以找对应平台下载，android 可以在 play 商店下载。</p><p>通用设置就是：</p><ol><li>找到服务器选项</li></ol><ul><li>编辑服务器，输入之前记录的公网ip，设置的端口，密码，然后确定</li><li>启用系统代理</li><li>代理方式：自动模式（只有被墙的才会走代理），全局代理（国内网站也会走代理）</li></ul><h2 id="错误记录"><a href="#错误记录" class="headerlink" title="错误记录"></a>错误记录</h2><p>在安装 Shadowsocks 时，使用 pip install 命令出现了下面这个错误：</p><pre><code class="bash"># pip install shadowsocksTraceback (most recent call last):  File &quot;/usr/bin/pip&quot;, line 11, in &lt;module&gt;    sys.exit(main())  File &quot;/usr/lib/python2.7/dist-packages/pip/__init__.py&quot;, line 215, in main    locale.setlocale(locale.LC_ALL, &#39;&#39;)  File &quot;/usr/lib/python2.7/locale.py&quot;, line 581, in setlocale    return _setlocale(category, locale)locale.Error: unsupported locale setting</code></pre><p>其实是语言配置错误导致的，解决方案：</p><p><code>export LC_ALL=C</code></p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShadowScoke </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>canvas 图片合成填坑记</title>
      <link href="/2017-12/canvas-%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90%E5%A1%AB%E5%9D%91%E8%AE%B0/"/>
      <url>/2017-12/canvas-%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90%E5%A1%AB%E5%9D%91%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>在实际开发过程中，经常会接到产品关于分享海报，生成海报，照片合成等需求，这里就简单总结一下。关于一次海报合成的填坑过程，欢迎指正。</p><span id="more"></span><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>要用代码来实现多张外部图片和文字的合并而且要上传到七牛云，再将图片链接通过客户端分享出去。图片背景需要支持用户自定义更换。</p><p><img src="http://cdn.chuyunt.com/uPic/WX20200803-120638@2x.png"></p><h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><p>在一个canvas上多次调用drawImage函数，分别绘制在canvas中，多次之后canvas中是多个图片合并的效果，然后再调用toDataURL函数将canvas转成dataURL格式的图片，再将dataURL格式装换为blob文件，上传至七牛云。</p><h3 id="需要注意的坑"><a href="#需要注意的坑" class="headerlink" title="需要注意的坑"></a>需要注意的坑</h3><h4 id="canvas图片模糊的问题"><a href="#canvas图片模糊的问题" class="headerlink" title="canvas图片模糊的问题"></a>canvas图片模糊的问题</h4><blockquote><p>将canvas的长宽设为样式长宽的2倍或更大， 如下：</p></blockquote><pre><code class="js">var canvas = document.getElementById(&quot;myCanvas&quot;);canvas.width = &quot;600&quot;;canvas.height = &quot;600&quot;canvas.style.height = &quot;300px&quot;canvas.style.height = &quot;300px&quot;</code></pre><h4 id="报安全性错误"><a href="#报安全性错误" class="headerlink" title="报安全性错误"></a>报安全性错误</h4><p>如果你的图片url和页面不在同一域下，在调用toDataURL函数的时候就会报安全性错误。chrome中：</p><p><code>Uncaught SecurityError: Failed to execute ‘toDataURL’ on ‘HTMLCanvasElement’: Tainted canvases may not be exported.</code></p><p>Safari中貌似更严格，根域名相同子域不同依然会报错：</p><p><code>Cross-origin image load denied by Cross-Origin Resource Sharing policy.</code></p><p>原因：</p><p>没有CORS授权虽然可以在 canvas 中使用图像, 但这样做就会污染(taints)画布。 只要 canvas 被污染, 就不能再从画布中提取数据, 也就是说不能再调用 toBlob(), toDataURL() 和 getImageData() 等方法, 否则会抛出安全错误(security error).这实际上是为了保护用户的个人信息,避免未经许可就从远程web站点加载用户的图像信息,造成隐私泄漏。</p><p>解决方法：</p><p>为每个图片创建一个新的img对象，再赋给其src等参数，用这种方式要等到img加载完毕再进行canvas其他操作，在img的load事件处理函数中进行操作，否则可能会绘制出空内容。</p><pre><code class="js">let img = new Image()img.setAttribute(&#39;crossorigin&#39;, &#39;anonymous&#39;)img.src = imgUrlimg.onload = function () &#123;    // do Something&#125;img.error = function () &#123;&#125;</code></pre><p><strong>在mac和pc的浏览器上运行正常，但是在ios11以下的手机内无法toDataURL</strong></p><p>解决办法：</p><ul><li>改变图片的载入方式，先在DOM上新建img标签，如下：</li></ul><pre><code class="html">&lt;img crossOrigin=&quot;Anonymous&quot; id=&quot;bgImg&quot; src=&quot;https://www.test.com/test.png&quot; alt=&quot;&quot;&gt;</code></pre><p><strong>注意：<code>crossOrigin=&quot;Anonymous&quot;</code>一定要在<code>src</code>属性前面</strong></p><blockquote><p>被这个坑了很久</p></blockquote><ul><li>利用js获取img元素</li></ul><pre><code class="js">var img = document.getElementById(&#39;bgImg&#39;)ctx.drawImage(img, 0, 0, 700, 700)</code></pre><h4 id="canvas-toBlob-safari上无效"><a href="#canvas-toBlob-safari上无效" class="headerlink" title="canvas.toBlob() safari上无效"></a>canvas.toBlob() safari上无效</h4><p>解决办法：</p><p>将canvas使用toDataURL方法转为base64,再将base64通过file API 转为 blob</p><pre><code class="js">function dataURLtoBlob (dataurl) &#123; // 将dataUrl 转为 Blob  let arr = dataurl.split(&#39;,&#39;)  let mime = arr[0].match(/:(.*?);/)[1]  let bstr = atob(arr[1])  let n = bstr.length  let u8arr = new Uint8Array(n)  while (n--) &#123;      u8arr[n] = bstr.charCodeAt(n)  &#125;  return new Blob([u8arr], &#123;type: mime&#125;)&#125;var resultBase64 = canvas.toDataURL(&#39;image/jpeg&#39;) // 转为jpeg压缩图片大小var canvasBlob = dataURLtoBlob(resultBase64)</code></pre><p>formData 上传方式</p><pre><code class="js">var formData = new FormData(); formData.append(&quot;file&quot;, document.getElementById(&#39;file&#39;).files[0]); formData.append(&quot;token&quot;, token_value); // 其他参数按这样子加入var xhr = new XMLHttpRequest();xhr.open(&#39;POST&#39;, &#39;/uploadurl&#39;);// 上传完成后的回调函数xhr.onload = function () &#123;  if (xhr.status === 200) &#123;　　console.log(&#39;上传成功&#39;);  &#125; else &#123;  　console.log(&#39;上传出错&#39;);  &#125;&#125;;// 获取上传进度xhr.upload.onprogress = function (event) &#123;  if (event.lengthComputable) &#123;    var percent = Math.floor(event.loaded / event.total * 100) ;    // 设置进度显示    $(&quot;#J_upload_progress&quot;).progress(&#39;set progress&#39;, percent);  &#125;&#125;;xhr.send(formData);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云服务之ngnix安装配置</title>
      <link href="/2017-05/%E4%BA%91%E6%9C%8D%E5%8A%A1%E4%B9%8Bngnix%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
      <url>/2017-05/%E4%BA%91%E6%9C%8D%E5%8A%A1%E4%B9%8Bngnix%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>在项目开发中需要自己搭建配置前端服务，发布代码，所以捣鼓了一下 nginx。在这里记录一下，相应的常规配置。Nginx 是一款轻量级的网页服务器、反向代理服务器。相较于 Apache、lighttpd 具有占有内存少，稳定性高等优势。它最常的用途是提供反向代理服务。</p><span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>各自优点</li></ul><p>安装 nginx 有两种方法，方法一是 ECS 服务器在线 yum 安装，方法二是下载并上传到 ECS 服务器编译安装。方法一安装是在线安装，好处是：安装方式简单，不易出错；方法二安装是先将 nginx 的源码下载下来，在自己的系统里编译生成可执行文件，然后执行，好处是：因为是在自己的系统上编译的，更符合自己系统的性能，也就是说在自己的系统上执行 nginx 服务性能效率更好。</p><ul><li>他们之间最大的区别是 ：<code>安装位置不同</code>。</li></ul><p>yum 在线安装会将 nginx 的安装文件放在系统的不同位置，可以通过命令 <code>rpm -ql nginx</code> 来查看安装路径。卸载的时候，只能通过 命令来卸载，因为我们不可能 将这些文件自己手动删除，可以通过命令 rpm -e nginx 来卸载，这个命令一般不会报错，因为 nginx 不与其他的包有依赖关系，如果提示关于 依赖包的问题 ，可以尝试 rpm -e –nodeps nginx 来卸载，这个命令相当于强制卸载，不考虑依赖问题。</p><p>源码包 安装他的所有文件（包括配置文件，库文件，资源文件等）都在同一个目录下，我们想卸载的时候，直接将这个文件删除就可以，不会有任何垃圾文件存在。<br>通过源码包编译安装的软件，通常都放在 /usr/local/包名 路径下。</p><ul><li>启动方式不同</li></ul><p>yum 安装 nginx，我们可以通过 系统服务命令 service 来启动或停止</p><pre><code class="shell">service nginx start #启动 nginx 服务service nginx stop #停止 nginx 服务service nginx restart #重启 nginx 服务</code></pre><p>源码包 安装 nginx 启动的时候不能使用 service 来启动，需要执行 nginx 安装目录下的 sbin 目录下的 nginx 可执行程序才行，如下（我的 nginx 安装在 /usr/local/webserver/ 目录下）</p><pre><code class="shell">/usr/local/webserver/nginx/sbin/nginx           #启动 nginx 服务/usr/local/webserver/nginx/sbin/nginx -s stop   #停止 nginx 服务</code></pre><p>或者 直接进入安装目录 ，执行 ./nginx 也可以，这两种方式其实是一样的，. 表示当前目录</p><pre><code class="shell">cd /usr/local/webserver/nginx/sbin./nginx           #启动 nginx 服务./nginx -s stop   #停止 nginx 服务</code></pre><h3 id="yum-在线安装"><a href="#yum-在线安装" class="headerlink" title="yum 在线安装"></a>yum 在线安装</h3><ul><li>如果是刚买的服务器 先执行<code>yum -y update</code>,把 yum 更新到最新版本</li><li>yum 使用 yum 安装是在线安装，直接使用命令 <code>yum -y install nginx</code> 安装即可</li><li>执行 <code>nginx</code> 来启动 nginx 服务</li></ul><h3 id="源码包-安装"><a href="#源码包-安装" class="headerlink" title="源码包 安装"></a>源码包 安装</h3><p>以下命令均需 root 权限执行：首先安装必要的库（nginx 中 gzip 模块需要 zlib 库，rewrite 模块需要 pcre 库，ssl 功能需要 openssl 库）。选定/usr/local 为安装目录，以下具体版本号根据实际改变。</p><ul><li>安装依赖</li></ul><pre><code class="shell">yum -y install gcc gcc-c++ make libtool zlib zlib-devel openssl openssl-devel pcre pcre-devel</code></pre><ul><li>安装 nginx</li></ul><pre><code class="shell">cd /usr/local/wget http://nginx.org/download/nginx-1.13.0.tar.gztar -zxvf nginx-1.13.0.tar.gzcd nginx-1.13.0./configure --prefix=/usr/local/nginx\ --with-http_stub_status_module\ --with-http_ssl_module\ --with-pcre\ --with-zlibmake&amp;&amp;make install/usr/local/nginx/sbin/nginx -v</code></pre><ul><li>启动</li></ul><p><code>/usr/local/nginx/sbin/nginx</code></p><p>检查是否启动成功，如何出现错误详见下文：</p><p>打开浏览器访问此机器的 IP，如果浏览器出现 Welcome to nginx! 则表示 Nginx 已经安装并运行成功。</p><ul><li>其他命令如下：</li></ul><p>重启： <code>/usr/local/nginx/sbin/nginx –s reload</code></p><p>停止： <code>/usr/local/nginx/sbin/nginx –s stop</code></p><p>测试配置文件是否正常： <code>/usr/local/nginx/sbin/nginx –t</code></p><p>强制关闭： <code>pkill nginx</code></p><h2 id="Nignx-配置"><a href="#Nignx-配置" class="headerlink" title="Nignx 配置"></a>Nignx 配置</h2><p>nginx 的配置文件根据你的安装方式，会在不同的文件夹下。如果使用在线 yum 安装，配置文件在<code>/etc/nginx</code>。默认配置文件已经被按模块分开了，所以只要在 default.d 或 conf.d 内新建一个.conf 结尾的文件填写你的 server 配置就可以了。</p><p>如果使用源码安装，则配置文件在你安装目录下，比如我的<code>/usr/local/nginx/conf/nginx.conf</code>，这里的配置文件是完整的，可以根据自己的需求对配置文件进行分离。</p><pre><code>&#123;    base   # 基本配置    events: &#123;&#125;    http: &#123;        base # 基本配置        server: &#123;            main            location: &#123;&#125;        &#125;    &#125;&#125;</code></pre><p>最外面的块是 base; base 包含 events 和 http; http 包含 upstream 和多个 server; server 又包含多个 location;</p><ul><li>base 块设置的指令将影响其他所有设置，相当于全局设置</li><li>server 块的指令主要用于指定主机和端口，设置网站，例如虚拟主机</li><li>upstream 指令主要用于负载均衡，设置一系列的后端服务器</li><li>location 块用于匹配网页位置，就是匹配网页的路径，匹配到的路径可以做一些事情，例如反代</li></ul><p>这四者之间的关系式：server 继承 base，location 继承 server，upstream 既不会继承其他设置也不会被继承。在这四个部分当中，每个部分都包含若干指令，这些指令主要包含 Nginx 的主模块指令、事件模块指令、HTTP 核心模块指令，同时每个部分还可以使用其他 HTTP 模块指令，例如 Http SSL 模块、HttpGzip Static 模块和 Http Addition 模块等。</p><h3 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h3><pre><code class="shell"># 定义Nginx运行的用户和用户组user www www;# nginx进程数，建议设置为等于CPU总核心数。worker_processes 1;# 全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]error_log /var/log/nginx/error.log info;# 进程文件pid /var/run/nginx.pid;# 一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除，但是nginx分配请求并不均匀，所以建议与ulimit -n的值保持一致。worker_rlimit_nofile 65535;# 工作模式与连接数上限events&#123;    # 参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型。    use epoll;    # 单个进程最大连接数（最大连接数=连接数*进程数）    worker_connections 65535;&#125;# 设定http服务器http&#123;    include mime.types; #文件扩展名与文件类型映射表    default_type application/octet-stream; #默认文件类型    charset utf-8; #默认编码    server_names_hash_bucket_size 128; #服务器名字的hash表大小    client_header_buffer_size 32k; #上传文件大小限制    large_client_header_buffers 4 64k; #设定请求缓    client_max_body_size 8m; #设定请求缓    sendfile on; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。    autoindex on; #开启目录列表访问，合适下载服务器，默认关闭。    tcp_nopush on; #防止网络阻塞    tcp_nodelay on; #防止网络阻塞    keepalive_timeout 120; #长连接超时时间，单位是秒    #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。    fastcgi_connect_timeout 300;    fastcgi_send_timeout 300;    fastcgi_read_timeout 300;    fastcgi_buffer_size 64k;    fastcgi_buffers 4 64k;    fastcgi_busy_buffers_size 128k;    fastcgi_temp_file_write_size 128k;    #gzip模块设置    gzip on; #开启gzip压缩输出    gzip_min_length 1k; #最小压缩文件大小    gzip_buffers 4 16k; #压缩缓冲区    gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）    gzip_comp_level 2; #压缩等级    gzip_types text/plain application/x-javascript text/css application/xml;    #压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。    gzip_vary on;    limit_zone crawler $binary_remote_addr 10m; #开启限制IP连接数的时候需要使用    upstream blog.ha97.com &#123;    #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。    server 192.168.80.121:80 weight=3;    server 192.168.80.122:80 weight=2;    server 192.168.80.123:80 weight=3;    &#125;    #虚拟主机的配置    server&#123;        #监听端口        listen 80;        #域名可以有多个，用空格隔开        server_name www.ha97.com ha97.com;        index index.html index.htm index.php;        root /data/www/ha97;        location ~ .*\.(php|php5)?$ &#123;            fastcgi_pass 127.0.0.1:9000;            fastcgi_index index.php;            include fastcgi.conf;        &#125;        #图片缓存时间设置        location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$ &#123;            expires 10d;        &#125;        #JS和CSS缓存时间设置        location ~ .*\.(js|css)?$ &#123;            expires 1h;        &#125;        #日志格式设定        log_format access &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;        &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;        &#39;&quot;$http_user_agent&quot; $http_x_forwarded_for&#39;;        #定义本虚拟主机的访问日志        access_log /var/log/nginx/ha97access.log access;        #对 &quot;/&quot; 启用反向代理        location / &#123;            proxy_pass http://127.0.0.1:88;            proxy_redirect off;            proxy_set_header X-Real-IP $remote_addr;            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            #以下是一些反向代理的配置，可选。            proxy_set_header Host $host;            client_max_body_size 10m; #允许客户端请求的最大单文件字节数            client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数，            proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时)            proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时)            proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时)            proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小            proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的设置            proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2）            proxy_temp_file_write_size 64k;            #设定缓存文件夹大小，大于这个值，将从upstream服务器传        &#125;        #设定查看Nginx状态的地址        location /NginxStatus &#123;            stub_status on;            access_log on;            auth_basic &quot;NginxStatus&quot;;            auth_basic_user_file conf/htpasswd;            #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。        &#125;        #本地动静分离反向代理配置        #所有jsp的页面均交由tomcat或resin处理        location ~ .(jsp|jspx|do)?$ &#123;            proxy_set_header Host $host;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            proxy_pass http://127.0.0.1:8080;        &#125;        #所有静态文件由nginx直接读取不经过tomcat或resin        location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$ &#123;            expires 15d;        &#125;        location ~ .*.(js|css)?$ &#123;            expires 1h;        &#125;    &#125;&#125;</code></pre><h3 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h3><ul><li>配置静态页面</li></ul><pre><code class="shell">server &#123;    listen       80;    server_name  test.lion1ou.win;    location / &#123;        root   /home/lion1ou/dist; # 静态文件地址        index  index.html index.htm; # 指定首页    &#125;    error_page  404              /404.html;    error_page   500 502 503 504  /50x.html;    location = /50x.html &#123;        root   html;    &#125;     #charset koi8-r;    access_log  logs/lion1ou.access.log;&#125;</code></pre><ul><li>配置 web 服务</li></ul><pre><code class="shell">server &#123;    listen 80;    server_name test1.lion1ou.win;    location /&#123;        proxy_redirect off;        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_pass http://127.0.0.1:8080;    &#125;    access_log logs/8080_access.log;&#125;</code></pre><h2 id="配置-HTTPS"><a href="#配置-HTTPS" class="headerlink" title="配置 HTTPS"></a>配置 HTTPS</h2><h3 id="SSL-证书介绍"><a href="#SSL-证书介绍" class="headerlink" title="SSL 证书介绍"></a>SSL 证书介绍</h3><p>SSL 证书是一种数字证书，它使用 Secure Socket Layer 协议在浏览器和 Web 服务器之间建立一条安全通道，从而实现：</p><ol><li>数据信息在客户端和服务器之间的加密传输，保证双方传递信息的安全性，不可被第三方窃听；</li><li>用户可以通过服务器证书验证他所访问的网站是否真实可靠。</li></ol><p>HTTPS 是以安全为目标的 HTTP 通道，即 HTTP 下加入 SSL 加密层。HTTPS 不同于 HTTP 的端口，HTTP 默认端口为 80，HTTPS 默认端口为 443。</p><h3 id="申请-SSL-证书-已失效"><a href="#申请-SSL-证书-已失效" class="headerlink" title="申请 SSL 证书(已失效)"></a>申请 SSL 证书(已失效)</h3><ul><li><p>进入阿里云控制台，“安全（云盾）”下的“证书服务”，点击购买证书，选择免费型 DV SSL，按提示走就可以，反正不用花钱的。</p></li><li><p>接下来到我的订单页面，看到证书状态是“待完成”，点击“补全”链接，根据提示完成操作，在上传相关信息时，一般选择<code>系统生成</code>。<br><img src="http://cdn.chuyunt.com/uPic/006tNbRwgy1fgdmbplogfj30u5077mx8.jpg"></p></li><li><p>然后等验证通过，一般十几二十分钟就 OK</p></li><li><p>然后下载证书，选择 nginx<br><img src="http://cdn.chuyunt.com/uPic/006tNbRwgy1fgdm7pqa91j30tm0amweh.jpg"></p></li><li><p>将下载下来的证书解压，里面有两个文件一个是.key，另一个是.pem，把这两个文件传到服务器的一个目录中。</p></li><li><p>配置 nginx 配置文件，重启 nginx 即可</p></li></ul><h3 id="配置-https"><a href="#配置-https" class="headerlink" title="配置 https"></a>配置 https</h3><pre><code class="shell">server&#123;    listen 443;    server_name www.lion1ou.com;    ssl on;    root /home/lion1ou/dist;    index index.html index.htm;    ssl_certificate   /home/lion1ou/cert/214128084570320.pem;    ssl_certificate_key  /home/lion1ou/cert/214128084570320.key;    ssl_session_timeout 5m;    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    ssl_prefer_server_ciphers on;    # error_page 497 &quot;https://$host$uri?$args&quot;;  # 这是跳转Http请求到Https    location / &#123;        root /home/lion1ou/dist;        index index.html index.htm;    &#125;&#125;</code></pre><h3 id="将-http-重定向到-https"><a href="#将-http-重定向到-https" class="headerlink" title="将 http 重定向到 https"></a>将 http 重定向到 https</h3><pre><code class="shell">server &#123;     listen 80;     server_name www.chuyunt.com;     rewrite ^/(.*) https://$server_name$1 permanent;    #用于http重定向到Https&#125;</code></pre><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li><p>通过重定向跳转到 https 时，浏览器上会出现多次重定向，需要删除缓存才能访问的问题。</p><p>现这个问题没有解决，有解决办法的同学，可以留言告诉我。</p></li><li><p>在 Centos7 上编译安装 openssl 后，运行 openssl version 出现如下错误：</p></li></ol><pre><code class="shell">/usr/local/nginx/sbin/nginx: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory</code></pre><p>这是由于 openssl 库的位置不正确造成的。</p><p>解决方法：</p><p>在 root 用户下执行：</p><pre><code class="shell">ln -s /usr/local/lib64/libssl.so.1.1 /usr/lib64/libssl.so.1.1ln -s /usr/local/lib64/libcrypto.so.1.1 /usr/lib64/libcrypto.so.1.1</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云服务之nodejs进程管理</title>
      <link href="/2017-05/%E4%BA%91%E6%9C%8D%E5%8A%A1%E4%B9%8Bnodejs%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2017-05/%E4%BA%91%E6%9C%8D%E5%8A%A1%E4%B9%8Bnodejs%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>运行 node 服务时，如果直接通过 node app 来启动，如果报错了，整个服务就会直接停止运行。所以开发时和在服务器运行时，需要一个进程管理的工具，一般有 forever，pm2，supervisor 这几种。</p><span id="more"></span><p>分别的使用场合:</p><ul><li>supervisor 监听文件变化，会重启服务，适用于开发调试阶段。</li><li>forever 管理多个站点，每个站点访问量不大，不需要监控。</li><li>pm2 网站访问量比较大,需要完整的监控界面。</li></ul><h2 id="supervisor"><a href="#supervisor" class="headerlink" title="supervisor"></a><a target="_blank" rel="noopener" href="https://github.com/petruisfan/node-supervisor/">supervisor</a></h2><p>主要特性：</p><ul><li>默认监控所有文件、文件夹的变化的；一旦有变化，服务就会重启</li></ul><pre><code class="shell"># 安装npm install -g supervisor# 运行supervisor myapp</code></pre><h2 id="PM2"><a href="#PM2" class="headerlink" title="PM2"></a><a target="_blank" rel="noopener" href="https://pm2.keymetrics.io/">PM2</a></h2><p>主要特性:</p><ul><li>内建负载均衡（使用 Node cluster 集群模块）</li><li>后台运行</li><li>0 秒停机重载，我理解大概意思是维护升级的时候不需要停机.</li><li>具有 Ubuntu 和 CentOS 的启动脚本</li><li>停止不稳定的进程（避免无限循环）</li><li>控制台检测</li><li>提供 HTTP API</li><li>远程控制和实时的接口 API ( Nodejs 模块,允许和 PM2 进程管理器交互 )</li></ul><pre><code class="shell"># 安装npm install -g pm2# 用法$ npm install -g pm2      # 命令行全局安装pm2$ pm2 start app.js        # 启动app项目$ pm2 list                # 列出由pm2管理的所有进程信息，还会显示一个进程会被启动多少次，因为没处理的异常。# 其他命令$ pm2 monit               # 监视每个node进程的CPU和内存的使用情况$ pm2 logs                # 显示所有进程日志$ pm2 stop all            # 停止所有进程$ pm2 restart all         # 重启所有进程$ pm2 reload all          # 0秒停机重载进程 (用于 NETWORKED 进程)$ pm2 stop 0              # 停止指定的进程$ pm2 restart 0           # 重启指定的进程$ pm2 startup             # 产生 init 脚本 保持进程活着$ pm2 web                 # 运行健壮的 computer API endpoint (http://localhost:9615)$ pm2 delete 0            # 杀死指定的进程$ pm2 delete all          # 杀死全部进程# 运行进程的不同方式$ pm2 start app.js -i max                         # 根据有效CPU数目启动最大进程数目$ pm2 start app.js -i 3                           # 启动3个进程$ pm2 start app.js -x                             # 用fork模式启动 app.js 而不是使用 cluster$ pm2 start app.js -x -- -a 23                    # 用fork模式启动 app.js 并且传递参数 (-a 23)$ pm2 start app.js --name serverone               # 启动一个进程并把它命名为 serverone$ pm2 stop serverone                              # 停止 serverone 进程$ pm2 start app.json                              # 启动进程, 在 app.json里设置选项$ pm2 start app.js -i max -- -a 23                # 在--之后给 app.js 传递参数$ pm2 start app.js -i max -e err.log -o out.log   # 启动 并 生成一个配置文件</code></pre><p>pm2 相关文档：<a target="_blank" rel="noopener" href="https://wohugb.gitbooks.io/pm2/content/">https://wohugb.gitbooks.io/pm2/content/</a></p><h2 id="forever"><a href="#forever" class="headerlink" title="forever"></a>forever</h2><p>官方的说明是说：A simple CLI tool for ensuring that a given script runs continuously（一个用来持续（或者说永远）运行一个给定脚本的简单的命令行工具）。Github 地址：<a target="_blank" rel="noopener" href="https://github.com/nodejitsu/forever">https://github.com/nodejitsu/forever</a></p><pre><code class="shell"># 安装# 记得加-g，forever要求安装到全局环境下sudo npm install forever -g# 启动# 1. 简单的启动forever start app.js# 2. 指定forever信息输出文件，当然，默认它会放到~/.forever/forever.logforever start -l forever.log app.js# 3. 指定app.js中的日志信息和错误日志输出文件，#  -o 就是console.log输出的信息，-e 就是console.error输出的信息forever start -o out.log -e err.log app.js# 4. 追加日志，forever默认是不能覆盖上次的启动日志，#  所以如果第二次启动不加-a，则会不让运行forever start -l forever.log -a app.js# 5. 监听当前文件夹下的所有文件改动forever start -w app.js# 文件改动监听并自动重启# 1. 监听当前文件夹下的所有文件改动（不太建议这样）forever start -w app.js# 显示所有运行的服务forever list# 停止操作# 1. 停止所有运行的node Appforever stopall# 2. 停止其中一个node Appforever stop app.js# 当然还可以这样# forever list 找到对应的id，然后：forever stop [id]# 重启# 1. 启动所有，重启操作跟停止操作保持一致。forever restartall</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeJs </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云服务之Linux常用命令</title>
      <link href="/2017-04/%E4%BA%91%E6%9C%8D%E5%8A%A1%E4%B9%8Blinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2017-04/%E4%BA%91%E6%9C%8D%E5%8A%A1%E4%B9%8Blinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>最近买了一台学生阿里云的服务器，开始建一个属于自己的小网站和一些项目 demo，所以开始了解 Linux 系统的相关知识和相关使用，入门第一步当然是命令行操作了，下面记录了一些常用的命令语句。</p><span id="more"></span><h2 id="Mac-链接操作-Linux-服务器"><a href="#Mac-链接操作-Linux-服务器" class="headerlink" title="Mac 链接操作 Linux 服务器"></a>Mac 链接操作 Linux 服务器</h2><h3 id="SCP-命令"><a href="#SCP-命令" class="headerlink" title="SCP 命令"></a>SCP 命令</h3><p>copy 本地文件到服务器的命令如下：</p><p>scp <code>local file</code> <code>remote user</code>@<code>remote machine</code>:<code>remote path</code></p><p>如果想 Copy 远程文件到本地，则是：</p><p>scp <code>remote user</code>@<code>remote machine</code>:<code>remote path</code> <code>local file</code></p><h3 id="ssh-命令"><a href="#ssh-命令" class="headerlink" title="ssh 命令"></a>ssh 命令</h3><ol><li>ssh 主机</li></ol><p><code>ssh 192.168.1.155</code><br>（表示用电脑用户登录到服务器）</p><ol start="2"><li>ssh 用户@主机</li></ol><p><code>ssh user1@192.168.1.155</code><br>（表示用 user1 登录到服务器）</p><ol start="3"><li>ssh 主机 -l 用户名 -p 端口</li></ol><p><code>ssh 192.168.1.155 -l user2 -p 8080</code><br>（表示 user2 用户用 8080 端口连接到 192.168.1.155 的服务器）</p><h3 id="Linux-防火墙的关闭和开启"><a href="#Linux-防火墙的关闭和开启" class="headerlink" title="Linux 防火墙的关闭和开启"></a>Linux 防火墙的关闭和开启</h3><ol><li>重启后生效</li></ol><p>开启： chkconfig iptables on<br>关闭： chkconfig iptables off</p><ol start="2"><li>即时生效，重启后失效</li></ol><p>开启： service iptables start<br>关闭： service iptables stop</p><p>需要说明的是对于 Linux 下的其它服务都可以用以上命令执行开启和关闭操作。</p><h2 id="cd-命令"><a href="#cd-命令" class="headerlink" title="cd 命令"></a>cd 命令</h2><blockquote><p>用于切换当前目录，参数是要切换到的目录的路径，可以是绝对路径，也可以是相对路径。</p></blockquote><pre><code class="shell">cd /root/Docements # 切换到目录/root/Docementscd ./path          # 切换到当前目录下的path目录中，“.”表示当前目录cd ../path         # 切换到上层目录中的path目录中，“..”表示上一层目录</code></pre><h2 id="ls-命令"><a href="#ls-命令" class="headerlink" title="ls 命令"></a>ls 命令</h2><blockquote><p>查看文件与目录的命令，以下为常用参数。</p></blockquote><pre><code>ls -l   # 列出长数据串，包含文件的属性与权限数据等ls -a   # 列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来（常用）ls -d   # 仅列出目录本身，而不是列出目录的文件数据ls -h   # 将文件容量以较易读的方式（GB，kB等）列出来ls -R   # 连同子目录的内容一起列出（递归列出），等于该目录下的所有文件都会显示出来</code></pre><p>可以组合使用</p><pre><code>ls -l   # 以长数据串的形式列出当前目录下的数据文件和目录ls -lR  # 以长数据串的形式列出当前目录下的所有文件</code></pre><h2 id="mkdir-命令"><a href="#mkdir-命令" class="headerlink" title="mkdir 命令"></a>mkdir 命令</h2><blockquote><p>mkdir 命令用来创建指定的名称的目录，要求创建目录的用户在当前目录中具有写权限，并且指定的目录名不能是当前目录中已有的目录。</p></blockquote><pre><code>-m  --mode   模式，设定权限&lt;模式&gt; (类似 chmod)-p  --parents  可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录;-v  --verbose  每次创建新目录都显示信息    --help   显示此帮助信息并退出    --version  输出版本信息并退出</code></pre><p>实例</p><pre><code>mkdir test1             # 创建一个空目录mkdir -p test2/test22   # 递归创建多个目录mkdir -m 777 test3      # 创建权限为777的目录mkdir -v test4          # 创建新目录都显示信息mkdir -vp scf/&#123;lib/,bin/,doc/&#123;info,product&#125;,logs/&#123;info,product&#125;,service/deploy/&#123;info,product&#125;&#125;# 一个命令创建项目的目录结构</code></pre><h2 id="cp-命令"><a href="#cp-命令" class="headerlink" title="cp 命令"></a>cp 命令</h2><blockquote><p>该命令用于复制文件，copy 之意，它还可以把多个文件一次性地复制到一个目录下。</p></blockquote><pre><code class="shell">cp -a  # 将文件的特性一起复制cp -p  # 连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份cp -i  # 若目标文件已经存在时，在覆盖时会先询问操作的进行cp -r  # 递归持续复制，用于目录的复制行为cp -u  # 目标文件与源文件有差异时才会复制# 栗子cp -a file1 file2 #连同文件的所有特性把文件file1复制成文件file2cp file1 file2 file3 dir #把文件file1、file2、file3复制到目录dir中</code></pre><h2 id="mv-命令"><a href="#mv-命令" class="headerlink" title="mv 命令"></a>mv 命令</h2><blockquote><p>该命令用于移动文件、目录或更名，move 之意，它的常用参数如下：</p></blockquote><pre><code class="shell">mv -f  # force强制的意思，如果目标文件已经存在，不会询问而直接覆盖mv -i  # 若目标文件已经存在，就会询问是否覆盖mv -u  # 若目标文件已经存在，且比目标文件新，才会更新# 栗子mv file1 file2 file3 dir # 把文件file1、file2、file3移动到目录dir中mv file1 file2 # 把文件file1重命名为file2</code></pre><p>注：该命令可以把一个文件或多个文件一次移动一个文件夹中，但是最后一个目标文件一定要是“目录”。</p><h2 id="rm-命令"><a href="#rm-命令" class="headerlink" title="rm 命令"></a>rm 命令</h2><blockquote><p>该命令用于删除文件或目录。</p></blockquote><pre><code class="shell">rm -f  # 就是force的意思，忽略不存在的文件，不会出现警告消息rm -i  # 互动模式，在删除前会询问用户是否操作rm -r  # 递归删除，最常用于目录删除，它是一个非常危险的参数# 栗子rm -i file  # 删除文件file，在删除之前会询问是否进行该操作rm -fr dir  # 强制删除目录dir中的所有文件</code></pre><h2 id="ps-命令"><a href="#ps-命令" class="headerlink" title="ps 命令"></a>ps 命令</h2><p>该命令用于将某个时间点的进程运行情况选取下来并输出，process 之意，它的常用参数如下：</p><pre><code class="shell">-A ：所有的进程均显示出来-a ：不与terminal有关的所有进程-u ：有效用户的相关进程-x ：一般与a参数一起使用，可列出较完整的信息-l ：较长，较详细地将PID的信息列出其实我们只要记住ps一般使用的命令参数搭配即可，它们并不多，如下：ps aux # 查看系统所有的进程数据ps ax # 查看不与terminal有关的所有进程ps -lA # 查看系统所有的进程数据ps axjf # 查看连同一部分进程树状态</code></pre><h2 id="kill-命令"><a href="#kill-命令" class="headerlink" title="kill 命令"></a>kill 命令</h2><blockquote><p>该命令用于向某个工作（%jobnumber）或者是某个 PID（数字）传送一个信号，它通常与 ps 和 jobs 命令一起使用。</p></blockquote><pre><code class="shell">kill -signal PID</code></pre><p>signal 的常用参数如下：注：最前面的数字为信号的代号，使用时可以用代号代替相应的信号。</p><pre><code class="shell">1：SIGHUP，启动被终止的进程2：SIGINT，相当于输入ctrl+c，中断一个程序的进行9：SIGKILL，强制中断一个进程的进行15：SIGTERM，以正常的结束进程方式来终止进程17：SIGSTOP，相当于输入ctrl+z，暂停一个进程的进行# 栗子# 以正常的结束进程方式来终于第一个后台工作，可用jobs命令查看后台中的第一个工作进程kill -SIGTERM %1# 重新改动进程ID为PID的进程，PID可用ps命令通过管道命令加上grep命令进行筛选获得kill -SIGHUP PID</code></pre><h2 id="killall-命令"><a href="#killall-命令" class="headerlink" title="killall 命令"></a>killall 命令</h2><blockquote><p>该命令用于向一个命令启动的进程发送一个信号。</p></blockquote><pre><code class="shell">killall [-iIe] [command name]它的参数如下：-i ：交互式的意思，若需要删除时，会询问用户-e ：表示后面接的command name要一致，但command name不能超过15个字符-I ：命令名称忽略大小写# 例如：killall -SIGHUP syslogd # 重新启动syslogd</code></pre><h2 id="tar-命令"><a href="#tar-命令" class="headerlink" title="tar 命令"></a>tar 命令</h2><blockquote><p>该命令用于对文件进行打包，默认情况并不会压缩，如果指定了相应的参数，它还会调用相应的压缩程序（如 gzip 和 bzip 等）进行压缩和解压。</p></blockquote><pre><code class="shell">-c ：新建打包文件-t ：查看打包文件的内容含有哪些文件名-x ：解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中-j ：通过bzip2的支持进行压缩/解压缩-z ：通过gzip的支持进行压缩/解压缩-v ：在压缩/解压缩过程中，将正在处理的文件名显示出来-f filename ：filename为要处理的文件-C dir ：指定压缩/解压缩的目录dir# 上面的解说可以已经让你晕过去了，但是通常我们只需要记住下面三条命令即可：tar -jcv -f filename.tar.bz2 要被处理的文件或目录名称  # 压缩tar -jtv -f filename.tar.bz2  # 查询tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录  # 解压# 注：文件名并不定要以后缀tar.bz2结尾，这里主要是为了说明使用的压缩程序为bzip2</code></pre><h2 id="chmod-命令"><a href="#chmod-命令" class="headerlink" title="chmod 命令"></a>chmod 命令</h2><blockquote><p>该命令用于改变文件的权限，一般的用法如下：</p></blockquote><pre><code class="shell">chmod [-R] xyz 文件或目录-R：进行递归的持续更改，即连同子目录下的所有文件都会更改同时，chmod还可以使用u（user）、g（group）、o（other）、a（all）和+（加入）、-（删除）、=（设置）跟rwx搭配来对文件的权限进行更改。# 例如：chmod 0755 file # 把file的文件权限改变为-rxwr-xr-xchmod g+w file # 向file的文件权限中加入用户组可写权限</code></pre><h2 id="vim-命令"><a href="#vim-命令" class="headerlink" title="vim 命令"></a>vim 命令</h2><p>该命令主要用于文本编辑，它接一个或多个文件名作为参数，如果文件存在就打开，如果文件不存在就以该文件名创建一个文件。</p><ul><li>输入“i”，进入编辑模式</li><li>使用“Esc”按钮，退出编辑模式</li><li>输入“:wq”，回车，保存文件内容并退出</li></ul><h2 id="find-命令"><a href="#find-命令" class="headerlink" title="find 命令"></a>find 命令</h2><blockquote><p>find 是一个基于查找的功能非常强大的命令.</p></blockquote><pre><code class="shell">find [PATH] [option] [action]# 与时间有关的参数：find . -mtime n   # n为数字，意思为在n天之前的“一天内”被更改过的文件；find . -mtime +n   # 列出在n天之前（不含n天本身）被更改过的文件名；find . -mtime -n   # 列出在n天之内（含n天本身）被更改过的文件名；find . -newer file   # 列出比file还要新的文件名# 例如：find /root -mtime 0 # 在当前目录下查找今天之内有改动的文件# 与用户或用户组名有关的参数：find . -user name   # 列出文件所有者为name的文件find . -group name   # 列出文件所属用户组为name的文件find . -uid n   # 列出文件所有者为用户ID为n的文件find . -gid n   # 列出文件所属用户组为用户组ID为n的文件# 例如：find /home/ljianhui -user ljianhui # 在目录/home/ljianhui中找出所有者为ljianhui的文件# 与文件权限及名称有关的参数：find . -name filename  # 找出文件名为filename的文件find . -size [+-]SIZE  # 找出比SIZE还要大（+）或小（-）的文件find . -tpye TYPE  # 查找文件的类型为TYPE的文件，TYPE的值主要有 # 一般文件（f)、设备文件（b、c）、目录（d）、连接文件（l）、socket（s）、FIFO管道文件（p）；find . -perm mode  # 查找文件权限刚好等于mode的文件，mode用数字表示，如0755；find . -perm -mode  # 查找文件权限必须要全部包括mode权限的文件，mode用数字表示find . -perm +mode  # 查找文件权限包含任一mode的权限的文件，mode用数字表示# 例如：find / -name passwd # 查找文件名为passwd的文件find . -perm 0755 # 查找当前目录中文件权限的0755的文件find . -size +12k # 查找当前目录中大于12KB的文件，注意c表示byte</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的工作原理</title>
      <link href="/2017-02/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>/2017-02/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>浏览器的主要功能是将用户选择得web资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是HTML，也包括PDF、image及其他格式。用户用URI（Uniform Resource Identifier 统一资源标识符）来指定所请求资源的位置。</p><span id="more"></span><h2 id="浏览器主要构成："><a href="#浏览器主要构成：" class="headerlink" title="浏览器主要构成："></a>浏览器主要构成：</h2><ul><li>用户界面————包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分</li><li>浏览器引擎————用来查询及操作渲染引擎的接口</li><li>渲染引擎————用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来</li><li>网络————用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作</li><li>UI后端————用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口</li><li>JS解释器————用来解释执行JS代码</li><li>数据存储————属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术</li></ul><p><img src="http://cdn.chuyunt.com/uPic/006tNc79ly1fdniynfby8j30dw09f0tk.jpg"></p><h2 id="常用那几种浏览器测试？有哪些内核-Layout-Engine"><a href="#常用那几种浏览器测试？有哪些内核-Layout-Engine" class="headerlink" title="常用那几种浏览器测试？有哪些内核(Layout Engine)?"></a>常用那几种浏览器测试？有哪些内核(Layout Engine)?</h2><p>Ie(Ie内核) 火狐（Gecko） Safari，谷歌（webkit） opear(Presto)</p><h2 id="浏览器的基本流程"><a href="#浏览器的基本流程" class="headerlink" title="浏览器的基本流程"></a>浏览器的基本流程</h2><p>解析html以构建dom树-&gt;解析CSS转化为CSSOM(CSS Object Model)-&gt;构建render树-&gt;布局render树-&gt;绘制render树</p><p><img src="http://cdn.chuyunt.com/uPic/006tNc79ly1fdniz86rwcj30hi084q32.jpg"></p><ol><li>渲染引擎开始解析html，并将标签转化为内容树中的dom节点。</li><li>解析外部CSS文件及style标签中的样式信息。</li><li>这些样式信息以及html中的可见性指令将被用来构建另一棵树——render树。(Render树由一些包含有颜色和大小等属性的矩形组成，它们将被按照正确的顺序显示到屏幕上。)</li><li>Render树构建好了之后，将会执行布局过程，它将确定每个节点在屏幕上的确切坐标。</li><li>绘制，即遍历render树，并使用UI后端层绘制每个节点。</li></ol><p>值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p><p><img src="http://cdn.chuyunt.com/uPic/006tNc79gy1fdnizs50rvj30hc081754.jpg" alt="webkit主流程"></p><p><img src="http://cdn.chuyunt.com/uPic/006tNc79gy1fdnj083n8gj30hc082dg2.jpg" alt="Geoko主流程"></p><p>尽管webkit和Gecko使用的术语稍有不同，他们的主要流程基本相同。Gecko称可见的格式化元素组成的树为frame树，每个元素都是一个frame，webkit则使用render树这个名词来命名由渲染对象组成的树。Webkit中元素的定位称为布局，而Gecko中称为回流。Webkit称利用dom节点及样式信息去构建render树的过程为attachment，Gecko在html和dom树之间附加了一层，这层称为内容接收器，相当制造dom元素的工厂。</p><h2 id="重排（reflow）和重绘（repaint）"><a href="#重排（reflow）和重绘（repaint）" class="headerlink" title="重排（reflow）和重绘（repaint）"></a>重排（reflow）和重绘（repaint）</h2><p>网页生成的时候，至少会渲染一次。用户访问的过程中，还会不断重新渲染。以下三种情况，会导致网页重新渲染。</p><ul><li>修改DOM</li><li>修改样式表</li><li>用户事件（比如鼠标悬停、页面滚动、输入框键入文字、改变窗口大小等等）</li></ul><p>重新渲染，就需要重新生成布局和重新绘制。前者叫做”重排”（reflow），后者叫做”重绘”（repaint）。需要注意的是，”重绘”不一定需要”重排”，比如改变某个网页元素的颜色，就只会触发”重绘”，不会触发”重排”，因为布局没有改变。但是，”重排”必然导致”重绘”，比如改变一个网页元素的位置，就会同时触发”重排”和”重绘”，因为布局改变了。</p><h2 id="性能影响"><a href="#性能影响" class="headerlink" title="性能影响"></a>性能影响</h2><p>重排和重绘会不断触发，这是不可避免的。但是，它们非常耗费资源，是导致网页性能低下的根本原因。<strong>提高网页性能，就是要降低”重排”和”重绘”的频率和成本，尽量少触发重新渲染。</strong>前面提到，DOM变动和样式变动，都会触发重新渲染。但是，浏览器已经很智能了，会尽量把所有的变动集中在一起，排成一个队列，然后一次性执行，尽量避免多次重新渲染。</p><pre><code class="js">div.style.color = &#39;blue&#39;;div.style.marginTop = &#39;30px&#39;;</code></pre><p>上面代码中，div元素有两个样式变动，但是浏览器只会触发一次重排和重绘。如果写得不好，就会触发两次重排和重绘。</p><pre><code class="js">div.style.color = &#39;blue&#39;;var margin = parseInt(div.style.marginTop);div.style.marginTop = (margin + 10) + &#39;px&#39;;</code></pre><p>上面代码对div元素设置背景色以后，第二行要求浏览器给出该元素的位置，所以浏览器不得不立即重排。一般来说，样式的写操作之后，如果有下面这些属性的读操作，都会引发浏览器立即重新渲染。</p><pre><code class="js">offsetTop/offsetLeft/offsetWidth/offsetHeightscrollTop/scrollLeft/scrollWidth/scrollHeightclientTop/clientLeft/clientWidth/clientHeightgetComputedStyle()</code></pre><p>所以，从性能角度考虑，尽量不要把读操作和写操作，放在一个语句里面。</p><pre><code class="js">// baddiv.style.left = div.offsetLeft + 10 + &quot;px&quot;;div.style.top = div.offsetTop + 10 + &quot;px&quot;;// goodvar left = div.offsetLeft;var top  = div.offsetTop;div.style.left = left + 10 + &quot;px&quot;;div.style.top = top + 10 + &quot;px&quot;;</code></pre><p>一般的规则是：</p><ul><li>样式表越简单，重排和重绘就越快。</li><li>重排和重绘的DOM元素层级越高，成本就越高。</li><li>table元素的重排和重绘成本，要高于div元素</li></ul><h2 id="提高性能的九个技巧"><a href="#提高性能的九个技巧" class="headerlink" title="提高性能的九个技巧"></a>提高性能的九个技巧</h2><p>有一些技巧，可以降低浏览器重新渲染的频率和成本。</p><ul><li>第一条是上一节说到的，DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。</li><li>第二条，如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。</li><li>第三条，不要一条条地改变样式，而要通过改变class，或者csstext属性，一次性地改变样式。<br>```js<br>// bad<br>var left = 10;<br>var top = 10;<br>el.style.left = left + “px”;<br>el.style.top  = top  + “px”;</li></ul><p>// good<br>el.className += “ theclassname”;</p><p>// good<br>el.style.cssText += “; left: “ + left + “px; top: “ + top + “px;”;</p><pre><code>* 第四条，尽量使用离线DOM，而不是真实的网面DOM，来改变元素样式。比如，操作Document Fragment对象，完成后再把这个对象加入DOM。再比如，使用 cloneNode() 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。* 第五条，先将元素设为display: none（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。* 第六条，position属性为absolute或fixed的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。* 第七条，只在必要的时候，才将元素的display属性为可见，因为不可见的元素不影响重排和重绘。另外，visibility : hidden的元素只对重绘有影响，不影响重排。* 第八条，使用虚拟DOM的脚本库，比如React等。* 第九条，使用 window.requestAnimationFrame()、window.requestIdleCallback() 这两个方法调节重新渲染## window.requestAnimationFrame()有一些JavaScript方法可以调节重新渲染，大幅提高网页性能。其中最重要的，就是 window.requestAnimationFrame() 方法。它可以将某些代码放到下一次重新渲染时执行。```jsfunction doubleHeight(element) &#123;  var currentHeight = element.clientHeight;  element.style.height = (currentHeight * 2) + &#39;px&#39;;&#125;elements.forEach(doubleHeight);</code></pre><p>上面的代码使用循环操作，将每个元素的高度都增加一倍。可是，每次循环都是，读操作后面跟着一个写操作。这会在短时间内触发大量的重新渲染，显然对于网页性能很不利。<br>我们可以使用window.requestAnimationFrame()，让读操作和写操作分离，把所有的写操作放到下一次重新渲染。</p><pre><code class="js">function doubleHeight(element) &#123;  var currentHeight = element.clientHeight;  window.requestAnimationFrame(function () &#123;    element.style.height = (currentHeight * 2) + &#39;px&#39;;  &#125;);&#125;elements.forEach(doubleHeight);</code></pre><p>页面滚动事件（scroll）的监听函数，就很适合用 window.requestAnimationFrame() ，推迟到下一次重新渲染。</p><pre><code class="js">$(window).on(&#39;scroll&#39;, function() &#123;   window.requestAnimationFrame(scrollHandler);&#125;);</code></pre><p>当然，最适用的场合还是网页动画。下面是一个旋转动画的例子，元素每一帧旋转1度。</p><pre><code class="js">var rAF = window.requestAnimationFrame;var degrees = 0;function update() &#123;  div.style.transform = &quot;rotate(&quot; + degrees + &quot;deg)&quot;;  console.log(&#39;updated to degrees &#39; + degrees);  degrees = degrees + 1;  rAF(update);&#125;rAF(update);</code></pre><h2 id="window-requestIdleCallback"><a href="#window-requestIdleCallback" class="headerlink" title="window.requestIdleCallback()"></a>window.requestIdleCallback()</h2><p>还有一个函数window.requestIdleCallback()，也可以用来调节重新渲染。<br>它指定只有当一帧的末尾有空闲时间，才会执行回调函数。</p><pre><code class="js">requestIdleCallback(fn);</code></pre><p>上面代码中，只有当前帧的运行时间小于16.66ms时，函数fn才会执行。否则，就推迟到下一帧，如果下一帧也没有空闲时间，就推迟到下下一帧，以此类推。</p><p>它还可以接受第二个参数，表示指定的毫秒数。如果在指定的这段时间之内，每一帧都没有空闲时间，那么函数fn将会强制执行。</p><pre><code class="js">requestIdleCallback(fn, 5000);</code></pre><p>上面的代码表示，函数fn最迟会在5000毫秒之后执行。<br>函数 fn 可以接受一个 deadline 对象作为参数。</p><pre><code class="js">requestIdleCallback(function someHeavyComputation(deadline) &#123;  while(deadline.timeRemaining() &gt; 0) &#123;    doWorkIfNeeded();  &#125;  if(thereIsMoreWorkToDo) &#123;    requestIdleCallback(someHeavyComputation);  &#125;&#125;);</code></pre><p>上面代码中，回调函数 someHeavyComputation 的参数是一个 deadline 对象。<br>deadline对象有一个方法和一个属性：timeRemaining() 和 didTimeout。</p><ol><li><p>timeRemaining() 方法</p><p> timeRemaining() 方法返回当前帧还剩余的毫秒。这个方法只能读，不能写，而且会动态更新。因此可以不断检查这个属性，如果还有剩余时间的话，就不断执行某些任务。一旦这个属性等于0，就把任务分配到下一轮requestIdleCallback。</p><p> 前面的示例代码之中，只要当前帧还有空闲时间，就不断调用doWorkIfNeeded方法。一旦没有空闲时间，但是任务还没有全执行，就分配到下一轮requestIdleCallback。</p></li><li><p>didTimeout属性</p><p> deadline对象的 didTimeout 属性会返回一个布尔值，表示指定的时间是否过期。这意味着，如果回调函数由于指定时间过期而触发，那么你会得到两个结果。</p><p> <code>timeRemaining方法返回0</code></p><p> <code>didTimeout 属性等于 true</code></p><p> 因此，如果回调函数执行了，无非是两种原因：当前帧有空闲时间，或者指定时间到了。<br>```js<br>function myNonEssentialWork (deadline) {<br>while ((deadline.timeRemaining() &gt; 0 || deadline.didTimeout) &amp;&amp; tasks.length &gt; 0)<br> doWorkIfNeeded();</p></li></ol><p>  if (tasks.length &gt; 0)<br>    requestIdleCallback(myNonEssentialWork);<br>}</p><p>requestIdleCallback(myNonEssentialWork, 5000);</p><pre><code>上面代码确保了，doWorkIfNeeded函数一定会在将来某个比较空闲的时间（或者在指定时间过期后）得到反复执行。requestIdleCallback 是一个很新的函数，刚刚引入标准，目前只有Chrome支持，不过其他浏览器可以用垫片库。参考：* [网页性能管理详解-阮一峰](http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html)* [现代浏览器的工作原理](http://blog.jobbole.com/12749/)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS之BFC(块级格式化上下文)</title>
      <link href="/2017-02/css%E4%B9%8Bbfc-%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
      <url>/2017-02/css%E4%B9%8Bbfc-%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p>BFC 是什么？从没有认识到最初的认识是一个关键且困难的过程。网上的很多文章都会写道：BFC 是一个环境。这样的写法让人看了就头疼：我们在 HTML 和 CSS 中好像从没接触过环境这个概念。</p><p>下面不妨让我用通俗的方式解释一下 BFC 的概念：BFC 可以简单的理解为某个元素的一个 CSS 属性，只不过这个属性不能被开发者显式的修改，拥有这个属性的元素对内部元素和外部元素会表现出一些特性（后面会讲到），这就是 BFC。</p><span id="more"></span><h2 id="BFC-的特性"><a href="#BFC-的特性" class="headerlink" title="BFC 的特性"></a>BFC 的特性</h2><p>BFC 对布局的影响主要体现在对 float 和 margin 两个属性的处理。在我看来，BFC 让 float 和 margin 这两个属性的表现更加符合我们的直觉。</p><h4 id="BFC-包裹浮动元素"><a href="#BFC-包裹浮动元素" class="headerlink" title="BFC 包裹浮动元素"></a>BFC 包裹浮动元素</h4><p>BFC 的特性之一就是其高度的计算会包括所有浮动元素的高度，所以使用 BFC 可以包裹浮动元素，达到清除浮动的目的。</p><pre><code class="html">&lt;div style=&quot;overflow: hidden; background: #AAA;&quot;&gt;  &lt;div    style=&quot;float: left; width: 100px; height: 100px; background: #000;&quot;  &gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p><code>overflow: hidden</code>可以触发一个元素的 BFC 属性，使该元素成为一个 BFC 容器，从而使该元素对内部元素及外部元素表现出 BFC 的特性</p><p>运行代码可以看到，我们虽然没有进行任何清除浮动的工作，外层 div 还是包裹住了内层浮动的 div，没有造成高度塌陷的情况。</p><p><img src="http://cdn.chuyunt.com/uPic/006tKfTcgy1fdcyj88jx5j30fa03c0l2.jpg"></p><p>另外，将外层 div 同时设为浮动来清除内层浮动的方法，本质上也是应用了 BFC 的特性，因为将一个元素设为浮动也会触发该元素的 BFC 属性，使外层元素成为一个 BFC 容器。</p><h4 id="BFC-包裹-margin-阻止外边距折叠"><a href="#BFC-包裹-margin-阻止外边距折叠" class="headerlink" title="BFC 包裹 margin(阻止外边距折叠)"></a>BFC 包裹 margin(阻止外边距折叠)</h4><p>BFC 对内部元素的另一个特性就是可以取消 margin 折叠(margin collapse)。这个特性我喜欢更形象的称之为包裹 margin。</p><pre><code class="html">&lt;div style=&quot;background: #AAA;&quot;&gt;  &lt;div    style=&quot;width: 100px; height: 100px; margin-top: 50px; background: #000;&quot;  &gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p>运行代码可以看到，内层 div 的 margin 并没有将内层 div 相对于外层 div 向下推移，而是将内外两层 div 整体向下推移：</p><p><img src="http://cdn.chuyunt.com/uPic/006tKfTcgy1fdcylpnq22j30fa04g0pd.jpg"></p><p>而我们想要的结果是这样的：</p><p><img src="http://cdn.chuyunt.com/uPic/006tKfTcgy1fdcym3n2urj30fa04q0qo.jpg"></p><p>内外两层 div 被整体向下推移的原因就是 margin 折叠，关于 margin 折叠的相关介绍可以<a target="_blank" rel="noopener" href="http://www.w3school.com.cn/css/css_margin_collapsing.asp">参见这里</a>。CSS 中父子元素的 margin 只要相邻，也会发生折叠，CSS 规范虽是如此，但很多时候这并不符合我们的预期：我们希望外部 div 能够包裹内部 div 的 margin，避免形成折叠，这时我们就可以使用 BFC。</p><pre><code class="html">&lt;div style=&quot;overflow:hidden; background:#AAA;&quot;&gt;  &lt;div    style=&quot;width:100px; height:100px; margin-top:50px; background:#000;&quot;  &gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p>我们将外层 div 设置为一个 BFC 容器，由于 margin 折叠只会发生在同一个 BFC 中的元素之间，而不同 BFC 的元素之间以及元素及其所属的 BFC 之间不会发生 margin 折叠，因此就可以实现对 margin 的包裹。</p><h4 id="BFC-可以阻止元素被浮动元素覆盖-阻止文本在浮动元素周围自动换行"><a href="#BFC-可以阻止元素被浮动元素覆盖-阻止文本在浮动元素周围自动换行" class="headerlink" title="BFC 可以阻止元素被浮动元素覆盖,阻止文本在浮动元素周围自动换行"></a>BFC 可以阻止元素被浮动元素覆盖,阻止文本在浮动元素周围自动换行</h4><p>BFC 对外部元素的独立性在于 BFC 元素不会与浮动元素叠加。例如：</p><pre><code class="html">&lt;div style=&quot;float: left; width: 100px; height: 100px; background: #000;&quot;&gt;&lt;/div&gt;&lt;div style=&quot;height: 200px; background: #AAA;&quot;&gt;&lt;/div&gt;</code></pre><p><img src="http://cdn.chuyunt.com/uPic/006tKfTcgy1fdd1j6h3rpj30fa0643y9.jpg"><br>可以看到，浮动的 div 由于脱离了文档流，导致正常的 div 左上角被覆盖。为了避免这种情况，我们使第二个 div 成为 BFC 容器：</p><pre><code class="html">&lt;div style=&quot;float: left; width: 100px; height: 100px; background: #000;&quot;&gt;&lt;/div&gt;&lt;div style=&quot;overflow: hidden; height: 200px; background: #AAA;&quot;&gt;&lt;/div&gt;</code></pre><p><img src="http://cdn.chuyunt.com/uPic/006tKfTcgy1fdd1jew2loj30fa064a9t.jpg"><br>当第二个 div 成为 BFC 容器后，其不会再受到浮动 div 的影响，布局相对独立。这样的技巧经常用作两栏或三栏自适应布局。</p><h2 id="BFC-的触发条件"><a href="#BFC-的触发条件" class="headerlink" title="BFC 的触发条件"></a>BFC 的触发条件</h2><p>BFC 可以被理解为元素的一个属性，但是这个属性无法被显式的设置，那么如何触发一个元素的 BFC 属性呢？上面的代码中使用的 overflow:hidden 就是触发 BFC 的一种方式，除了设置 overflow:hidden，下面的 CSS 属性设置都可以触发 BFC:</p><ul><li>父级元素，浮动元素：float 设置为除 none 之外的取值；</li><li>父级元素的 overflow 设置为除 visible 之外的取值；</li><li>父级元素，绝对定位元素：position 设置为 absolute 或 fixed；</li><li>父级元素，display 设置为 table-cell、table-caption、inline-block 中的任一取值；</li></ul><h2 id="BFC-与-Layout"><a href="#BFC-与-Layout" class="headerlink" title="BFC 与 Layout"></a>BFC 与 Layout</h2><p>IE 作为浏览器中的奇葩，当然不可能按部就班的支持 BFC 标准，于是乎 IE 中有了 Layout 这个东西。Layout 和 BFC 基本是等价的，为了处理 IE 的兼容性，在需要触发 BFC 时，我们除了需要用上面的 CSS 属性来触发 BFC，还需要针对 IE 浏览器使用<code>zoom: 1</code>来触发 IE 浏览器的 Layout。</p><p>参考链接：<a target="_blank" rel="noopener" href="https://www.w3cplus.com/css/understanding-block-formatting-contexts-in-css.html">理解 CSS 中 BFC</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前后端分离之JWT用户认证</title>
      <link href="/2017-01/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E4%B9%8Bjwt%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81/"/>
      <url>/2017-01/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E4%B9%8Bjwt%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<p>在前后端分离开发时为什么需要用户认证呢？原因是由于 HTTP 协定是不储存状态的(stateless)，这意味着当我们透过帐号密码验证一个使用者时，当下一个 request 请求时它就把刚刚的资料忘了。于是我们的程序就不知道谁是谁，就要再验证一次。所以为了保证系统安全，我们就需要验证用户否处于登录状态。</p><span id="more"></span><h3 id="传统方式"><a href="#传统方式" class="headerlink" title="传统方式"></a>传统方式</h3><p>前后端分离通过 Restful API 进行数据交互时，如何验证用户的登录信息及权限。在原来的项目中，使用的是最传统也是最简单的方式，前端登录，后端根据用户信息生成一个<code>token</code>，并保存这个 <code>token</code> 和对应的用户 id 到数据库或 Session 中，接着把 <code>token</code> 传给用户，存入浏览器 cookie，之后浏览器请求带上这个 cookie，后端根据这个 cookie 值来查询用户，验证是否过期。</p><p>但这样做问题就很多，如果我们的页面出现了 XSS 漏洞，由于 cookie 可以被 JavaScript 读取，XSS 漏洞会导致用户 token 泄露，而作为后端识别用户的标识，cookie 的泄露意味着用户信息不再安全。尽管我们通过转义输出内容，使用 CDN 等可以尽量避免 XSS 注入，但谁也不能保证在大型的项目中不会出现这个问题。</p><p>在设置 cookie 的时候，其实你还可以设置 httpOnly 以及 secure 项。设置 httpOnly 后 cookie 将不能被 JS 读取，浏览器会自动的把它加在请求的 header 当中，设置 secure 的话，cookie 就只允许通过 HTTPS 传输。secure 选项可以过滤掉一些使用 HTTP 协议的 XSS 注入，但并不能完全阻止。</p><p>httpOnly 选项使得 JS 不能读取到 cookie，那么 XSS 注入的问题也基本不用担心了。但设置 httpOnly 就带来了另一个问题，就是很容易的被 XSRF，即跨站请求伪造。当你浏览器开着这个页面的时候，另一个页面可以很容易的跨站请求这个页面的内容。因为 cookie 默认被发了出去。</p><p>另外，如果将验证信息保存在数据库中，后端每次都需要根据<code>token</code>查出用户<code>id</code>，这就增加了数据库的查询和存储开销。若把验证信息保存在 session 中，有加大了服务器端的存储压力。那我们可不可以不要服务器去查询呢？如果我们生成<code>token</code>遵循一定的规律，比如我们使用对称加密算法来加密用户<code>id</code>形成<code>token</code>，那么服务端以后其实只要解密该<code>token</code>就可以知道用户的<code>id</code>是什么了。不过呢，我只是举个例子而已，要是真这么做，只要你的对称加密算法泄露了，其他人可以通过这种加密方式进行伪造<code>token</code>，那么所有用户信息都不再安全了。恩，那用非对称加密算法来做呢，其实现在有个规范就是这样做的，就是我们接下来要介绍的 JWT。</p><h3 id="Json-Web-Token（JWT）"><a href="#Json-Web-Token（JWT）" class="headerlink" title="Json Web Token（JWT）"></a>Json Web Token（JWT）</h3><p>JWT 是一个开放标准(RFC 7519)，它定义了一种用于简洁，自包含的用于通信双方之间以 JSON 对象的形式安全传递信息的方法。JWT 可以使用 HMAC 算法或者是 RSA 的公钥密钥对进行签名。它具备两个特点：</p><ul><li><p>简洁(Compact)</p><p>可以通过 URL, POST 参数或者在 HTTP header 发送，因为数据量小，传输速度快</p></li><li><p>自包含(Self-contained)</p><p>负载中包含了所有用户所需要的信息，避免了多次查询数据库</p></li></ul><h4 id="JWT-组成"><a href="#JWT-组成" class="headerlink" title="JWT 组成"></a>JWT 组成</h4><p><img src="http://cdn.chuyunt.com/uPic/006tNc79gy1fbv54tfilmj31120b2wl9.jpg"></p><ul><li>Header 头部</li></ul><p>头部包含了两部分，token 类型和采用的加密算法</p><pre><code class="json">&#123;  &quot;alg&quot;: &quot;HS256&quot;,  &quot;typ&quot;: &quot;JWT&quot;&#125;</code></pre><p>它会使用 Base64 编码组成 JWT 结构的第一部分,如果你使用 Node.js，可以用 Node.js 的包 base64url 来得到这个字符串。</p><blockquote><p>Base64 是一种编码，也就是说，它是可以被翻译回原来的样子来的。它并不是一种加密过程。</p></blockquote><ul><li>Payload 负载</li></ul><p>这部分就是我们存放信息的地方了，你可以把用户 ID 等信息放在这里，JWT 规范里面对这部分有进行了比较详细的介绍，常用的由 iss（签发者），exp（过期时间），sub（面向的用户），aud（接收方），iat（签发时间）。</p><pre><code class="json">&#123;  &quot;iss&quot;: &quot;lion1ou JWT&quot;,  &quot;iat&quot;: 1441593502,  &quot;exp&quot;: 1441594722,  &quot;aud&quot;: &quot;www.example.com&quot;,  &quot;sub&quot;: &quot;lion1ou@163.com&quot;&#125;</code></pre><p>同样的，它会使用 Base64 编码组成 JWT 结构的第二部分</p><ul><li>Signature 签名</li></ul><p>前面两部分都是使用 Base64 进行编码的，即前端可以解开知道里面的信息。Signature 需要使用编码后的 header 和 payload 以及我们提供的一个密钥，然后使用 header 中指定的签名算法（HS256）进行签名。签名的作用是保证 JWT 没有被篡改过。</p><p>三个部分通过<code>.</code>连接在一起就是我们的 JWT 了，它可能长这个样子，长度貌似和你的加密算法和私钥有关系。</p><p><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</code>.<code>eyJpZCI6IjU3ZmVmMTY0ZTU0YWY2NGZmYzUzZGJkNSIsInhzcmYiOiI0ZWE1YzUwOGE2NTY2ZTc2MjQwNTQzZjhmZWIwNmZkNDU3Nzc3YmUzOTU0OWM0MDE2NDM2YWZkYTY1ZDIzMzBlIiwiaWF0IjoxNDc2NDI3OTMzfQ</code>.<code>PA3QjeyZSUh7H0GfE0vJaKW4LjKJuC3dVLQiY4hii8s</code></p><p>其实到这一步可能就有人会想了，HTTP 请求总会带上 token，这样这个 token 传来传去占用不必要的带宽啊。如果你这么想了，那你可以去了解下 HTTP2，HTTP2 对头部进行了压缩，相信也解决了这个问题。</p><ul><li>签名的目的</li></ul><p>最后一步签名的过程，实际上是对头部以及负载内容进行签名，防止内容被窜改。如果有人对头部以及负载的内容解码之后进行修改，再进行编码，最后加上之前的签名组合形成新的 JWT 的话，那么服务器端会判断出新的头部和负载形成的签名和 JWT 附带上的签名是不一样的。如果要对新的头部和负载进行签名，在不知道服务器加密时用的密钥的话，得出来的签名也是不一样的。</p><ul><li>信息暴露</li></ul><p>在这里大家一定会问一个问题：Base64 是一种编码，是可逆的，那么我的信息不就被暴露了吗？</p><p>是的。所以，在 JWT 中，不应该在负载里面加入任何敏感的数据。在上面的例子中，我们传输的是用户的 User ID。这个值实际上不是什么敏感内容，一般情况下被知道也是安全的。但是像密码这样的内容就不能被放在 JWT 中了。如果将用户的密码放在了 JWT 中，那么怀有恶意的第三方通过 Base64 解码就能很快地知道你的密码了。</p><p>因此 JWT 适合用于向 Web 应用传递一些非敏感信息。JWT 还经常用于设计用户认证和授权系统，甚至实现 Web 应用的单点登录。</p><h3 id="JWT-使用"><a href="#JWT-使用" class="headerlink" title="JWT 使用"></a>JWT 使用</h3><p><img src="http://cdn.chuyunt.com/uPic/006tNc79gy1fbv63pzqocj30pj0h8t9m.jpg"></p><ol><li>首先，前端通过 Web 表单将自己的用户名和密码发送到后端的接口。这一过程一般是一个 HTTP POST 请求。建议的方式是通过 SSL 加密的传输（https 协议），从而避免敏感信息被嗅探。</li><li>后端核对用户名和密码成功后，将用户的 id 等其他信息作为 JWT Payload（负载），将其与头部分别进行 Base64 编码拼接后签名，形成一个 JWT。形成的 JWT 就是一个形同 lll.zzz.xxx 的字符串。</li><li>后端将 JWT 字符串作为登录成功的返回结果返回给前端。前端可以将返回的结果保存在 localStorage 或 sessionStorage 上，退出登录时前端删除保存的 JWT 即可。</li><li>前端在每次请求时将 JWT 放入 HTTP Header 中的 Authorization 位。(解决 XSS 和 XSRF 问题)</li><li>后端检查是否存在，如存在验证 JWT 的有效性。例如，检查签名是否正确；检查 Token 是否过期；检查 Token 的接收方是否是自己（可选）。</li><li>验证通过后后端使用 JWT 中包含的用户信息进行其他逻辑操作，返回相应结果。</li></ol><h3 id="和-Session-方式存储-id-的差异"><a href="#和-Session-方式存储-id-的差异" class="headerlink" title="和 Session 方式存储 id 的差异"></a>和 Session 方式存储 id 的差异</h3><p>Session 方式存储用户 id 的最大弊病在于 Session 是存储在服务器端的，所以需要占用大量服务器内存，对于较大型应用而言可能还要保存许多的状态。一般而言，大型应用还需要借助一些 KV 数据库和一系列缓存机制来实现 Session 的存储。</p><p>而 JWT 方式将用户状态分散到了客户端中，可以明显减轻服务端的内存压力。除了用户 id 之外，还可以存储其他的和用户相关的信息，例如该用户是否是管理员、用户所在的分组等。虽说 JWT 方式让服务器有一些计算压力（例如加密、编码和解码），但是这些压力相比磁盘存储而言可能就不算什么了。具体是否采用，需要在不同场景下用数据说话。</p><ul><li>单点登录</li></ul><p>Session 方式来存储用户 id，一开始用户的 Session 只会存储在一台服务器上。对于有多个子域名的站点，每个子域名至少会对应一台不同的服务器，例如：<code>www.taobao.com</code>，<code>nv.taobao.com</code>，<code>nz.taobao.com</code>，<code>login.taobao.com</code>。所以如果要实现在<code>login.taobao.com</code>登录后，在其他的子域名下依然可以取到 Session，这要求我们在多台服务器上同步 Session。使用 JWT 的方式则没有这个问题的存在，因为用户的状态已经被传送到了客户端。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>JWT 的主要作用在于（一）可附带用户信息，后端直接通过 JWT 获取相关信息。（二）使用本地保存，通过 HTTP Header 中的 Authorization 位提交验证。但其实关于 JWT 存放到哪里一直有很多讨论，有人说存放到本地存储，有人说存 cookie。个人偏向于放在本地存储，如果你有什么意见和看法欢迎提出。</p><h3 id="nodejs-使用示例"><a href="#nodejs-使用示例" class="headerlink" title="nodejs 使用示例"></a>nodejs 使用示例</h3><p>在 node 中需要需要引入两个库</p><ul><li>jsonwebtoken</li><li>koa-jwt</li></ul><p>使用<code>jsonwebtoken</code>来加密生成返回给客户端的 token</p><pre><code class="js">const jwt = require(&quot;jsonwebtoken&quot;);const secret = &quot;aaa&quot;; // 私钥，用于加密时混淆//jwt生成tokenconst token = jwt.sign(  &#123;    name: 123,  &#125;,  secret,  &#123;    expiresIn: 60, //秒到期时间  &#125;);console.log(token);//解密tokenjwt.verify(token, secret, function (err, decoded) &#123;  if (!err) &#123;    console.log(decoded.name); //会输出123，如果过了60秒，则有错误。  &#125;&#125;);</code></pre><p>我们看看 jwt.sign 生成的 token:</p><pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoxMjMsImlhdCI6MTQ5MTQ3NTQyNCwiZXhwIjoxNDkxNDc1NDg0fQ.hYNC4qFAyhZClmPaLixfN137d41R2CFk1xPlfLK10JU</code></pre><p>我们仔细看这字符串，分为三段。分别被 “.” 隔开。我们对：<code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</code> 由 base64 解密得到<br><code>&#123;&quot;alg&quot;:&quot;HS256&quot;,&quot;typ&quot;:&quot;JWT&quot;&#125;</code> alg 是加密算法名字，typ 是类型</p><p>这段: <code>eyJuYW1lIjoxMjMsImlhdCI6MTQ5MTQ3NTQyNCwiZXhwIjoxNDkxNDc1NDg0fQ</code> 由 base64 解密得到： <code>&#123;&quot;name&quot;:123,&quot;iat&quot;:1491475424,&quot;exp&quot;:1491475484&#125;</code> name 是我们储存的内容，但是多了 iat（创建的时间戳），exp（到期时间戳）。</p><p>最后一段是<code>hYNC4qFAyhZClmPaLixfN137d41R2CFk1xPlfLK10JU</code>，是由前面俩段字符串 HS256 加密后得到。 所以前面的任何一个字段修改，都会导致加密后的字符串不匹配。</p><p>参考：</p><ul><li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000005783306">1.Node 實作 jwt 驗證 API</a></li><li><a target="_blank" rel="noopener" href="http://blog.rainy.im/2015/06/10/react-jwt-pretty-good-practice/">2.JWT 在前后端分离中的应用与实践</a></li><li><a target="_blank" rel="noopener" href="https://ruiming.me/archives/41">3.关于前后端分离鉴权的思考</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESLint入门指南</title>
      <link href="/2017-01/eslint%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2017-01/eslint%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>ESLint 是一个插件化的 javascript 代码检测工具，它可以用于检查常见的 JavaScript 代码错误，也可以进行代码风格检查，这样我们就可以根据自己的喜好指定一套 ESLint 配置，然后应用到所编写的项目上，从而实现辅助编码规范的执行，有效控制项目代码的质量。</p><span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>全局安装 <code>eslint</code></p><pre><code class="shell">$ npm install -g eslint</code></pre><p>将下面的测试代码保存在 eslintTest/test.js</p><pre><code class="js">function merge() &#123;  var ret = &#123;&#125;;  for (var i in arguments) &#123;    var m = arguments[i];    for (var j in m) ret[j] = m[j];  &#125;  return ret;&#125;console.log(merge(&#123; a: 123 &#125;, &#123; b: 456 &#125;));</code></pre><p>在执行 eslint 检查命令：</p><pre><code class="shell">eslint merge.js</code></pre><p>然后会出现以下错误：</p><p><img src="http://cdn.chuyunt.com/uPic/006tNc79gw1fbmzw6s2b6j30ev06r75k.jpg"></p><p>这是因为我们没有指定任何的配置，除非这个文件是有语法错误，否则应该是不会有任何提示的。所以我们根据提示，执行<code>eslint --init</code>,根据自己的需求选择相应的配置。</p><pre><code>? How would you like to configure ESLint? Answer questions about your style? Are you using ECMAScript 6 features? No? Where will your code run? Browser? Do you use CommonJS? No? Do you use JSX? No? What style of indentation do you use? Spaces? What quotes do you use for strings? Single? What line endings do you use? Unix? Do you require semicolons? Yes? What format do you want your config file to be in? JavaScript</code></pre><p>结束后，你就会发现在在文件夹下会出现一个<code>.eslintrc.js</code>文件，这个就是根据你的选择生成的 eslint 的配置文件。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>重新执行<code>elsint test.js</code>,会出现以下错误：</p><p><img src="http://cdn.chuyunt.com/uPic/006tNc79gw1fbn0bg8ej4j30bt02w74p.jpg"></p><ul><li>Unexpected console statement no-console - 不能使用 console</li></ul><p>针对这条提示，我们可以禁用 no-console 规则。在配置文件.eslintrc.js 中添加以下内容：</p><pre><code>rules: &#123;    &#39;no-console&#39;: &#39;off&#39;,&#125;</code></pre><p>说明：配置规则写在 rules 对象里面，key 表示规则名称，value 表示规则的配置，具体说明见下文。</p><p>然后再执行<code>eslint test.js</code>,就啥也不出现的，说明验证通过。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><pre><code class="js">module.exports = &#123;  extends: &quot;eslint:recommended&quot;,  //使用内置的eslint:recommended配置，它包含了一系列核心规则，能报告一些常见的问题。  env: &#123;    browser: true,  &#125;,  //指定程序的目标运行环境  rules: &#123;    &quot;no-console&quot;: &quot;off&quot;,    indent: [&quot;error&quot;, 2], //缩进为 2 个空格    &quot;linebreak-style&quot;: &quot;off&quot;, //强制使用一致的换行符风格    quotes: [&quot;error&quot;, &quot;single&quot;], //使用单引号    semi: [&quot;error&quot;, &quot;always&quot;], //结束添加分号  &#125;,&#125;;</code></pre><p>说明：</p><ol><li>因为 JavaScript 有很多种运行环境，比如常见的有浏览器和 Node.js，另外还有很多软件系统使用 JavaScript 作为其脚本引擎，比如 PostgreSQL 就支持使用 JavaScript 来编写存储引擎，而这些运行环境可能并不存在 console 这个对象。另外在浏览器环境下会有 window 对象，而 Node.js 下没有；在 Node.js 下会有 process 对象，而浏览器环境下没有。</li><li>每条规则有 3 个等级：off、warn 和 error。off 表示禁用这条规则，warn 表示仅给出警告，并不会导致检查不通过，而 error 则会导致检查不通过。</li><li>强制使用一致的换行符风格 L：”unix” (默认) 强制使用 Unix 换行符： <code>\n</code>。”windows” 强制使用 Windows 换行符： <code>\r\n</code>。如果你不关心你的代码中是否以不同的换行符结尾，你可以关闭此规则。</li></ol><p>以上是通过配置生成的配置文件，详细文档可以参考这里：<a target="_blank" rel="noopener" href="http://eslint.cn/docs/user-guide/configuring">Configuring ESLint - 配置</a>，规则的详细说明文档可以参考这里：<a target="_blank" rel="noopener" href="http://eslint.cn/docs/rules/">Rules - 规则</a></p><h2 id="代码格式化"><a href="#代码格式化" class="headerlink" title="代码格式化"></a>代码格式化</h2><p>在 <a target="_blank" rel="noopener" href="http://eslint.cn/docs/rules/">ESLint 规则列表</a> 页面，我们发现有些规则的旁边会带有一个橙色扳手图标，表示在执行 eslint 命令时指定–fix 参数可以自动修复该问题。即：</p><pre><code class="shell">eslint merge.js --fix</code></pre><p>则你的代码就会根据你配置好的配置文件自动格式化成你想要的样子。</p><h2 id="禁用检查"><a href="#禁用检查" class="headerlink" title="禁用检查"></a>禁用检查</h2><p>尽管我们在编码时怀着严格遵守规则的美好愿景，而凡事总有例外。定立 <code>ESLint</code> 规则的初衷是为了避免自己犯错，但是我们也要避免不顾实际情况而将其搞得太过于形式化，本末倒置。</p><p>ESLint 提供了多种临时禁用规则的方式，比如我们可以通过一条<code>eslint-disable-next-line</code>备注来使得下一行可以跳过检查：</p><pre><code class="js">// eslint-disable-next-linevar a = 123;var b = 456;</code></pre><p>在上面的示例代码中，var a = 123 不会受到检查，而 var b = 456 则右恢复检查，在上文我们使用的 eslint-config-lei 的配置规则下，由于不允许使用 var 声明变量，则 var b 这一行会报告一个 error。</p><p>我们还可以通过成对的 eslint-enable 和 eslint-disable 备注来禁用对某一段代码的检查，但是稍不小心少写了一个 eslint-disable 就可能会导致后面所有文件的检查都被禁用，所以我并不推荐使用。</p><p>详细使用方法可以参考文档：<a target="_blank" rel="noopener" href="http://eslint.cn/docs/user-guide/configuring#disabling-rules-with-inline-comments">Disabling Rules with Inline Comments - 使用行内注释禁用规则</a></p><h2 id="共享配置文件"><a href="#共享配置文件" class="headerlink" title="共享配置文件"></a>共享配置文件</h2><p>上文我们以 eslint:recommended 为基础配置，然后在此之上修改 no-console 这条规则。而在大多数时候，我们可能会根据自己个人或团队的习惯，定制更多的规则，比如限定缩进是 2 个空格和使用单引号的字符串等。而如果每一个项目都要这样写到.eslintrc.js 文件上，管理起来会比较麻烦。</p><p>我们可以将定义好规则的.eslintrc.js 文件存储到一个公共的位置，比如 public-eslintrc.js：</p><p>然后将原来的.eslintrc.js 文件改成这样：</p><pre><code>module.exports = &#123;  extends: &#39;./public-eslintrc.js&#39;,&#125;;</code></pre><p>还可以使用已经发布到 NPM 上的 ESLint 配置，这些配置的模块名一般以 eslint-config-为前缀，要使用这个配置，先执行以下命令安装它：</p><pre><code class="shell">npm install -g eslint-config-*</code></pre><p>注意：由于我们的 eslint 命令是全局安装的，所有用到的 eslint-config-*模块也必须全局安装，否则将无法正确载入。</p><p>然后将.eslintrc.js 文件改成这样：</p><pre><code class="js">module.exports = &#123;  extends: &quot;*&quot;,&#125;;</code></pre><p><a target="_blank" rel="noopener" href="http://eslint.cn/docs/user-guide/configuring#using-the-configuration-from-a-plugin">Using the configuration from a plugin - 使用插件</a></p><h2 id="发布配置"><a href="#发布配置" class="headerlink" title="发布配置"></a>发布配置</h2><p>在 extends 中指定一个文件名，或者一个 eslint-config-开头的模块名。为了便于共享，一般推荐将其发布成一个 NPM 模块。其原理就是在载入模块时输出原来.eslintrc.js 的数据。</p><p>比如我们可以创建一个模块 eslint-config-my 用于测试。新建文件 eslint-config-my/index.js：</p><pre><code class="js">module.exports = &#123;  extends: &quot;eslint:recommended&quot;,  env: &#123;    node: true,    es6: true,  &#125;,  rules: &#123;    &quot;no-console&quot;: &quot;off&quot;,    indent: [&quot;error&quot;, 2],    quotes: [&quot;error&quot;, &quot;single&quot;],  &#125;,&#125;;</code></pre><p>再新建文件 eslint-config-my/package.json：</p><pre><code class="js">&#123;  &quot;name&quot;: &quot;eslint-config-my&quot;,  &quot;version&quot;: &quot;0.0.1&quot;,  &quot;main&quot;: &quot;index.js&quot;&#125;</code></pre><p>为了能让 eslint 正确载入这个模块，我们需要执行 npm link 将这个模块链接到本地全局位置：</p><pre><code class="shell">$ npm link eslint-config-my</code></pre><p>然后将测试文件中的.eslintrc.js 改成这样：</p><pre><code class="js">module.exports = &#123;  extends: &quot;my&quot;,&#125;;</code></pre><p>说明：在 extends 中，eslint-config-my 可简写为 my。</p><p>在执行<code>eslint merge.js</code>检查，可看到没有任何错误提示信息，说明 eslint 已经成功载入了<code>eslint-config-my</code>的配置。如果我们使用<code>npm publish</code>将其发布到 NPM 上，那么其他人通过<code>npm install eslint-config-my</code>即可使用我们共享的这个配置。</p><p>关于共享 ESLint 配置的详细文档可参考：<a target="_blank" rel="noopener" href="http://eslint.cn/docs/developer-guide/shareable-configs">Shareable Configs - 可共享的配置</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ESLint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML之Meta标签</title>
      <link href="/2016-11/html%E4%B9%8Bmeta%E6%A0%87%E7%AD%BE/"/>
      <url>/2016-11/html%E4%B9%8Bmeta%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<p>meta是html语言head区的一个辅助性标签。也许你认为这些代码可有可无。其实如果你能够用好meta标签，会给你带来意想不到的效果，meta标签的作用有：搜索引擎优化（SEO），定义页面使用语言，自动刷新并指向新的页面，实现网页转换时的动态效果，控制页面缓冲，网页定级评价，控制网页显示的窗口等！</p><span id="more"></span><h2 id="桌面端"><a href="#桌面端" class="headerlink" title="桌面端"></a>桌面端</h2><h3 id="Name属性"><a href="#Name属性" class="headerlink" title="Name属性"></a>Name属性</h3><h5 id="Meta-Description"><a href="#Meta-Description" class="headerlink" title="Meta Description"></a>Meta Description</h5><p>这个标签曾经在搜索排名中占有很大的权重，但随着算法的不断更新升级，它的地位也逐渐降低。它虽然不会提高网站排名，但是，因为它会被用在搜索引擎的结果页，所以依然有用。</p><pre><code class="html">&lt;meta name=&quot;description&quot; content=&quot;You can write everything!&quot;&gt;</code></pre><p>Meta description标签可能是最有用的标签之一。顾名思义，它会给搜索引擎提供关于这个网页的简短的描述。推荐的description长度为160 个字符。</p><h5 id="Meta-Robots"><a href="#Meta-Robots" class="headerlink" title="Meta Robots"></a>Meta Robots</h5><p>Meta robots标签管理着搜索引擎是否可以进入网页，你可以用它来允许或不允许搜索引擎来获取你的网页、进入你网页中的子链接或对你的网页存档。</p><pre><code class="html">&lt;meta name=&quot;robots&quot; content=&quot;robotterms&quot; /&gt;</code></pre><p>robotterms是一组使用逗号(,)分割的值，通常有如下几种取值：none，noindex，nofollow，all，index和follow。</p><ul><li>none    搜索引擎将忽略此网页，等价于noindex，nofollow。</li><li>noindex 搜索引擎不索引此网页。</li><li>nofollow    搜索引擎不继续通过此网页的链接索引搜索其它的网页。</li><li>all 搜索引擎将索引此网页与继续通过此网页的链接索引，等价于index，follow。</li><li>index   搜索引擎索引此网页。</li><li>follow  搜索引擎继续通过此网页的链接索引搜索其它的网页。</li></ul><p>如果网页没有提供robots，搜索引擎认为网页的robots属性为all(index，follow)；</p><h5 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h5><p>专业的讲，title标签不是meta标签，但他们都放在相同位置。我之所以把title标签放在这里是因为它对搜索引擎优化很重要。在所有的HTML文档中，title标签都是不可缺少的。它定义了整个文档的标题。</p><pre><code class="html">&lt;title&gt;Examples&lt;/title&gt;</code></pre><p>浏览器会以特殊的方式来使用标题，并且通常把它放置在浏览器窗口的标题栏或状态栏上。同样，当把文档加入用户的链接列表或者收藏夹或书签列表时，标题将成为该文档链接的默认名称。</p><h5 id="Meta-keywords"><a href="#Meta-keywords" class="headerlink" title="Meta keywords"></a>Meta keywords</h5><p>keywords用于定义网页关键词，keywords出现在name属性中，使用content属性提供网页的关键词。</p><pre><code class="html">&lt;meta name=&quot;keywords&quot; content=&quot;HTML XHTML&quot; /&gt;</code></pre><ul><li>keywords提供的网页关键词通常是为搜索引擎分类网页使用的；</li><li>可以为网页提供多个关键词，多个关键词应该使用空格分开；</li><li>不要给网页定义过多的关键词，最好保持在10个以下，过多的关键词，搜索引擎将忽略；</li><li>不要给网页定义与网页描述内容无关的关键词；</li><li>由于网页制作者滥用keywords(提供过多的关键词或者提供与网页无关的关键词)，导致目前常用的搜索引擎降低了keywords的重要性。</li></ul><h5 id="Meta-refresh"><a href="#Meta-refresh" class="headerlink" title="Meta refresh"></a>Meta refresh</h5><p>定义文档在规定的时间内容刷新或跳转到新的 URL 上。</p><pre><code class="html">&lt;meta name=&quot;refresh&quot; content=&quot;10&quot;&gt;&lt;meta name=&quot;refresh&quot; content=&quot;10;URL=http://www.chuyunt.com&quot;&gt;</code></pre><p>name值还有：</p><ul><li><p>abstract  定义了一个二级描述</p></li><li><p>author  定义文档的作者。<br>  实例：<code>&lt;meta name=&quot;author&quot; content=&quot;Hege Refsnes&quot;&gt;</code></p></li><li><p>classification  归类站点到正确类别</p></li><li><p>copyright   定义文档的版权信息。<br>  实例：<code>&lt;meta name=&quot;copyright&quot; content=&quot;2016 © lion1ou&quot;&gt;</code></p></li><li><p>distribution  规定文件是否可用于Web或Intranet。（web - 互联网，intranet - 内网）<br>  实例：<code>&lt;meta name=&quot;distribution&quot; content=&quot;web&quot;&gt;</code></p></li><li><p>doc-class   指定文档完成的状态</p></li><li><p>doc-rights  文档的版权声明</p></li><li><p>doc-type    指定文档的类型</p></li><li><p>DownloadOptions 控制下载对话框按钮的显示。noopen - 隐藏打开按钮，nosave - 隐藏保存按钮。</p></li><li><p>expires 设置网页过期时间<br>  实例：<code>&lt;meta name=&quot;expires&quot; content=&quot;Fri, 10 Jun 2011 12:00:00 GMT&quot;&gt;</code></p></li><li><p>generator   指定文档生成的工具名称</p></li><li><p>googlebot   设置 Google 搜索隐藏的收入规则：</p><ul><li>noarchive - 告诉爬虫,不要为本网页建立快照</li><li>nofollow - 网页可以被追踪，但网页的链接不要去追终</li><li>noindex - 链接可以被追踪，但含此标签的网页不能建立索引</li><li>nosnippet - 告诉Google不要在搜索结果页的列表里显示含此标签的网站的描述语句，并且不要在列表里显示快照链接。</li></ul><p>  实例：<code>&lt;meta http-equiv=&quot;googlebot&quot; content=&quot;noarchive&quot;&gt;</code></p></li><li><p>MSSmartTagsPreventParsing   防止微软页面编辑软件在页面上自动添加标签、链接等。</p><ul><li>name    指定文档的名称</li><li>owner   定义网页的所有者</li><li>progid  定义程序 id 用于生成文档。</li><li>rating  定义内容分级，如：14 years（14岁以上），general(普通人)，mature（成年人），restricted（限制级），safe for kids(孩童)。</li><li>reply-to    定义网页开发者的邮件地址</li><li>resource-type   定义 web 资源类型</li><li>revisit-after   定义搜索引擎爬取网页的时间频率</li><li>Template    内容属性可以指定用于编译文档的模板位置</li><li>others  你可以定义自己的名字</li></ul></li></ul><h3 id="httpEquiv-属性"><a href="#httpEquiv-属性" class="headerlink" title="httpEquiv 属性"></a>httpEquiv 属性</h3><h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><pre><code class="html">&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;</code></pre><p>content：</p><ul><li>public - cached in public shared caches/缓存在共享缓存中</li><li>private - cached in private cache/缓存在私有缓存中</li><li>no-cache - not cached/不缓存</li><li>no-store - cached but not archived/缓存但不存档</li></ul><h5 id="文本语言"><a href="#文本语言" class="headerlink" title="文本语言"></a>文本语言</h5><pre><code class="html">&lt;meta http-equiv=&quot;content-language&quot; content=&quot;en-US&quot;&gt;</code></pre><h5 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h5><pre><code class="html">&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;   </code></pre><h5 id="定义页面本身刷新的时间"><a href="#定义页面本身刷新的时间" class="headerlink" title="定义页面本身刷新的时间"></a>定义页面本身刷新的时间</h5><pre><code class="html">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;300&quot;&gt;</code></pre><h5 id="创建带有指定名称的cookie，过期日期和值"><a href="#创建带有指定名称的cookie，过期日期和值" class="headerlink" title="创建带有指定名称的cookie，过期日期和值"></a>创建带有指定名称的cookie，过期日期和值</h5><pre><code class="html">&lt;meta http-equiv=&quot;set-cookie&quot; content=&quot;cookie=myContent;expires=Fri, 30 Dec 2011 12:00:00 GMT; path=http://www.chuyunt.com&quot;&gt;</code></pre><h3 id="scheme-属性"><a href="#scheme-属性" class="headerlink" title="scheme 属性"></a>scheme 属性</h3><p>scheme 属性设置或返回用于解释 content 属性的值的格式。</p><h3 id="content-属性"><a href="#content-属性" class="headerlink" title="content 属性"></a>content 属性</h3><p>content 属性可设置或者返回 meta 元素 content 属性值。content 属性指定了 meta 信息的内容。这个属性可用的值依赖于name 和 httpEquiv 属性的值。</p><h2 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h2><h3 id="Meta-之-viewport"><a href="#Meta-之-viewport" class="headerlink" title="Meta 之 viewport"></a>Meta 之 viewport</h3><p>　viewport即可视区域，有如下几种属性值可以设置：</p><ul><li>width: viewport 的宽度 (范围从 200 到 10,000 ，默认为 980 像素 )</li><li>height: viewport 的高度 (范围从 223 到 10,000 )</li><li>initial-scale: 初始的缩放比例 (范围从&gt;0到 10 )</li><li>minimum-scale: 允许用户缩放到的最小比例</li><li>maximum-scale: 允许用户缩放到的最大比例</li><li>user-scalable: 用户是否可以手动缩放</li></ul><p>对于这些属性，我们可以设置其中的一个或者多个，并不需要你同时都设置，手机会根据你设置的属性自动推算其他属性值，而非直接采用默认值。</p><pre><code class="html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width;&quot; user-scalable=&quot;0;&quot; maximum-scale=&quot;1.0;&quot; initial-scale=&quot;1.0;&quot;&gt;</code></pre><h3 id="Meta-之-format-detection"><a href="#Meta-之-format-detection" class="headerlink" title="Meta 之 format-detection"></a>Meta 之 format-detection</h3><pre><code class="html">&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;</code></pre><p>telephone=no就禁止了把数字转化为拨号链接!telephone=yes就开启了把数字转化为拨号链接，要开启转化功能，这个meta就不用写了,在默认是情况下就是开启!</p><h3 id="Meta-之-apple-mobile-web-app-capable"><a href="#Meta-之-apple-mobile-web-app-capable" class="headerlink" title="Meta 之 apple-mobile-web-app-capable"></a>Meta 之 apple-mobile-web-app-capable</h3><pre><code class="html">&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;</code></pre><p>这meta的作用就是删除默认的苹果工具栏和菜单栏。content有两个值”yes”和”no”,当我们需要显示工具栏和菜单栏时，这个行meta就不用加了，默认就是显示。</p><h3 id="Meta-之-apple-mobile-web-app-status-bar-style"><a href="#Meta-之-apple-mobile-web-app-status-bar-style" class="headerlink" title="Meta 之 apple-mobile-web-app-status-bar-style"></a>Meta 之 apple-mobile-web-app-status-bar-style</h3><pre><code class="html">&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;default&quot;&gt;&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt;&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black-translucent&quot;&gt;</code></pre><p>作用是控制状态栏显示样式</p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apidoc一个自动生成API文档的工具</title>
      <link href="/2016-10/apidoc%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90api%E6%96%87%E6%A1%A3%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
      <url>/2016-10/apidoc%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90api%E6%96%87%E6%A1%A3%E7%9A%84%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p><code>apidoc</code>是一个生成<code>RESTful API文档</code>的工具，它通过代码注释中的特定格式和内容，生成API文档。目前支持的语法有:Java、Javascript、C#、C/C++、D、Erlang、Go、Groovy、Pascal/Delphi、 Perl、PHP、Python、Ruby、Rust、Scala 和 Swift。</p><ul><li>项目主页：<a target="_blank" rel="noopener" href="http://apidocjs.com/">http://apidocjs.com/</a> </li><li>Github：<a target="_blank" rel="noopener" href="https://github.com/apidoc/apidoc">https://github.com/apidoc/apidoc</a><span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2></li></ul><p>可以通过<code>npm install apidoc -g</code>进行全局安装</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>仅需要在终端当前目录下创建一个apidoc.json文件和一个存放生成的文档的<code>apidoc</code>文件夹。</p><p>执行以下命令：</p><pre><code class="shell">apidoc -i your-project-dir/ -o apidoc/</code></pre><p>参数说明：</p><ul><li>-i 表示输入，后面是文件夹路径</li><li>-o 表示输出，后面是文件夹路径</li><li>-c，默认会带上，在当前路径下寻找配置文件(apidoc.json)，如果找不到则会在package.json中寻找<code>&quot;apidoc&quot;: &#123; &#125;</code>对象</li><li>-f 为文件过滤，后面是正则表达式，<code>-f &quot;.*\.js$&quot;</code>为只选着js文件</li><li>-e 表示要排除的<code>文件/文件夹</code>，也是使用正则表达式</li></ul><p>另外apidoc还支持自动化构建工具：</p><ul><li>gulp：<a target="_blank" rel="noopener" href="https://github.com/c0b41/gulp-apidoc">https://github.com/c0b41/gulp-apidoc</a></li><li>grunt：<a target="_blank" rel="noopener" href="https://github.com/apidoc/grunt-apidoc">https://github.com/apidoc/grunt-apidoc</a></li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>可以在之前创建的<code>apidoc.json</code>中添加配置内容：</p><pre><code class="js">&#123;  &quot;name&quot; : &quot;koa-api&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;title&quot;: &quot;API文档&quot;, // 浏览器标题  &quot;url&quot;: &quot;http://localhost:3100&quot;,//所有API的baseUrl  &quot;sampleUrl&quot;: &quot;http://localhost:3100&quot;,//测试API的地址  &quot;description&quot;: &quot;这是一个基于koa开发的RESTful API项目&quot;&#125;</code></pre><p>也可以在package.json中使用已定义的相同字段,并在<code>apidoc</code>对象定义额外字段，如下：</p><pre><code class="js">&#123;  &quot;name&quot;: &quot;koa-api&quot;,  &quot;private&quot;: true,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;这是一个基于koa开发的RESTful API项目&quot;,  &quot;apidoc&quot;: &#123;    &quot;url&quot;: &quot;http://localhost:3100&quot;,//所有API的baseUrl    &quot;sampleUrl&quot;: &quot;http://localhost:3100&quot;,//测试API的地址    &quot;title&quot;: &quot;API文档&quot; //浏览器标题  &#125;,  ...&#125;</code></pre><h2 id="注释规范"><a href="#注释规范" class="headerlink" title="注释规范"></a>注释规范</h2><h4 id="常规使用"><a href="#常规使用" class="headerlink" title="常规使用"></a>常规使用</h4><ul><li><p><code>@api &#123;method&#125; path [title]</code></p><p>  只有使用<code>@api</code>标注的注释块才会在解析之后生成文档</p><p>  <code>method</code>可以有空格，如{POST GET}</p><p>  <code>title</code>会被解析为API文档中导航菜单<code>@apiGroup</code>下的小菜单</p></li><li><p><code>@apiIgnore</code> </p><p>  凡是带此标签的代码块，表示该文档暂时被忽略。父标签：@api。</p></li><li><p><code>@apiGroup name</code></p><p>  提供了对 api 的分组信息，不同的分组，最终可能会被呈现在不同的页面。</p></li><li><p><code>@apiVersion verison</code></p><p>  接口版本，major.minor.patch的形式，如1.1.1</p></li><li><p><code>@apiSampleRequest url</code></p><p>  接口测试地址以供测试，发送请求时，@api method必须为POST/GET等其中一种，该参数也可以在之前的配置文件中统一配置</p></li><li><p><code>@apiPermission name</code></p><p>  name必须独一无二，描述@api的访问权限，如admin/anyone/none</p></li><li><p>示例代码如下：</p></li></ul><pre><code class="js">/** * @api &#123;post&#125; /api/v1/admin  登录后台验证  * @apiGroup admin * @apiVersion 1.1.0 * @apiPermission none * * @apiHeader &#123;String&#125; access-key Users unique access-key. * @apiHeader &#123;String&#125; Authorization 用户验证信息 * */</code></pre><ul><li>对应生成的文档样式如下：</li></ul><p><img src="http://cdn.chuyunt.com/uPic/006y8lVagw1fabo85xestj30r00hrjsr.jpg"></p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li><p><code>@apiParam [(group)] [&#123;type&#125;] [field=defaultValue] [description]</code></p></li><li><p>示例代码如下：</p></li></ul><pre><code class="js">/** * @apiParam &#123;String&#125; [firstname]  Optional Firstname of the User. * @apiParam &#123;String&#125; lastname     Mandatory Lastname. * @apiParam &#123;String&#125; country=&quot;DE&quot; Mandatory with default value &quot;DE&quot;. * @apiParam &#123;Number&#125; [age=18]     Optional Age with default 18. * * @apiParam (Login) &#123;String&#125; pass Only logged in users can post this. *                                 In generated documentation a separate *                                 &quot;Login&quot; Block will be generated. */                                 </code></pre><ul><li>对应生成的文档样式如下：</li></ul><p><img src="http://cdn.chuyunt.com/uPic/006y8lVagw1fabo5ltbj0j31cs0nmwhr.jpg"></p><h4 id="参数结果"><a href="#参数结果" class="headerlink" title="参数结果"></a>参数结果</h4><ul><li><p>相关参数和结果</p><p>  <code>@apiHeader [(group)] [&#123;type&#125;] [field=defaultValue] [description]</code></p><p>  <code>@apiError [(group)] [&#123;type&#125;] field [description]</code></p><p>  <code>@apiSuccess [(group)] [&#123;type&#125;] field [description]</code></p><p>  用法基本类似，分别描述请求参数、头部，响应错误和成功；group表示参数的分组，type表示类型(不能有空格)，入参可以定义默认值(不能有空格)</p></li><li><p>展示示例</p><p>  <code>@apiParamExample [&#123;type&#125;] [title] example</code></p><p>  <code>@apiHeaderExample [&#123;type&#125;] [title] example</code></p><p>  <code>@apiErrorExample [&#123;type&#125;] [title] example</code></p><p>  <code>@apiSuccessExample [&#123;type&#125;] [title] example</code></p><p>  用法完全一致，但是type表示的是example的语言类型example书写成什么样就会解析成什么样，所以最好是书写的时候注意格式化，(许多编辑器都有列模式，可以使用列模式快速对代码添加*号)</p></li><li><p>示例代码如下：</p></li></ul><pre><code class="js">/** * @apiSuccess (200) &#123;String&#125; OK 描述 * @apiSuccessExample &#123;json&#125; Success-Response: *     HTTP/1.1 200 OK *     &#123; *       &quot;firstname&quot;: &quot;John&quot;, *       &quot;lastname&quot;: &quot;Doe&quot; *     &#125; */</code></pre><ul><li>对应生成的文档样式如下：</li></ul><p><img src="http://cdn.chuyunt.com/uPic/006y8lVagw1fabo1cxcizj316w0hggn7.jpg"></p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li><p><code>@apiDefine MySuccess</code></p><p>  定义一个注释块(不包含@api)，配合@apiUse使用可以引入注释块，在@apiDefine内部不可以使用@apiUse</p></li><li><p><code>@apiUse name</code></p><p>  引入一个@apiDefine的注释块</p></li></ul><ul><li><p>示例代码如下：</p><p>  如下代码,定义一个API调用成功的内容,然后在其他API文档中调用这个内容</p></li></ul><pre><code class="js">/** * @apiDefine MySuccess * @apiSuccess &#123;string&#125; firstname The users firstname. * @apiSuccess &#123;number&#125; age The users age. *//** * @api &#123;post&#125; /api/v1/admin  登录后台验证  * @apiGroup admin * @apiUse MySuccess * */</code></pre><ul><li>对应生成的文档样式如下：</li></ul><p><img src="http://cdn.chuyunt.com/uPic/006y8lVagw1faboaw3539j31ce0oodit.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS之修改input range样式</title>
      <link href="/2016-10/css%E4%B9%8B%E4%BF%AE%E6%94%B9input-range%E6%A0%B7%E5%BC%8F/"/>
      <url>/2016-10/css%E4%B9%8B%E4%BF%AE%E6%94%B9input-range%E6%A0%B7%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>今天来探讨一下 HTML5 的 <code>range</code> 这个新的 input 类型，不过重点不是在 <code>range</code> 要如何使用，而是在如何去改变 <code>range</code> 的样式，做出一个漂漂亮亮的滑动杆。</p><p>过去我们要制作美美的滑动杆 ( <code>range slider</code> )，不外乎就是用个 <code>span</code> 或 <code>div</code> ，搭配判断滑鼠座标 ( pageX、pageY ) 与点击事件来制作，就算是 HTML5 具有了 <code>range</code> 的 <code>input</code> 类型，预设的样式只能满足基本的需求，对于有一些要求视觉设计的网站来说，根本就毫无用武之地，只好自己手动干一个 <code>range slider</code> 来用了。</p><span id="more"></span><p>虽然这篇会介绍两种修改 <code>range</code> 样式的方法，但由于 HTML5 与 CSS3 在各个浏览器之间仍然没有完全统一 ( 虽然之前好像就说标准制定完成了 )，所以要改变 <code>range</code> 的样式，仍然必须使用到各家浏览器自己的特有写法来调整，因此下列的范例，主要以 Chrome 为主，也会介绍 Firefox 的用法，至于 IE，能吃吗？哈哈哈~~</p><p>首先要来写一个 range 出来，min 是最小值，max 是最大值，step 是每隔间距，value 是预设数值：</p><pre><code class="html">&lt;input type=&quot;range&quot; min=&quot;0&quot; max=&quot;100&quot; step=&quot;1&quot; value=&quot;50&quot;&gt;</code></pre><p>如果没有意外，看到的长相就会是下面这个样子非常的….嗯…你懂的…</p><input type="range" min="0" max="100" step="1" value="50"><h4 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h4><p>纯 CSS 的做法，由于 <code>range</code> 是 <code>input</code> 的一种类型，我们无法用传统的 CSS 编辑方法来修改样式，这裡必须要使用到<code>-webkit-appearance</code>这个特殊属性，这是 <code>webkit</code> 特有的属性，代表使用系统预设的外观，可惜 <code>W3C</code> 到写这篇文章的时候，都还没有纳入规范 ( 不然 <code>webkit</code> 简直是神呀 )，只要我们将这个属性设为<code>none</code>，那麽原本 <code>range</code> 的样式就不会呈现了，这时我们只要加入自己的背景、阴影…等样式，就可以看到样式被换过来了。</p><pre><code class="css">input[type=&quot;range&quot;]&#123;  -webkit-appearance: none;  overflow:hidden;     /* 限定范围 */  width:200px;  height:20px;  outline : none;      /* 避免点选会有蓝线或虚线 */  background:none;&#125;</code></pre><p><img src="http://cdn.chuyunt.com/picGo/006tNbRwgw1fapes1ngc8g30bf01pq2v.gif?imageslim"></p><p>上面的 CSS 只是针对 <code>range</code> 的本体，但还有一个拉把的按钮样式还没改，这时候我们要使用另外一个 webkit 的伪元素<code>::-webkit-slider-thumb</code>来修改。</p><pre><code class="css">input[type=&quot;range&quot;]::-webkit-slider-thumb&#123;  -webkit-appearance: none;  position: relative;    /* 设为相对位置，为了前后区块的绝对位置而设定 */  width:10px;  height:10px;  background:#f22;  border-radius:50%;  transition:.2s;        /* 点选放大时候的渐变时间 */&#125;</code></pre><p>写完上面这两段，应该就可以看到<code>range slider</code>变成下面这个样子只有一个红点，然后这个红点可以左右拉动。</p><p><img src="http://cdn.chuyunt.com/uPic/006tNbRwgw1fapeqn641pg30bf01pjre.gif"></p><p>接下来要进行的步骤就是加上一些颜色和效果，主要让圆点左边的区域是红色，右边的区域是浅红色，这样看起来才像是不同的 <code>range</code>，为了达到这个目的，我们要使用<code>伪元素裡面的伪元素</code>，也就是在 webkit 的<code>::-webkit-slider-thumb</code>伪元素的前后，各再安插<code>:before</code>和<code>:after</code>的伪元素，并让这两个伪元素颜色不同，就可以做出前后颜色差异的效果。</p><pre><code class="css">input[type=&quot;range&quot;]::-webkit-slider-thumb:before,input[type=&quot;range&quot;]::-webkit-slider-thumb:after&#123;  position: absolute;  top: 3px;  width: 2000px;          /* 长度很长没关係，因为刚刚有用 overflow:hidden 了 */  height: 4px;  content:&quot;&quot;;  pointer-events: none;   /* 让滑鼠可以点击穿透伪元素，不然会点不到下面 */  transition:.2s;&#125;input[type=&quot;range&quot;]::-webkit-slider-thumb:before&#123;  left: -1997px;  background: #f22;&#125;input[type=&quot;range&quot;]::-webkit-slider-thumb:after &#123;  left: 10px;  background: #edc;&#125;</code></pre><p>这样写完之后，应该就已经可以看到前后不同颜色的 <code>range slider</code> 效果。</p><p><img src="http://cdn.chuyunt.com/uPic/006tNbRwgw1fapfbrwsd6g305v01paa3.gif"></p><p>不过光是这样还不够，接着我们要来让点击的时候圆圈会变大，本来想做滑鼠移上去就会变大，但两层伪元素虽然会变大，但位置却无法控制，所以就只好用 <code>active</code> 来代替。</p><pre><code class="css">input[type=&quot;range&quot;]:active::-webkit-slider-thumb:before,input[type=&quot;range&quot;]:active::-webkit-slider-thumb:after&#123;  top: 6px;&#125;input[type=&quot;range&quot;]:active::-webkit-slider-thumb&#123;  width:16px;  height:16px;&#125;input[type=&quot;range&quot;]:active::-webkit-slider-thumb:after &#123;  left: 16px;&#125;</code></pre><p>完成之后的长相就会像下图这样。</p><p><img src="http://cdn.chuyunt.com/uPic/006tNbRwgw1fapfcqqz53g305v01pdfw.gif"></p><p>不过如果是 <code>Firefox</code>，就必须要做一些修改，因为 <code>Firefox</code> 是认不得 <code>webkit</code> 的，要在 <code>Firefox</code> 跑的 CSS 就要写成下面这样，相较于 <code>webkit</code>，<code>Firefox</code> 就显得比较直觉，因为他裡面具有一个<code>::-moz-range-progress</code>的伪元素，利用这个伪元素，我们就不用在前后加个区块，他直接就可以呈现 range 的色彩囉！</p><pre><code class="css">input[type=&quot;range&quot;]&#123;  width:200px;  height:16px;  outline : none;  background:none;&#125;input[type=&quot;range&quot;]::-moz-range-track&#123;  height:4px;  background:#edc;  border:none;&#125;input[type=&quot;range&quot;]::-moz-range-thumb&#123;  width:10px;  height:10px;  background:#f22;  border:none;  border-radius:50%;&#125;input[type=&quot;range&quot;]::-moz-range-thumb:hover,input[type=&quot;range&quot;]:active::-moz-range-thumb&#123;  width:16px;  height:16px;&#125;input[type=&quot;range&quot;]::-moz-range-progress&#123;  height:4px;  background:#f22;&#125;input[type=&quot;range&quot;]::-moz-focus-outer&#123;  border:none;    /* 去除 focus 时候的外框虚线 */&#125;</code></pre><h4 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h4><p>接着介绍一下如何用<code>CSS + jQuery</code>做出一样的效果，同样的，我们要先用<code>-webkit-appearance</code>把原始样式隐藏，先看到<code>input[type=&quot;range&quot;]</code>的样式，这边我利用背景颜色渐层的方式，来完成左右颜色不同的效果 ( 虽然方便，但相对的就不能用纯 CSS 控制 )。</p><pre><code class="css">input[type=&quot;range&quot;]&#123;  -webkit-appearance: none;  border-radius:2px;  width:200px;  height:3px;  background-image:-webkit-linear-gradient(left ,#f22 0%,#f22 50%,#fff 50%, #fff 100%);  box-shadow:inset #ebb 0 0 5px;  outline : none;  transition:.1s;&#125;</code></pre><p>接着看到input[type=”range”]::-webkit-slider-thumb的样式，并加上 hover 的效果：</p><pre><code class="css">input[type=&quot;range&quot;]::-webkit-slider-thumb&#123;  -webkit-appearance: none;  width:10px;  height:10px;  background:#f22;  border-radius:50%;  transition:.1s;&#125;input[type=&quot;range&quot;]::-webkit-slider-thumb:hover,input[type=&quot;range&quot;]::-webkit-slider-thumb:active&#123;  width:16px;  height:16px;&#125;</code></pre><p>因为背景是用渐层产生的呀，如果要动态改背景，就不是纯 CSS 能办得到的领域，这时候就要借助 jquery 来帮忙了，利用简单的focus和mousemove，我们就可以让背景跟着移动咯！</p><pre><code class="js">$(function()&#123;  var r = $(&#39;input&#39;);  r.on(&#39;mouseenter&#39;,function()&#123;    var p = r.val();    r.on(&#39;click&#39;,function()&#123;      p = r.val();      bg(p);    &#125;);    r.on(&#39;mousemove&#39;,function()&#123;      p = r.val();      bg(p);    &#125;);  &#125;);  function bg(n)&#123;      r.css(&#123;        &#39;background-image&#39;:&#39;-webkit-linear-gradient(left ,#f22 0%,#f22 &#39;+n+&#39;%,#fff &#39;+n+&#39;%, #fff 100%)&#39;      &#125;);  &#125;&#125;);</code></pre><p>以上就是用 CSS 和 jQuery 去修改 <code>range slider</code> 样式的基本方法，分享给大家，活用这个方法，就可以做出许多非常有特色的 <code>range slider</code> 囉。</p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS之响应式页面布局</title>
      <link href="/2016-10/css%E4%B9%8B%E5%93%8D%E5%BA%94%E5%BC%8F%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/"/>
      <url>/2016-10/css%E4%B9%8B%E5%93%8D%E5%BA%94%E5%BC%8F%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<p>要说到”响应式布局设计”，我们先来介绍一下另外一个名词：”自适应网页设计”（Responsive Web Design），最早是Ethan Marcotte在2010年提出的。指的是可以自动识别屏幕宽度、并对页面的布局会基于一定的因素搭建做出相应调整的网页设计。自适应布局能够提供一种更加实用的解决方案，使得项目的实现成本更低，并且更加易于测试。自适应布局可以被看作是响应式布局的一个更加廉价的替代品，换句话说自适应网页设计就是一个精简版的响应式布局。当固定宽度与流动宽度结合起来时，自适应就变成了响应式，响应式网页设计指的是页面的布局（流动网格、灵活的图像及媒介查询），响应式布局等于流动网格布局，而自适应布局等于使用固定分割点来进行布局。</p><span id="more"></span><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>这里有2个关键点：如何在不修改Dom结构的前提下调整布局，如何判断屏幕分辨率并应用对应的CSS。且这两点都应该不依赖与JS。</p><h3 id="使用CSS3-Media-Queries（媒介查询）"><a href="#使用CSS3-Media-Queries（媒介查询）" class="headerlink" title="使用CSS3 Media Queries（媒介查询）"></a>使用CSS3 Media Queries（媒介查询）</h3><blockquote><p>根据不同的屏幕分辨率，选择应用不同的Css规则</p></blockquote><p>基本使用</p><pre><code class="css">/* 当屏幕分辨率小于等于400px时，会立即套用以下样式 */@media screen and (max-width:400px)&#123;     .class  &#123;        background:#ccc;     &#125;&#125;/* 当屏幕分辨率大于等于800px时，会立即套用以下样式 */@media screen and (min-width:800px)&#123;    .class  &#123;        background:#666;    &#125;&#125;/* 当屏幕分辨率x&gt;=800px和600px&gt;=x&gt;=520px区间时，会立即套用以下样式 */@media screen and (max-width: 600px) and (min-width: 520px), (min-width: 800px)&#123;   .class  &#123;        background:#ff0;    &#125;&#125;</code></pre><p>link标签引入</p><pre><code class="html">/* 设备屏幕的输出宽度Device Width小于400px时，会立即套用style.css样式 */&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; media=&quot;screen and (max-width:400px)&quot; type=&quot;text/css&quot;&gt;/* 专门针对iPhone4 */&lt;link rel=&quot;stylesheet&quot; media=&quot;only screen and (-webkit-min-device-pixel-ratio: 2)&quot; type=&quot;text/css&quot; href=&quot;iphone4.css&quot; /&gt;/* iPad 在纵向(portrait)时采用portrait.css来渲染页面；在横向（landscape）时采用landscape.css来渲染页面。 */&lt;link rel=&quot;stylesheet&quot; media=&quot;all and (orientation:portrait)&quot; href=&quot;portrait.css&quot; type=&quot;text/css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; media=&quot;all and (orientation:landscape)&quot; href=&quot;landscape.css&quot;  type=&quot;text/css&quot; /&gt;/* Android设备 *//*240px的宽度*/&lt;link rel=&quot;stylesheet&quot; media=&quot;only screen and (max-device-width:240px)&quot; href=&quot;android240.css&quot; type=&quot;text/css&quot; /&gt;/*360px的宽度*/&lt;link rel=&quot;stylesheet&quot; media=&quot;only screen and (min-device-width:241px) and (max-device-width:360px)&quot; href=&quot;android360.css&quot; type=&quot;text/css&quot; /&gt;/*480px的宽度*/&lt;link rel=&quot;stylesheet&quot; media=&quot;only screen and (min-device-width:361px) and (max-device-width:480px)&quot; href=&quot;android480.css&quot; type=&quot;text/css&quot; /&gt;</code></pre><h3 id="网页添加-viewport-meta-标签"><a href="#网页添加-viewport-meta-标签" class="headerlink" title="网页添加 viewport meta 标签"></a>网页添加 viewport meta 标签</h3><p>在网页html head 中添加：</p><pre><code class="html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;&gt;</code></pre><p>该属性可以控制视窗口宽度的大小。viewport设置属性如下：</p><ul><li>width：可设定数值，或者指定为 device-width <blockquote><p>device-width ，主要是为了让整个页面宽度与手机可视宽度相同，这样就可以简单相容于不同机型屏幕大小，如果这边width沒有设定的话，就会依照html/css给予的width当作预设值。</p></blockquote></li><li>height：可设定数值，或者指定为 device-height </li><li>initial-scale：第一次进入页面的初始比例 </li><li>minimum-scale：允许缩小最小比例 </li><li>maximum-scale：允许放大最大比例 </li><li>user-scalable：允许使用者缩放，1 or 0 (yes or no)</li></ul><p>如果希望在不同device使用不同缩放大小，就必须使用javascript，检测UA(User agent)，动态设定viewport，如下：</p><pre><code class="js">viewport = document.querySelector(&quot;meta[name=viewport]&quot;);viewport.setAttribute(&#39;content&#39;, &#39;width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=0;&#39;);</code></pre><h3 id="流动布局"><a href="#流动布局" class="headerlink" title="流动布局"></a>流动布局</h3><h4 id="float"><a href="#float" class="headerlink" title="float"></a>float</h4><p>流动布局的含义是各个位置都是浮动的，不是固定不变的</p><pre><code class="css">.main &#123; float: right; width: 70%; &#125; .leftBar &#123; float: left; width: 25%; &#125; </code></pre><p>float的好处是，如果宽度太小，放不下两个元素，后面的元素会自动滚动到前面元素的下方，不会在水平方向overflow（溢出），避免了水平滚动条的出现。</p><h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><p>Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。详细内容参见<a href="http://lion1ou.tech/2016/10/15/">css之flex布局</a></p><h3 id="流式媒体"><a href="#流式媒体" class="headerlink" title="流式媒体"></a>流式媒体</h3><pre><code class="css">img, video, canvas &#123;  max-width: 100%;&#125;</code></pre><p>要使媒体按等比缩放，一般不需要规定媒体高度。且图片最好不用background-image,因为这样不会按照等比缩放。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="不使用绝对宽度"><a href="#不使用绝对宽度" class="headerlink" title="不使用绝对宽度"></a>不使用绝对宽度</h4><p>不能使用绝对宽度（margin-left:5px）的布局，也不能使用具有绝对宽度(例如：width：200px)的元素,而最好使用百分比宽度width:20%;或者with:auto;</p><h4 id="字体单位"><a href="#字体单位" class="headerlink" title="字体单位"></a>字体单位</h4><p>不使用绝度单位<code>px</code>，最好使用<code>rem</code>（参考<code>&lt;html&gt;</code>的字体大小、全局性、CSS3）、<code>em</code>(参考父元素的字体大小)。</p><pre><code class="css">html &#123; font-size: 100%; &#125; /*上面的代码指定，字体大小是页面默认大小的100%，即16像素。*/h1 &#123; font-size: 1.5rem; &#125;  /*h1的大小是默认大小的1.5倍，即24像素（24/16=1.5）*/.small &#123; font-size: 0.875rem; &#125; /*small元素的大小是默认大小的0.875倍，即14像素（14/16=0.875）*/</code></pre><h4 id="普通元素的栅格布局"><a href="#普通元素的栅格布局" class="headerlink" title="普通元素的栅格布局"></a>普通元素的栅格布局</h4><p>对于普通的div布局，使用了通用简单的栅格布局，相信这个大家都知道原理：</p><pre><code class="css">.row&#123;  width: 100%;&#125;.row .col-1 &#123;  width: 8.33333333333%&#125;/* ...比较多，这里省略 */.row .col-12 &#123;  width: 100%&#125;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a target="_blank" rel="noopener" href="http://www.alloyteam.com/2015/04/zi-shi-ying-she-ji-yu-xiang-ying-shi-wang-ye-she-ji-qian-tan/">自适应设计与响应式网页设计</a></li><li><a target="_blank" rel="noopener" href="http://www.w3cplus.com/content/css3-media-queries">CSS3 Media Queries_media queries 教程_w3cplus</a></li><li><a target="_blank" rel="noopener" href="http://www.w3cplus.com/css/advanced-html-css-lesson4-responsive-web-design.html">HTML和CSS高级指南之四——响应式设计_HTML和CSS高级指南 教程_w3cplus</a></li><li><a target="_blank" rel="noopener" href="http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html">使用Flexible实现手淘H5页面的终端适配_双11前端技术连载</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git学习</title>
      <link href="/2016-09/git%E5%AD%A6%E4%B9%A0/"/>
      <url>/2016-09/git%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p><span id="more"></span><h2 id="可视化软件"><a href="#可视化软件" class="headerlink" title="可视化软件"></a>可视化软件</h2><blockquote><p>官网在这里：<a target="_blank" rel="noopener" href="https://www.git-scm.com/">https://www.git-scm.com/</a>，在git 官网上这种GUI工具多达十几款，在Mac平台我推荐一两款好用的软件GUI，官网GUI客户端列表：<a target="_blank" rel="noopener" href="https://www.git-scm.com/downloads/guis">https://www.git-scm.com/downloads/guis</a></p></blockquote><ul><li>DiffMerge </li></ul><blockquote><p>是一款可视化的文件比较（也可进行目录比较）与合并工具。该软件主要具有文件差异比较、自动化的文件合并、以及文件夹差异比较这三大功能。这里下载：<a target="_blank" rel="noopener" href="http://sourcegear.com/diffmerge/">http://sourcegear.com/diffmerge/</a></p></blockquote><ul><li>SourceTree </li></ul><blockquote><p>(Windows/Mac)免费，官网在这里：<a target="_blank" rel="noopener" href="https://www.sourcetreeapp.com/">https://www.sourcetreeapp.com/</a></p></blockquote><ul><li>Gitup</li></ul><blockquote><p>(Mac)免费开源，好玩的Gitup是 Mac OS X 的全功能开源 Git 客户端,提供快速,安全的操作,直接在硬盘上与 Git 数据库交互,操作库的图而不是操作 commits，官网在这里：<a target="_blank" rel="noopener" href="http://gitup.co/">http://gitup.co/</a></p></blockquote><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><ol><li>安装git for window</li><li>安装TortoiseGit-1.8.16.0-64bit.msi</li><li>配置path C:\Program Files\Git\bin</li><li>详见<a target="_blank" rel="noopener" href="http://blog.csdn.net/renfufei/article/details/41647875">enter link description here</a></li></ol><h4 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h4><ol><li>最为简单的方式是安装 .dmg 格式的安装包。其中带有一个正在解包图标的文件（扩展名为 .pkg ）是 Git 的安装程序</li><li>点击扩展名为 .pkg 的安装程序，开始 Git 的安装</li><li>安装完毕，git 会被安装到 /usr/local/git/bin/ 目录下。重启终端程序，才能让 /etc/paths.d/git 文件为 PATH 环境变量中添加的新路径注册生效。然后就可以在终端中直接运行 git 命令了。</li><li>下载地址：<a target="_blank" rel="noopener" href="http://code.google.com/p/git-osx-installer/">enter link description here</a></li></ol><h2 id="绑定远程仓库"><a href="#绑定远程仓库" class="headerlink" title="绑定远程仓库"></a>绑定远程仓库</h2><h4 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h4><pre><code class="shell">git config --global user.name &quot;xxx&quot;          # 配置用户名   git config --global user.email &quot;xxx@xxx.com&quot; # 配置邮件  git config --list                            # 检查已有的配置信息</code></pre><h4 id="创建SSH-Key"><a href="#创建SSH-Key" class="headerlink" title="创建SSH Key"></a>创建SSH Key</h4><ul><li>打开终端，输入 <code>ssh-keygen -t rsa -C &quot;xxxxxx@qq.com&quot;</code> 邮箱更新为自己的</li><li>回车保存默认位置</li><li>输入密码,用来加密私钥(以后就要用这个密码)</li><li>输入<code>cat ~/.ssh/id_rsa.pub</code>，即返回对应id_rsa.pub(公钥)信息，复制所有内容（待用）</li></ul><h4 id="与远程仓库绑定"><a href="#与远程仓库绑定" class="headerlink" title="与远程仓库绑定"></a>与远程仓库绑定</h4><ul><li>在远程服务器,如coding/github页面内找到<code>添加公钥选项</code>,粘贴刚刚复制的内容,添加即可.</li></ul><p><img src="http://cdn.chuyunt.com/uPic/72f96cbagw1f5ri2y4lq6j20li0c1aam.jpg" alt="add-key.png"></p><h4 id="测试是否配置成功，首次建立链接会要求信任主机："><a href="#测试是否配置成功，首次建立链接会要求信任主机：" class="headerlink" title="测试是否配置成功，首次建立链接会要求信任主机："></a>测试是否配置成功，首次建立链接会要求信任主机：</h4><p><code>ssh -T git@github.com</code></p><p><code>ssh -T git@git.coding.net</code></p><p><code>ssh-add ~/.ssh/id_rsa</code>  运行此命令，解决每次都需要输入密码的问题。</p><p><img src="http://cdn.chuyunt.com/uPic/git%E5%A4%9A%E6%AC%A1%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81.png" alt="git多次输入密码.png"></p><p><code>git config --global credential.helper store</code></p><pre><code>ssh-add ~/.ssh/id_rsaEnter passphrase for /Users/lionluo/.ssh/id_rsa:Identity added: /Users/lionluo/.ssh/id_rsa (/Users/lionluo/.ssh/id_rsa)</code></pre><p>可参考coding<a target="_blank" rel="noopener" href="https://coding.net/help/doc/account/ssh-key.html">官方文档</a></p><blockquote><p>如果返回的结果如下：</p></blockquote><p><img src="http://cdn.chuyunt.com/uPic/72f96cbagw1f5ri63qh0sj20gm01vwf5.jpg"></p><blockquote><p>输入yes，就能看到</p></blockquote><p><img src="http://cdn.chuyunt.com/uPic/72f96cbagw1f5ri77dmgyj20j500raa8.jpg"></p><blockquote><p>这样你的SSH key就配置完成了。</p></blockquote><blockquote><p>到这里github仓库已经建好了。接下来是本地部分了。</p></blockquote><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h4 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h4><pre><code class="shell">git init                        #初始化git仓库  git add .                       #添加所有文件到暂存区  git status                      #查看Git仓库状态，要随时掌握工作区的状态  git commit -m &#39;xxx&#39;             #提交已添加的文件到git仓库  git commit -am &#39;xxx&#39;            #将add和commit合为一步  git log /git reflog             #显示最近到最远的提交日志（历史）/（未来）  git reset --hard  &lt;commitId&gt;    #HEAD^--返回上个版本，  #HEAD~100--返回上100个版本  #commit_id--对应版本的commitId  </code></pre><h4 id="远程命令"><a href="#远程命令" class="headerlink" title="远程命令"></a>远程命令</h4><ul><li><code>git remote</code>命令就用于管理主机名。</li></ul><pre><code class="shell">git remote add &lt;主机名&gt; &lt;网址&gt;           #用于添加远程主机  git remote rm &lt;主机名&gt;                  #用于删除远程主机git remote rename &lt;原主机名&gt; &lt;新主机名&gt;   #用于远程主机的改名git remote (-v)                        #要查看远程库的信息(显示更详细的信息)  </code></pre><ul><li><code>git fetch</code>命令用于取回远程更新至本地  </li></ul><pre><code class="shell">git fetch &lt;远程主机名&gt;             #将某个远程更新,全部取回本地git fetch &lt;远程主机名&gt; &lt;分支名&gt;     #取回特定分支的更新#所取回的更新，在本地主机上要用&quot;远程主机名/分支名&quot;的形式读取。比如origin主机的master，就要用origin/master读取。</code></pre><ul><li><code>git pull</code>取回远程主机某个分支的更新，再与本地的指定分支合并。</li></ul><pre><code class="shell">git pull origin next(:maste)    #取回origin主机的next分支，与当前(本地的master)分支合并</code></pre><ul><li><code>git push</code>命令用于将本地分支的更新，推送到远程主机</li></ul><pre><code class="shell">git push origin &lt;本地分支名&gt;:&lt;远程分支名&gt; #提交本地的某分支，与origin主机的某分支合并git push -u origin master             #将本地master分支推送到origin主机,同时指定origin为默认主机，之后就可以不加任何参数使用git push   git push --all origin                 #将本地`所有分支`推送到origin主机git push origin master                #将master分支推送到origin远程主机的master分支上#如果推送失败，先用git pull抓取远程的新提交；git push origin --tags                #推送包含标签(tag)   git push -f                           #强推，即利用强覆盖方式用你本地的代码替代git仓库内的内容</code></pre><ul><li><code>git clone</code>命令用于克隆远程仓库到本地</li></ul><pre><code class="shell">git clone  &lt;url&gt;                      #克隆远程仓库到本地git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;    #克隆远程仓库到本地指定文件名</code></pre><h4 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h4><blockquote><ul><li><code>master</code>分支是主分支，因此要时刻与远程同步，程序的稳定版本；</li><li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li><li><code>bug</code>分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li><li><code>feature</code>分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li></ul></blockquote><pre><code class="shell">git branch                         #查看所有分支  git branch &lt;name&gt;                  #创建分支  git checkout &lt;name&gt;                #切换分支  git checkout -b &lt;name&gt;             #创建并切换分支git checkout -b newBrach origin/master #在origin/master的基础上，创建一个新分支git merge &lt;name&gt;                   #合并某分支到当前分支  git branch -d &lt;name&gt;               #删除分支git branch -a                      #显示所有分支git branch -r                      #显示所有远程分支git branch --merged                #显示所有已合并到当前分支的分支git branch --no-merged             #显示所有未合并到当前分支的分支git branch -m master master_copy   #本地分支改名</code></pre><h4 id="标签操作"><a href="#标签操作" class="headerlink" title="标签操作"></a>标签操作</h4><pre><code class="shell">git tag &lt;name&gt;                        #用于新建一个标签，默认为HEAD，也可以指定一个commit id；  git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;#可以指定标签信息；  git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;#可以用PGP签名标签；  git tag                               #查看所有标签  git push origin &lt;tagname&gt;             #推送一个本地标签；  git push origin --tags                #推送全部未推送过的本地标签；  git tag -d &lt;tagname&gt;                  #删除一个本地标签；  git push origin :refs/tags/&lt;tagname&gt;  #删除一个远程标签。  </code></pre><h4 id="其他使用场景"><a href="#其他使用场景" class="headerlink" title="其他使用场景"></a>其他使用场景</h4><ul><li>保存进度</li></ul><blockquote><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场。</p></blockquote><ul><li>合并分支</li></ul><blockquote><p><code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code>  合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p></blockquote><ul><li>撤销修改</li></ul><blockquote><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- &lt;fileName&gt;。</code> <code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p></blockquote><blockquote><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;fileName&gt;</code>，就回到了场景1，第二步按场景1操作。</p></blockquote><blockquote><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，则需要版本回退<code>git reset --hard HEAD^</code>，不过前提是没有推送到远程库。</p></blockquote><h4 id="访问本地git服务器"><a href="#访问本地git服务器" class="headerlink" title="访问本地git服务器"></a>访问本地git服务器</h4><p>ssh 指定私钥的配置管理，为本地添加 ssh 别名，编辑 ~/.ssh/config ，如果没有该文件，创建一个:</p><pre><code class="shell">$ vi ~/.ssh/config</code></pre><p>在 config 中添加：</p><pre><code class="shell"># 注释说明# Host 别名# HostName  域名或 ip# User 登陆服务器用的账号# Port 端口号(默认22，可以不填，如果服务器修改了`ssh`登录端口号，此处需要修改)# IdentityFile 密钥文件的位置</code></pre><p>例如设置为:</p><pre><code class="shell">Host git.project-y.comHostName 192.168.126.213User lion1ou# Port (不填则为默认值) # IdentityFile (不填则为默认值)</code></pre><p>现在，可以通过 git clone 命令克隆远程仓库了：</p><pre><code class="shell">$ git clone git@git.project-y.com:y/docs.git</code></pre><h4 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a><code>.gitignore</code></h4><p>在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可。</p><p>如下：</p><pre><code>.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*//themes/next</code></pre><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><h4 id="出现私钥权限太开放"><a href="#出现私钥权限太开放" class="headerlink" title="出现私钥权限太开放"></a>出现私钥权限太开放</h4><pre><code>&#123; .ssh &#125;  » ssh -T git@github.com                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Permissions 0670 for &#39;/home/Lion/.ssh/id_rsa&#39; are too open.It is recommended that your private key files are NOT accessible by others.This private key will be ignored.Load key &quot;/home/Lion/.ssh/id_rsa&quot;: bad permissionsPermission denied (publickey).</code></pre><p><strong>解决办法：</strong></p><p>执行命令：<code>chmod 600 /home/Lion/.ssh/id_rsa</code></p><h4 id="出现github上传ssh-key后仍须输入密码的问题"><a href="#出现github上传ssh-key后仍须输入密码的问题" class="headerlink" title="出现github上传ssh-key后仍须输入密码的问题"></a>出现github上传ssh-key后仍须输入密码的问题</h4><p>原因是因为我们使用https方式克隆</p><pre><code class="bash">git clone https://github.com/Name/project.git</code></pre><p>这样便会在你git push或者git pull时候要求输入用户名和密码 </p><p><strong>解决办法：</strong></p><p>使用ssh方式克隆仓库</p><pre><code class="bash">git clone git@github.com:Name/project.git</code></pre><p>当如，如果你已经用https方式克隆了仓库，就不必删除仓库重新克隆，只需将<code>.git/config</code>文件中的</p><pre><code class="bash">url = https://github.com/Name/project.git # 改成 =&gt; url = git@github.com:Name/project.git </code></pre><h4 id="git相关学习资源"><a href="#git相关学习资源" class="headerlink" title="git相关学习资源"></a>git相关学习资源</h4><ol><li>git的详细介绍：<a target="_blank" rel="noopener" href="http://blog.jobbole.com/25775/">Git详解之一：Git起步</a></li><li>git安装和配置：<a target="_blank" rel="noopener" href="http://blog.csdn.net/renfufei/article/details/41647875">Git安装与配置</a></li><li>git与TortoiseGit(小乌龟)的基本操作：<a target="_blank" rel="noopener" href="http://blog.csdn.net/renfufei/article/details/41647973">Git与TortoiseGit基本操作</a></li><li>git的基础教程：<a target="_blank" rel="noopener" href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰的gitgit教程</a></li><li>git的使用流程：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/tugenhua0707/p/4050072.html">Git使用教程</a></li><li>git远程操作详解：<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html">阮一峰的Git远程操作详解</a></li><li>git常用命令总结：<a target="_blank" rel="noopener" href="http://www.haorooms.com/post/git_common_ml">git常用命令总结</a></li><li>搭建基于SSH的Git服务器：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/zhongxinWang/p/4236326.html">Windows下搭建基于SSH的Git服务器</a>;<a target="_blank" rel="noopener" href="http://blog.chinaunix.net/xmlrpc.php?r=blog/article&uid=20078486&id=3864573">自己动手搭建Git服务器-Gitblit</a></li><li>git整体介绍：<a target="_blank" rel="noopener" href="https://gold.xitu.io/entry/57700fca165abd00547f788d">30 分钟 git 命令入门到放弃 - 掘金</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript之正则表达式</title>
      <link href="/2016-08/javascript%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2016-08/javascript%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>正则表达式（Regular Expression，在代码中常简写为regex、regexp或RE）是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为”元字符”）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。</p><span id="more"></span><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><p>所谓特殊字符，就是一些有特殊含义的字符。</p><table><thead><tr><th>特殊字符</th><th>描述</th></tr></thead><tbody><tr><td>$</td><td>匹配输入字符串的结尾位置。</td></tr><tr><td>()</td><td>标记一个子表达式的开始和结束位置。</td></tr><tr><td>*</td><td>匹配前面的子表达式零次或多次。</td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次。</td></tr><tr><td>.</td><td>匹配除换行符 <code>\n</code> 之外的任何单字符</td></tr><tr><td><code>[]</code></td><td>一个字符集合。匹配方括号的中任意字符，包括转义序列。你可以使用破折号（-）来指定一个字符范围。对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。</td></tr><tr><td>?</td><td>匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。</td></tr><tr><td>\</td><td>将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。</td></tr><tr><td>^</td><td>匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不包含该字符集合（即“非”）。</td></tr><tr><td>{</td><td>标记限定符表达式的开始。</td></tr><tr><td>&#124;</td><td>指明两项之间的一个选择。</td></tr></tbody></table><h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>*</td><td>匹配前面的子表达式零次或多次。</td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次。</td></tr><tr><td>?</td><td>匹配前面的子表达式零次或一次。</td></tr><tr><td>{n}</td><td>n 是一个非负整数。匹配确定的 n 次。</td></tr><tr><td>{n,}</td><td>n 是一个非负整数。至少匹配n 次。</td></tr><tr><td>{n,m}</td><td>m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。</td></tr></tbody></table><h2 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h2><p>定位符用来描述字符串或单词的边界，^和$分别指字符串的开始与结束，\b描述单词的前或后边界，\B表示非单词边界。</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>^</td><td>匹配输入字符串开始的位置。</td></tr><tr><td>$</td><td>匹配输入字符串结尾的位置。</td></tr><tr><td>\b</td><td>匹配一个字边界，即字与空格间的位置。</td></tr><tr><td>\B</td><td>非字边界匹配。</td></tr></tbody></table><h2 id="修饰符（添加在最后）"><a href="#修饰符（添加在最后）" class="headerlink" title="修饰符（添加在最后）"></a>修饰符（添加在最后）</h2><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>/i</td><td>忽略大小写</td></tr><tr><td>/g</td><td>全文查找出现的所有匹配字符</td></tr><tr><td>/m</td><td>多行查找</td></tr><tr><td>/gi</td><td>全文查找、忽略大小写</td></tr><tr><td>/ig</td><td>全文查找、忽略大小写</td></tr></tbody></table><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>\d</td><td>匹配一个数字。等价于[0-9]。</td></tr><tr><td>\D</td><td>匹配一个非数字字符。等价于[^0-9]。</td></tr><tr><td>\w</td><td>匹配一个单字字符（字母、数字或者下划线）。等价于[A-Za-z0-9_]。</td></tr><tr><td>\W</td><td>匹配一个非单字字符。等价于[^A-Za-z0-9_]。</td></tr><tr><td>\s</td><td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td></tr><tr><td>\S</td><td>匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td></tr></tbody></table><h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><p>1、正向预查</p><ul><li><p>(?:pattern) 匹配结果。Java(?:6|7)等效于Java6|Java7，结果Java6 Java7</p></li><li><p>(?=pattern) 正向匹配。Java(?=6)，匹配后面跟着6的Java，即第一个Java，结果Java6 Java7</p></li><li><p>(?!pattern) 正向不匹配。Java(?!6)，匹配后面不跟着6的Java，即第二个Java，结果Java6 Java7</p></li></ul><p>2、反向预查</p><ul><li><p>(?&lt;=pattern) 反向匹配。(?&lt;=J)a，匹配紧跟字母J后面的a，结果Java6 Java7</p></li><li><p>(?&lt;!pattern) 反向不匹配。(?&lt;!J)a，不匹配紧跟字母J后面的a，结果Java6 Java7</p></li></ul><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><pre><code class="js">var reg = /\d+/g  // 常规写的时候可以不需要 两个|（斜杠）var reg1 = new RegExp(&#39;\\d+&#39;, &#39;g&#39;) // 注意，在使用引号来表示正则时，一定要两个\\（斜杠）, 因为一个\（斜杠）会被转义掉reg.test(&#39;222222&#39;)  // truereg1.test(&#39;2333&#39;)   // truereg.exec(&#39;quehjq   whdja129u318873e&#39;) // [&quot;129&quot;, index: 14, input: &quot;quehjq   whdja129u318873e&quot;, groups: undefined]&#39;ssss128367812asda3485762  dfsd32424&#39;.match(reg) //  [&quot;128367812&quot;, &quot;3485762&quot;, &quot;32424&quot;]&#39;ssss128367812asda3485762  dfsd32424&#39;.replace(reg, &#39;*&#39;) // ssss*asda*  dfsd*&#39;ssss128367812asda3485762  dfsd32424&#39;.replace(reg, &#39;$&amp;,&#39;) // ssss128367812,asda3485762,  dfsd32424,&#39;ssss128367812asda3485762  dfsd32424&#39;.search(reg) // 4&#39;ssss128367812asda3485762  dfsd32424&#39;.split(reg) //  [&quot;ssss&quot;, &quot;asda&quot;, &quot;  dfsd&quot;, &quot;&quot;]</code></pre><ul><li>test – 用来测试字符串是否匹配相应的正则规则，返回boolean；</li><li>exec – 返回包含第一个匹配的数组</li><li>match – 返回所有匹配的数组</li><li>replace – 完成字符串中匹配值的指定替换,返回替换后的字符串</li><li>search – 类似于indexOf的用法，不过search支持正则，返回第一个匹配值的index</li><li>split – 根据规则拆分字符串，返回被拆分后的字符串数组</li></ul><h2 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h2><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td><code>^[\u4e00-\u9fa5]&#123;0,&#125;$</code></td><td>匹配中文字符串</td></tr><tr><td><code>[^\x00-\xff]</code></td><td>匹配双字节字符(包括汉字在内)</td></tr><tr><td><code>\n\s*\r</code></td><td>匹配空白行</td></tr><tr><td><code>^\s*&#124;\s*$</code></td><td>匹配首尾空白字符</td></tr><tr><td><code>\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*</code></td><td>匹配Email地址</td></tr><tr><td><code>\d&#123;3&#125;-\d&#123;8&#125;*&#124;\d&#123;4&#125;-\d&#123;7&#125;</code></td><td>匹配国内电话号码</td></tr><tr><td><code>[1-9][0-9]&#123;4,&#125;</code></td><td>匹配腾讯QQ号</td></tr><tr><td><code>[1-9]\d&#123;5&#125;(?!\d)</code></td><td>匹配中国邮政编码</td></tr><tr><td><code>[a-zA-z]+://[^\s]*</code></td><td>匹配网址URL</td></tr><tr><td><code>^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$</code></td><td>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)</td></tr></tbody></table><p>匹配特定数字：</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td><code>^[1-9]\d*$</code></td><td>匹配正整数</td></tr><tr><td><code>^-[1-9]\d*$</code></td><td>匹配负整数</td></tr><tr><td><code>^-?[1-9]\d*$</code></td><td>匹配整数</td></tr><tr><td><code>^[1-9]\d*&#124;0$</code></td><td>匹配非负整数（正整数 + 0）</td></tr><tr><td><code>^-[1-9]\d*&#124;0$</code></td><td>匹配非正整数（负整数 + 0）</td></tr><tr><td><code>^[1-9]\d<em>.\d</em>&#124;0.\d*[1-9]\d*$</code></td><td>匹配正浮点数</td></tr><tr><td><code>^-([1-9]\d<em>.\d</em>&#124;0.\d*[1-9]\d*)$</code></td><td>匹配负浮点数</td></tr><tr><td><code>^-?([1-9]\d<em>.\d</em>&#124;0.\d*[1-9]\d*&#124;0?.0+&#124;0)$</code></td><td>匹配浮点数</td></tr><tr><td><code>^[1-9]\d<em>.\d</em>&#124;0.\d*[1-9]\d*&#124;0?.0+&#124;0$</code></td><td>匹配非负浮点数（正浮点数 + 0）</td></tr><tr><td><code>^(-([1-9]\d<em>.\d</em>&#124;0.\d*[1-9]\d*))&#124;0?.0+&#124;0$</code></td><td>匹配非正浮点数（负浮点数 + 0）</td></tr></tbody></table><p>匹配特定字符串：</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td><code>^[A-Za-z]+$</code></td><td>匹配由26个英文字母组成的字符串</td></tr><tr><td><code>^[A-Z]+$</code></td><td>匹配由26个英文字母的大写组成的字符串</td></tr><tr><td><code>^[a-z]+$</code></td><td>匹配由26个英文字母的小写组成的字符串</td></tr><tr><td><code>^[A-Za-z0-9]+$</code></td><td>匹配由数字和26个英文字母组成的字符串</td></tr><tr><td><code>^\w+$</code></td><td>匹配由数字、26个英文字母或者下划线组成的字符串</td></tr></tbody></table><h3 id="用户名正则"><a href="#用户名正则" class="headerlink" title="用户名正则"></a>用户名正则</h3><pre><code class="js">//用户名正则，4到16位（字母，数字，下划线，减号）var uPattern = /^[a-zA-Z0-9_-]&#123;4,16&#125;$/;//输出 trueconsole.log(uPattern.test(&quot;caibaojian&quot;));</code></pre><h3 id="密码强度正则"><a href="#密码强度正则" class="headerlink" title="密码强度正则"></a>密码强度正则</h3><pre><code class="js">//密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符var pPattern = /^.*(?=.&#123;6,&#125;)(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&amp;*? ]).*$/;//输出 trueconsole.log(&quot;==&quot;+pPattern.test(&quot;caibaojian#&quot;));</code></pre><h3 id="整数正则"><a href="#整数正则" class="headerlink" title="整数正则"></a>整数正则</h3><pre><code class="js">//正整数正则var posPattern = /^\d+$/;//负整数正则var negPattern = /^-\d+$/;//整数正则var intPattern = /^-?\d+$/;//输出 trueconsole.log(posPattern.test(&quot;42&quot;));//输出 trueconsole.log(negPattern.test(&quot;-42&quot;));//输出 trueconsole.log(intPattern.test(&quot;-42&quot;));</code></pre><h3 id="数字正则"><a href="#数字正则" class="headerlink" title="数字正则"></a>数字正则</h3><pre><code class="js">可以是整数也可以是浮点数//正数正则var posPattern = /^\d*\.?\d+$/;//负数正则var negPattern = /^-\d*\.?\d+$/;//数字正则var numPattern = /^-?\d*\.?\d+$/;console.log(posPattern.test(&quot;42.2&quot;));console.log(negPattern.test(&quot;-42.2&quot;));console.log(numPattern.test(&quot;-42.2&quot;));</code></pre><h3 id="Email正则"><a href="#Email正则" class="headerlink" title="Email正则"></a>Email正则</h3><pre><code class="js">//Email正则var ePattern = /^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]&#123;2,4&#125;)$/;//输出 trueconsole.log(ePattern.test(&quot;99154507@qq.com&quot;));</code></pre><h3 id="手机号码正则"><a href="#手机号码正则" class="headerlink" title="手机号码正则"></a>手机号码正则</h3><pre><code class="js">//手机号正则var mPattern = /^1[34578]\d&#123;9&#125;$/; //http://caibaojian.com/regexp-example.html//输出 trueconsole.log(mPattern.test(&quot;15507621888&quot;));</code></pre><h3 id="身份证号正则"><a href="#身份证号正则" class="headerlink" title="身份证号正则"></a>身份证号正则</h3><pre><code class="js">//身份证号（18位）正则var cP = /^[1-9]\d&#123;5&#125;(18|19|([23]\d))\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d&#123;3&#125;[0-9Xx]$/;//输出 trueconsole.log(cP.test(&quot;11010519880605371X&quot;));</code></pre><h3 id="URL正则"><a href="#URL正则" class="headerlink" title="URL正则"></a>URL正则</h3><pre><code class="js">//URL正则var urlP= /^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]&#123;2,6&#125;)([\/\w \.-]*)*\/?$/;//输出 trueconsole.log(urlP.test(&quot;http://caibaojian.com&quot;));</code></pre><h3 id="IPv4地址正则"><a href="#IPv4地址正则" class="headerlink" title="IPv4地址正则"></a>IPv4地址正则</h3><pre><code class="js">//ipv4地址正则var ipP = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;//输出 trueconsole.log(ipP.test(&quot;115.28.47.26&quot;));</code></pre><h3 id="十六进制颜色正则"><a href="#十六进制颜色正则" class="headerlink" title="十六进制颜色正则"></a>十六进制颜色正则</h3><pre><code class="js">//RGB Hex颜色正则var cPattern = /^#?([a-fA-F0-9]&#123;6&#125;|[a-fA-F0-9]&#123;3&#125;)$/;//输出 trueconsole.log(cPattern.test(&quot;#b8b8b8&quot;));</code></pre><h3 id="日期正则"><a href="#日期正则" class="headerlink" title="日期正则"></a>日期正则</h3><pre><code class="js">//日期正则，简单判定,未做月份及日期的判定var dP1 = /^\d&#123;4&#125;(\-)\d&#123;1,2&#125;\1\d&#123;1,2&#125;$/;//输出 trueconsole.log(dP1.test(&quot;2017-05-11&quot;));//输出 trueconsole.log(dP1.test(&quot;2017-15-11&quot;));//日期正则，复杂判定var dP2 = /^(?:(?!0000)[0-9]&#123;4&#125;-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$/;//输出 trueconsole.log(dP2.test(&quot;2017-02-11&quot;));//输出 falseconsole.log(dP2.test(&quot;2017-15-11&quot;));//输出 falseconsole.log(dP2.test(&quot;2017-02-29&quot;));</code></pre><h3 id="QQ号码正则"><a href="#QQ号码正则" class="headerlink" title="QQ号码正则"></a>QQ号码正则</h3><pre><code class="js">//QQ号正则，5至11位var qqPattern = /^[1-9][0-9]&#123;4,10&#125;$/;//输出 trueconsole.log(qqPattern.test(&quot;65974040&quot;));</code></pre><h3 id="微信号正则"><a href="#微信号正则" class="headerlink" title="微信号正则"></a>微信号正则</h3><pre><code class="js">//微信号正则，6至20位，以字母开头，字母，数字，减号，下划线var wxPattern = /^[a-zA-Z]([-_a-zA-Z0-9]&#123;5,19&#125;)+$/;//输出 trueconsole.log(wxPattern.test(&quot;caibaojian_com&quot;));</code></pre><h3 id="车牌号正则"><a href="#车牌号正则" class="headerlink" title="车牌号正则"></a>车牌号正则</h3><pre><code class="js">//车牌号正则var cPattern = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]&#123;1&#125;[A-Z]&#123;1&#125;[A-Z0-9]&#123;4&#125;[A-Z0-9挂学警港澳]&#123;1&#125;$/;//输出 trueconsole.log(cPattern.test(&quot;粤B39006&quot;));</code></pre><h3 id="包含中文正则"><a href="#包含中文正则" class="headerlink" title="包含中文正则"></a>包含中文正则</h3><pre><code class="js">//包含中文正则var cnPattern = /[\u4E00-\u9FA5]/;//输出 trueconsole.log(cnPattern.test(&quot;蔡宝坚&quot;));</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript之前端资源预加载进度条</title>
      <link href="/2016-08/javascript%E4%B9%8B%E5%89%8D%E7%AB%AF%E8%B5%84%E6%BA%90%E9%A2%84%E5%8A%A0%E8%BD%BD%E8%BF%9B%E5%BA%A6%E6%9D%A1/"/>
      <url>/2016-08/javascript%E4%B9%8B%E5%89%8D%E7%AB%AF%E8%B5%84%E6%BA%90%E9%A2%84%E5%8A%A0%E8%BD%BD%E8%BF%9B%E5%BA%A6%E6%9D%A1/</url>
      
        <content type="html"><![CDATA[<p>我们经常会看到，一些站点在首次进入的时候会先显示一个进度条，等资源加载完毕后再呈现页面，然后整个页面的操作就会非常流畅，因为之后没必要再等待加载资源了。尤其是在移动端，或者是页游中，这样做能避免页面出现白屏（等待加载图片），很大程度提升用户体验。那这种技术是如何实现的呢？其实非常简单，本文就来从基础细节探究一番。</p><span id="more"></span><h3 id="资源预加载的原因"><a href="#资源预加载的原因" class="headerlink" title="资源预加载的原因"></a>资源预加载的原因</h3><p>大多时候，我们的页面并不是一次渲染完毕的，而是随着用户的操作，不断修改DOM节点，如果你动态插入了一个图片节点，那么浏览器要马上发一个http请求，把图片加载下来然后渲染在页面上，如果用户此时的网速不佳，那么加载这张图片可能就会消耗几秒钟时间，此时页面上什么都没有（白屏）。最坏的情况，如果你的应用图片很多，半天加载不出几张图，用户很可能就在白屏的那几秒跳走了。在游戏中更严重，主角的图片如果加载不出来，让用户玩空气去？</p><p>除了在DOM中插入图片节点，其他凡是涉及到要展示一张新图片的操作，浏览器都得即时去请求图片。比如，为某个节点添加如下css类来增加背景图片：</p><pre><code class="css">.bg1&#123;    background: url(http://p2.qhimg.com/t01ed1438874f940dc0.jpg);&#125;</code></pre><p>或者是动态修改了src属性、在canvas绘制图片等，这些都会即时请求新资源。</p><p>那么，资源预加载为什么能解决上述问题呢？</p><p>我们预加载的资源，浏览器会缓存下来，再次使用的时候，浏览器会检查是不是已经在缓存中，如果在，则直接用缓存的资源，不发送请求，或者由服务端返回<code>304 not modified</code>(304只带请求头信息，不传输资源)。这样使用一张图片的时间会大大缩减，我们的页面看起来会非常流畅。也就是说，预加载的资源我们并不需要手动保存，由浏览器自动放到缓存了。</p><h3 id="资源预加载的场景"><a href="#资源预加载的场景" class="headerlink" title="资源预加载的场景"></a>资源预加载的场景</h3><h5 id="什么样的项目需要预加载资源呢？"><a href="#什么样的项目需要预加载资源呢？" class="headerlink" title="什么样的项目需要预加载资源呢？"></a>什么样的项目需要预加载资源呢？</h5><p>范围应该锁定单页面应用，SPA的视图一般都是一步一步来呈现的，各种资源通过异步请求来获取，为了追求原生app般的流畅体验，可以把一些资源预加载下来。视图、图片较多的专题页面，或者是需要逐帧图片来完成的动画效果，最好都要做预加载。HTML5游戏，图片一般都比较多，而且很多逐帧动画，必须要预加载，事实上一些游戏引擎都会提供相应功能。</p><h5 id="哪些资源需要预加载呢？"><a href="#哪些资源需要预加载呢？" class="headerlink" title="哪些资源需要预加载呢？"></a>哪些资源需要预加载呢？</h5><p>web中包含的资源有很多种，图片、音视频之类的媒体文件，另外就是js、css文件，这些都需要发送请求来获取。那这些资源难道我们都预加载？当然不是了，预加载也是需要消耗时间的，总不能让用户等你加载个几十秒钟吧。具体预加载哪些资源，需要基于具体的考虑，也跟你的项目相关。</p><p>以下是一些我的想法：js、css文件不需进行预加载。现在写js基本都用<code>requirejs</code>之类的加载器，而且最后都会进行压缩合并，将请求数降到最低，最终只有一个文件，有些团队甚至还将压缩后的代码直接放在行内，这样一个多余的请求都没有了。</p><p>那么需要预加载的就是媒体文件了，图片、音视频之类。这类资源也得根据实际情况来选择哪些需要预加载。比如大多数页面装饰性图片就需要预加载，而由业务动态获取的图片则无法预加载（预先不知道地址）。用作音效、小动画的音视频可以预加载，一个半小时长的视频就不能预加载了。</p><h3 id="预加载的原理与加载进度的获取"><a href="#预加载的原理与加载进度的获取" class="headerlink" title="预加载的原理与加载进度的获取"></a>预加载的原理与加载进度的获取</h3><p>上面都是纸上谈兵的一些观点，下面我们该从技术的角度来思考一下预加载该如何实现。原理其实也相当简单，就是维护一个资源列表，挨个去加载列表中的资源，然后在每个资源加载完成的回调函数中更新进度即可。</p><p>以图片为例，大致的代码应该是这样：</p><pre><code class="js">var image = new Image();image.onload = function()&#123;&#125;;image.onerror = function()&#123;&#125;;image.src = url;</code></pre><p>这样就OK啦，图片已经进缓存，留着以后使用吧。</p><p>再说进度，这个进度严格来讲并不是文件加载的实时进度，因为我们只能在每个文件加载完成的时候执行回调，无法像<code>timeline</code>中那样拿到文件加载的实时进度。计算方法就很简单了，当前加载完的资源个数/资源总数*100，就是加载进度的百分比了。</p><p>资源预加载小插件：<code>resLoader.js</code>介绍，根据上面的原理，我写了一个插件，用来做资源预加载。</p><p>具备的特征如下：</p><ol><li>自定义资源列表，用于预加载</li><li>自定义<code>onProgress</code>，想展示成进度条还是百分比数字还是个性的设计都可</li><li>开始和结束可配置回调函数</li><li>只支持图片的预加载</li><li>支持amd、cmd加载器加载，同时支持直接用<code>&lt;script&gt;</code>标签引入使用</li><li>不依赖其他库</li></ol><p>用法如下：</p><pre><code class="js">var loader = new resLoader(&#123;     resources : [          &#39;http://p2.qhimg.com/t01ed1438874f940dc0.jpg&#39;,          &#39;http://p9.qhimg.com/t01b4ff03b72c7dc6c7.jpg&#39;,          &#39;http://p2.qhimg.com/t01dd90dfbec92074d0.jpg&#39;,          &#39;http://p7.qhimg.com/t01cfec6d87cde457c5.jpg&#39;,          &#39;http://p9.qhimg.com/t01943ced462da67833.jpg&#39;,          &#39;http://p0.qhimg.com/t01943ced462da67833.jpg&#39;,          &#39;http://p6.qhimg.com/t01aa15a7ba7ccb49a7.jpg&#39;,          &#39;http://p8.qhimg.com/t010f1e8badf1134376.jpg&#39;,          &#39;http://p8.qhimg.com/t01cf37ea915533a032.jpg&#39;,          &#39;http://p3.qhimg.com/t0193d8a3963e1803e9.jpg&#39;,          &#39;http://p3.qhimg.com/t01cd6a4d4b4bd4457b.jpg&#39;     ],     onStart : function(total)&#123;          console.log(&#39;start:&#39;+total);     &#125;,     onProgress : function(current, total)&#123;          console.log(current+&#39;/&#39;+total);          var percent = current/total*100;          $(&#39;.progressbar&#39;).css(&#39;width&#39;, percent+&#39;%&#39;);          $(&#39;.progresstext .current&#39;).text(current);          $(&#39;.progresstext .total&#39;).text(total);     &#125;,     onComplete : function(total)&#123;          alert(&#39;加载完毕:&#39;+total+&#39;个资源&#39;);     &#125;&#125;);loader.start();</code></pre><p>各项参数都直接明了，不再多说了。在上面的例子中，我自己定义onProgress函数，做了一个简单的进度条，你也可以做其他实现。函数为你传入了current和total，分别表示当前完成的资源个数和资源总个数，可用于计算进度。效果可看在线demo：<a target="_blank" rel="noopener" href="http://idoube.com/proj/resLoader/demo.html">点击这里</a>另外附上下载地址，感兴趣的朋友可以拿去使用：<a target="_blank" rel="noopener" href="http://files.cnblogs.com/files/lvdabao/resLoader.zip">http://files.cnblogs.com/files/lvdabao/resLoader.zip</a></p><p>这里想多说的东西是关于加载进度的，我上面说了我们只能获取到的是进度其实是离散的点，不是连续的。其实利用HTML5的xhr2的新特性我们也可以尝试获取更加精确的进度。因为xhr2新增了一个非常有趣的特性：可以从服务端获取文件数据。我们以前从服务端返回的数据都是字符串，现在可以直接返回Blob类型的文件。</p><p>那么在这里做一个猜想，能不能利用此特性，做更加精确的进度计算呢？我在此处只是提出一种可能性，还未做实践。我们知道xhr2新增的upload属性可以让我们获取到文件上传的进度信息，但对于返回的数据，却无法直接提供进度信息，所以要想依靠它来实现还得做其他工作。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cordova项目备忘</title>
      <link href="/2016-07/cordova%E9%A1%B9%E7%9B%AE%E5%A4%87%E5%BF%98/"/>
      <url>/2016-07/cordova%E9%A1%B9%E7%9B%AE%E5%A4%87%E5%BF%98/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="iOS-技巧"><a href="#iOS-技巧" class="headerlink" title="iOS 技巧"></a>iOS 技巧</h2><h3 id="iOS-运行调试方式"><a href="#iOS-运行调试方式" class="headerlink" title="iOS 运行调试方式"></a>iOS 运行调试方式</h3><p>iOS 开发与 Android 开发有所不同，由于苹果的限制，它不能像 Android 开发那样直接通过命令行命令实现真机调试。</p><p>iOS 版本的 cordova 项目编译步骤：添加 iOS 平台=》添加所需插件=》通过<code>cordova build ios</code>命令生成.xcodeproj 文件=》双击打开该文件=》通过 Xcode 实现真机调试</p><p><img src="http://cdn.chuyunt.com/uPic/72f96cbagw1f6fgatmsvnj215o0k0jx8.jpg" alt="72f96cbagw1f6fgatmsvnj215o0k0jx8"></p><h3 id="缩减标题栏，修复界面的高度。"><a href="#缩减标题栏，修复界面的高度。" class="headerlink" title="缩减标题栏，修复界面的高度。"></a>缩减标题栏，修复界面的高度。</h3><p>将通过命令行生成的.xcodeproject 文件直接打开运行时，会发现页面内容会显示到手机的通知栏。<br>只需要在 Staging 目录下 Classes 目录下的 MainViewController.m 下重写方法如下：</p><pre><code class="objc">-(void)viewWillAppear:(BOOL)animated&#123;    if([[[UIDevice currentDevice]systemVersion ] floatValue]&gt;=7)    &#123;        CGRect viewBounds=[self.webView  bounds];        viewBounds.origin.y=20;        viewBounds.size.height=viewBounds.size.height-20;        self.webView.frame=viewBounds;        self.modalPresentationStyle=UIModalPresentationOverCurrentContext; //解决上浮的问题    &#125;    [super viewWillDisappear:animated];&#125;-(void)viewWillDisappear:(BOOL)animated&#123;    if([[[UIDevice currentDevice]systemVersion ] floatValue]&gt;=7)    &#123;        CGRect viewBounds=[self.webView  bounds];        viewBounds.origin.y=20;        viewBounds.size.height=viewBounds.size.height+20;        self.webView.frame=viewBounds;        self.modalPresentationStyle=UIModalPresentationOverCurrentContext; //解决相机的问题    &#125;    [super viewWillDisappear:animated];&#125;</code></pre><h3 id="禁止上下滑动出现灰色背景"><a href="#禁止上下滑动出现灰色背景" class="headerlink" title="禁止上下滑动出现灰色背景"></a>禁止上下滑动出现灰色背景</h3><p>使用 Cordova 进行跨平台应用开发时，发现在 iOS 平台下，如果页面处于最顶端时，用户用手指往下拖动，会露出灰色空背景。同样页面在最底部的时候，继续向上拖动，下方也会露出空背景。</p><p>要禁止这个拖动效果，可在 config.xml 中进行如下设置：</p><pre><code class="xml">&lt;preference name=&quot;WebViewBounce&quot; value=&quot;false&quot; /&gt;&lt;preference name=&quot;DisallowOverscroll&quot; value=&quot;true&quot; /&gt;</code></pre><h3 id="设置-iOS-下默认语言为中文"><a href="#设置-iOS-下默认语言为中文" class="headerlink" title="设置 iOS 下默认语言为中文"></a>设置 iOS 下默认语言为中文</h3><p>比如在打开键盘输入时，调用相机插件时，调用相册时，都会出现英文现象。</p><p><img src="http://cdn.chuyunt.com/uPic/006tKfTcgw1f6vrt0t7thj30nl0ac763.jpg" alt="006tKfTcgw1f6vrt0t7thj30nl0ac763"></p><p>使用 Xcode 打开工程，将在 plist 文件里面 Localization native development region 设置为 China 即可。</p><p><img src="http://cdn.chuyunt.com/uPic/006tKfTcgw1f6vrw81nswj315k0hodo9.jpg" alt="006tKfTcgw1f6vrw81nswj315k0hodo9"></p><h3 id="出现-submit-方法无效"><a href="#出现-submit-方法无效" class="headerlink" title="出现 submit()方法无效"></a>出现 submit()方法无效</h3><p>在 post 请求时，可能出现 submit()方法无效的情况，需要在 config.xml 中添加</p><p><code>&lt;allow-navigation href=&quot;*&quot; /&gt;</code></p><h3 id="通过给按钮添加震动提高用户使用感受"><a href="#通过给按钮添加震动提高用户使用感受" class="headerlink" title="通过给按钮添加震动提高用户使用感受"></a>通过给按钮添加震动提高用户使用感受</h3><pre><code class="html">&lt;div class=&quot;button vibrate&quot;&gt;&lt;/div&gt;</code></pre><pre><code class="js">$(&quot;.vibrate&quot;).bind(&quot;tap&quot;, function () &#123;  //需要引入phonegap的js  if (navigator.notification)    setTimeout(function () &#123;      navigator.notification.vibrate(20);    &#125;, 0);&#125;);</code></pre><h2 id="android-技巧"><a href="#android-技巧" class="headerlink" title="android 技巧"></a>android 技巧</h2><h3 id="捕捉-android-返回按键【需要-cordova-支持】"><a href="#捕捉-android-返回按键【需要-cordova-支持】" class="headerlink" title="捕捉 android 返回按键【需要 cordova 支持】"></a>捕捉 android 返回按键【需要 cordova 支持】</h3><pre><code class="js">document.addEventListener(&quot;deviceready&quot;, onDeviceReady, false);function onDeviceReady() &#123;  // 注册回退按钮事件监听器  document.addEventListener(&quot;backbutton&quot;, onBackKeyDown, false);  //其他页面初始化完成后的事件&#125;function onBackKeyDown() &#123;  //这里写上你要处理的事情&#125;</code></pre><h3 id="使用命令行打包签名-apk"><a href="#使用命令行打包签名-apk" class="headerlink" title="使用命令行打包签名 apk"></a>使用命令行打包签名 apk</h3><ol><li>打包 apk</li></ol><pre><code class="shell">cordova bulid android              # 用于测试的打包方式，生成已签名apkcordova build --release android    # 生成没有签名的apk</code></pre><blockquote><p>第一个命令生成的是一个 Cordova-debug.apk，很明显是用来进行本地开发测试使用的，注意这个 apk 是有签名的，所以能被安装在手机上，但是这个不能用来上架。因为只有在绝对同样的环境下进行打包，才能保证这个 apk 的签名相同，意味着你这台机器必须始终保持正常并且系统和打包工具等不作修改。这明显是不合理的。所以，我们必须采用生产的方式打包，就是第二个命令，这个命令生成的是一个无签名的 apk，他无法安装在手机上，必须进行签名。</p></blockquote><ol start="2"><li>生成签名文件</li></ol><pre><code class="shell">keytool -genkey -v -keystore demo.keystore -alias demo.keystore -keyalg RSA -validity 20000# keytool是工具名称；# -genkey意味着执行的是生成数字证书操作；# -v表示将生成证书的详细信息打印出来；# -keystore demo.keystore 表示证书的文件名；# -alias demo.keystore 表示证书的别名；# -keyalg RSA 生成密钥文件所采用的算法；# -validity 20000 该数字证书的有效期，单位是天；</code></pre><p>输入后会让你输入密码，并回答一些关于你公司和地区的问题，回答完后截屏记录，防止忘记。</p><ol start="3"><li>签名 apk</li></ol><pre><code class="shell">jarsigner -verbose -keystore /yourpath/demo.keystore -signedjar /yourpath/demo_signed.apk  /yourpath/demo.apk  /yourpath/demo.keystore# jarsigner是工具名称，# -verbose表示将签名过程中的详细信息打印出来；# /yourpath/  （根据自己的情况配置）相对于当前命令行所在文件夹的位置，可将下列文件放在同一目录下;# -keystore   /yourpath/demo.keystore   刚刚生成的签名文件；# -signedjar  /yourpath/demo_signed.apk  签名后的apk名称# /yourpath/demo.apk  需要签名的apk# /yourpath/demo.keystore 证书的别名</code></pre><ol start="4"><li>查看 apk 的签名</li></ol><p>查看签名是否成功，可将签名后的文件，后缀名 apk 的改为 zip，解压。在该目录下，输入如下命令：</p><pre><code class="shell">keytool -printcert -file META-INF/CERT.RSA# META-INF/TEST.RSA   根据自己的情况配置</code></pre><p>输入命令行后，会出现类似下图信息</p><p><img src="http://cdn.chuyunt.com/uPic/72f96cbagw1f6d81otra6j214203ymz4.jpg" alt="72f96cbagw1f6d81otra6j214203ymz4"></p><h2 id="资源备忘"><a href="#资源备忘" class="headerlink" title="资源备忘"></a>资源备忘</h2><h3 id="cordova-文档"><a href="#cordova-文档" class="headerlink" title="cordova 文档"></a>cordova 文档</h3><p>官方文档: <a target="_blank" rel="noopener" href="http://cordova.apache.org/docs/en/latest/">http://cordova.apache.org/docs/en/latest/</a></p><p>phoneGap 官网: <a target="_blank" rel="noopener" href="https://phonegap.com/">https://phonegap.com/</a></p><p>PhoneGap 中文 API: <a target="_blank" rel="noopener" href="http://www.phonegapcn.com/docs/zh/cn/">http://www.phonegapcn.com/docs/zh/cn/</a></p><p>phonegap100 论坛: <a target="_blank" rel="noopener" href="http://www.phonegap100.com/">http://www.phonegap100.com/</a></p><h3 id="ionic"><a href="#ionic" class="headerlink" title="ionic"></a>ionic</h3><p>官网: <a target="_blank" rel="noopener" href="https://ionicframework.com/docs/">https://ionicframework.com/docs/</a></p><p>ng-cordova: <a target="_blank" rel="noopener" href="https://github.com/ionic-team/ng-cordova/issues/1452">https://github.com/ionic-team/ng-cordova/issues/1452</a> (已过时)</p><p>Ionic Native: <a target="_blank" rel="noopener" href="https://github.com/ionic-team/ionic-native">https://github.com/ionic-team/ionic-native</a></p><p>ionic 中文: <a target="_blank" rel="noopener" href="http://www.ionic.wang/">http://www.ionic.wang/</a></p><h3 id="相关博客集"><a href="#相关博客集" class="headerlink" title="相关博客集"></a>相关博客集</h3><p>本人博客：<a href="http://lion1ou.tech/categories/Cordova/">http://lion1ou.tech/categories/Cordova/</a></p><p>航歌 cordova 模块: <a target="_blank" rel="noopener" href="http://www.hangge.com/blog/cache/category_75_1.html">http://www.hangge.com/blog/cache/category_75_1.html</a></p><p>rensanning 的博客: <a target="_blank" rel="noopener" href="http://rensanning.iteye.com/blog/2163892">http://rensanning.iteye.com/blog/2163892</a></p><p>神秘_博士的博客: <a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelyelfpop/article/category/2000185">http://blog.csdn.net/lovelyelfpop/article/category/2000185</a></p><p>csdn 的 cordova 专栏: <a target="_blank" rel="noopener" href="http://blog.csdn.net/column/details/cordova.html">http://blog.csdn.net/column/details/cordova.html</a></p><p>csdn 的 phoneGap 专栏: <a target="_blank" rel="noopener" href="http://blog.csdn.net/column/details/phonegap.html?&page=1">http://blog.csdn.net/column/details/phonegap.html?&amp;page=1</a></p><h3 id="cordova-入门"><a href="#cordova-入门" class="headerlink" title="cordova 入门"></a>cordova 入门</h3><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/jsStudyjj/p/4956818.html">cordova 学习-基础篇</a></p><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000002964603">使用 Cordova API 开发(上)</a></p><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000003013808">使用 Cordova API 开发(下)</a></p><p><a target="_blank" rel="noopener" href="http://tanglei528.blog.163.com/blog/static/43353399201401110738334/">Phonegap navigator app 对象 </a></p><h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/tdalcn/archive/2013/12/26/3491973.html">phonegap–app 启动欢迎引导页 localstorage</a></p><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/flyingzl/articles/3115457.html">PhoneGap 拍照并上传到远程服务器</a></p><p><a target="_blank" rel="noopener" href="http://gundumw100.iteye.com/blog/2103612">cordova 读写文件（1）</a></p><p><a target="_blank" rel="noopener" href="http://gundumw100.iteye.com/blog/2103623">cordova 读写文件（2）</a></p><p><a target="_blank" rel="noopener" href="http://www.mamicode.com/info-detail-861464.html">PhoneGap 白名单安全机制 navigator.app 加载外部页面返回以及退出介绍</a></p><h3 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h3><p>cordova 插件搜索: <a target="_blank" rel="noopener" href="http://cordova.apache.org/plugins/">http://cordova.apache.org/plugins/</a></p><p>BLE 蓝牙: <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/cordova-plugin-ble-central">https://www.npmjs.com/package/cordova-plugin-ble-central</a></p><p>相机: <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/cordova-plugin-camera">https://www.npmjs.com/package/cordova-plugin-camera</a></p><p>媒体: <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/cordova-plugin-media">https://www.npmjs.com/package/cordova-plugin-media</a></p><p>APP 版本: <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/cordova-plugin-app-version">https://www.npmjs.com/package/cordova-plugin-app-version</a></p><p>听筒播放: <a target="_blank" rel="noopener" href="https://github.com/alongubkin/audiotoggle">https://github.com/alongubkin/audiotoggle</a></p><p>极光推送: <a target="_blank" rel="noopener" href="https://github.com/jpush/jpush-phonegap-plugin">https://github.com/jpush/jpush-phonegap-plugin</a></p><p>社交分享: <a target="_blank" rel="noopener" href="https://github.com/EddyVerbruggen/SocialSharing-PhoneGap-Plugin">https://github.com/EddyVerbruggen/SocialSharing-PhoneGap-Plugin</a></p><p>二维码扫描: <a target="_blank" rel="noopener" href="http://rensanning.iteye.com/blog/2034026">http://rensanning.iteye.com/blog/2034026</a></p><p>热更新插件: <a target="_blank" rel="noopener" href="http://www.phonegap100.com/article-491-1.html">http://www.phonegap100.com/article-491-1.html</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a target="_blank" rel="noopener" href="http://www.hangge.com/blog/cache/detail_1145.html">如何创建、配置、开发第一个 ios 应用</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Cordova </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cordova </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cordova启动页面和图标的设置</title>
      <link href="/2016-07/cordova%E5%90%AF%E5%8A%A8%E9%A1%B5%E9%9D%A2%E5%92%8C%E5%9B%BE%E6%A0%87%E7%9A%84%E8%AE%BE%E7%BD%AE/"/>
      <url>/2016-07/cordova%E5%90%AF%E5%8A%A8%E9%A1%B5%E9%9D%A2%E5%92%8C%E5%9B%BE%E6%A0%87%E7%9A%84%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="一、config-xml配置"><a href="#一、config-xml配置" class="headerlink" title="一、config.xml配置"></a>一、config.xml配置</h2><blockquote><p>在cordova5.0版本以后，需要安装<code>cordova-plugin-splashscreen</code>插件以后才能修改和设置App的启动页面。</p></blockquote><h3 id="安装splashscreen插件："><a href="#安装splashscreen插件：" class="headerlink" title="安装splashscreen插件："></a>安装splashscreen插件：</h3><pre><code class="shell">cordova plugin add cordova-plugin-splashscreencordova plugin add https://github.com/apache/cordova-plugin-splashscreen.git</code></pre><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>然后在你的config.xml文件中，添加以下代码</p><pre><code class="xml">&lt;platform name=&quot;android&quot;&gt;      &lt;icon density=&quot;ldpi&quot; src=&quot;res/icon/android/drawable-ldpi/icon.png&quot; /&gt;    &lt;icon density=&quot;mdpi&quot; src=&quot;res/icon/android/drawable-mdpi/icon.png&quot; /&gt;    &lt;icon density=&quot;hdpi&quot; src=&quot;res/icon/android/drawable-hdpi/icon.png&quot; /&gt;    &lt;icon density=&quot;xhdpi&quot; src=&quot;res/icon/android/drawable-xhdpi/icon.png&quot; /&gt;    &lt;icon density=&quot;xxhdpi&quot; src=&quot;res/icon/android/drawable-xxhdpi/icon.png&quot; /&gt;    &lt;!-- 以下是欢迎页面，可根据需要进行添加 --&gt;    &lt;splash density=&quot;land-hdpi&quot; src=&quot;res/screen/android/splash-land-hdpi.png&quot; /&gt;      &lt;splash density=&quot;land-ldpi&quot; src=&quot;res/screen/android/splash-land-ldpi.png&quot; /&gt;      &lt;splash density=&quot;land-mdpi&quot; src=&quot;res/screen/android/splash-land-mdpi.png&quot; /&gt;      &lt;splash density=&quot;land-xhdpi&quot; src=&quot;res/screen/android/splash-land-xhdpi.png&quot; /&gt;      &lt;splash density=&quot;port-hdpi&quot; src=&quot;res/screen/android/splash-port-hdpi.png&quot; /&gt;      &lt;splash density=&quot;port-ldpi&quot; src=&quot;res/screen/android/splash-port-ldpi.png&quot; /&gt;      &lt;splash density=&quot;port-mdpi&quot; src=&quot;res/screen/android/splash-port-mdpi.png&quot; /&gt;      &lt;splash density=&quot;port-xhdpi&quot; src=&quot;res/screen/android/splash-port-xhdpi.png&quot; /&gt;  &lt;/platform&gt;  &lt;platform name=&quot;ios&quot;&gt;      &lt;!-- iOS 8.0+ --&gt;      &lt;!-- iPhone 6 Plus  --&gt;      &lt;icon src=&quot;res/icon/ios/icon-60@3x.png&quot; width=&quot;180&quot; height=&quot;180&quot; /&gt;      &lt;!-- iOS 7.0+ --&gt;      &lt;!-- iPhone / iPod Touch  --&gt;      &lt;icon src=&quot;res/icon/ios/icon-60.png&quot; width=&quot;60&quot; height=&quot;60&quot; /&gt;      &lt;icon src=&quot;res/icon/ios/icon-60@2x.png&quot; width=&quot;120&quot; height=&quot;120&quot; /&gt;      &lt;!-- iPad --&gt;      &lt;icon src=&quot;res/icon/ios/icon-76.png&quot; width=&quot;76&quot; height=&quot;76&quot; /&gt;      &lt;icon src=&quot;res/icon/ios/icon-76@2x.png&quot; width=&quot;152&quot; height=&quot;152&quot; /&gt;      &lt;!-- iOS 6.1 --&gt;      &lt;!-- Spotlight Icon --&gt;      &lt;icon src=&quot;res/icon/ios/icon-40.png&quot; width=&quot;40&quot; height=&quot;40&quot; /&gt;      &lt;icon src=&quot;res/icon/ios/icon-40@2x.png&quot; width=&quot;80&quot; height=&quot;80&quot; /&gt;      &lt;!-- iPhone / iPod Touch --&gt;      &lt;icon src=&quot;res/icon/ios/icon.png&quot; width=&quot;57&quot; height=&quot;57&quot; /&gt;      &lt;icon src=&quot;res/icon/ios/icon@2x.png&quot; width=&quot;114&quot; height=&quot;114&quot; /&gt;      &lt;!-- iPad --&gt;      &lt;icon src=&quot;res/icon/ios/icon-72.png&quot; width=&quot;72&quot; height=&quot;72&quot; /&gt;      &lt;icon src=&quot;res/icon/ios/icon-72@2x.png&quot; width=&quot;144&quot; height=&quot;144&quot; /&gt;      &lt;!-- iPhone Spotlight and Settings Icon --&gt;      &lt;icon src=&quot;res/icon/ios/icon-small.png&quot; width=&quot;29&quot; height=&quot;29&quot; /&gt;      &lt;icon src=&quot;res/icon/ios/icon-small@2x.png&quot; width=&quot;58&quot; height=&quot;58&quot; /&gt;      &lt;!-- iPad Spotlight and Settings Icon --&gt;      &lt;icon src=&quot;res/icon/ios/icon-50.png&quot; width=&quot;50&quot; height=&quot;50&quot; /&gt;      &lt;icon src=&quot;res/icon/ios/icon-50@2x.png&quot; width=&quot;100&quot; height=&quot;100&quot; /&gt;      &lt;!-- 以下是欢迎页面，可根据需要进行添加 --&gt;    &lt;splash src=&quot;res/screen/ios/Default~iphone.png&quot; width=&quot;320&quot; height=&quot;480&quot;/&gt;      &lt;splash src=&quot;res/screen/ios/Default@2x~iphone.png&quot; width=&quot;640&quot; height=&quot;960&quot;/&gt;      &lt;splash src=&quot;res/screen/ios/Default-Portrait~ipad.png&quot; width=&quot;768&quot; height=&quot;1024&quot;/&gt;      &lt;splash src=&quot;res/screen/ios/Default-Portrait@2x~ipad.png&quot; width=&quot;1536&quot; height=&quot;2048&quot;/&gt;      &lt;splash src=&quot;res/screen/ios/Default-Landscape~ipad.png&quot; width=&quot;1024&quot; height=&quot;768&quot;/&gt;      &lt;splash src=&quot;res/screen/ios/Default-Landscape@2x~ipad.png&quot; width=&quot;2048&quot; height=&quot;1536&quot;/&gt;      &lt;splash src=&quot;res/screen/ios/Default-568h@2x~iphone.png&quot; width=&quot;640&quot; height=&quot;1136&quot;/&gt;      &lt;splash src=&quot;res/screen/ios/Default-667h.png&quot; width=&quot;750&quot; height=&quot;1334&quot;/&gt;      &lt;splash src=&quot;res/screen/ios/Default-736h.png&quot; width=&quot;1242&quot; height=&quot;2208&quot;/&gt;      &lt;splash src=&quot;res/screen/ios/Default-Landscape-736h.png&quot; width=&quot;2208&quot; height=&quot;1242&quot;/&gt;  &lt;/platform&gt;</code></pre><h3 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h3><ul><li>自动隐藏启动页面<code>AutoHideSplashScreen</code>（默认为：true）</li></ul><pre><code class="xml">&lt;preference name=&quot;AutoHideSplashScreen&quot; value=&quot;true&quot; /&gt;</code></pre><ul><li>显示启动页面的时间长度<code>SplashScreenDelay</code>(默认为：3000)</li></ul><pre><code class="xml">&lt;preference name=&quot;SplashScreenDelay&quot; value=&quot;3000&quot; /&gt;</code></pre><p>若想禁用启动页面，可设置为：</p><pre><code class="xml">&lt;preference name=&quot;SplashScreenDelay&quot; value=&quot;0&quot;/&gt;</code></pre><p>如果是iOS平台上想禁止启动页面，还需要添加</p><pre><code class="xml">&lt;preference name=&quot;FadeSplashScreenDuration&quot; value=&quot;0&quot;/&gt;</code></pre><ul><li>启动页面淡入淡出的效果</li></ul><p>是否显示淡入淡出效果<code>FadeSplashScreen</code>(默认为：true)</p><pre><code class="xml">&lt;preference name=&quot;FadeSplashScreen&quot; value=&quot;false&quot;/&gt;</code></pre><p>淡入淡出效果的执行时间长度<code>FadeSplashScreenDuration</code>(默认为：500)</p><pre><code class="xml">&lt;preference name=&quot;FadeSplashScreenDuration&quot; value=&quot;750&quot;/&gt;</code></pre><p>注意：<code>FadeSplashScreenDuration</code>时间是包含在<code>SplashScreenDelay</code>的时间里的。</p><ul><li>启动页面是否允许旋转（默认为：true）</li></ul><pre><code class="xml">&lt;preference name=&quot;ShowSplashScreenSpinner&quot; value=&quot;false&quot;/&gt;</code></pre><ul><li>插件还可以通过js代码调用，提供有以下两个方法：</li></ul><pre><code class="js">navigator.splashscreen.hide();//隐藏启动页面navigator.splashscreen.show();//显示启动页面</code></pre><ul><li>在Android平台下的特殊设置</li></ul><pre><code class="xml">&lt;preference name=&quot;SplashMaintainAspectRatio&quot; value=&quot;true|false&quot; /&gt;&lt;preference name=&quot;SplashShowOnlyFirstTime&quot; value=&quot;true|false&quot; /&gt;</code></pre><p><code>SplashMaintainAspectRatio</code>：选填项，默认为false。当设置为true时，则不会拉伸图片来填充屏幕，会以图片原始比例显示图片。</p><p><code>SplashShowOnlyFirstTime</code>：选填项，默认为true。当设置为false时，APP通过<code>navigator.app.exitApp()</code>代码退出app后，在下次打开APP时，还会显示启动页面。若为true时，就不会出现。</p><h2 id="二、图标文件夹内容"><a href="#二、图标文件夹内容" class="headerlink" title="二、图标文件夹内容"></a>二、图标文件夹内容</h2><p>根据上面的配置信息，你需要准备好你自己的app图标和启动画面png文件：</p><p>存放路径不是以<code>www文件夹</code>为依据，而是以<code>当前项目文件夹</code>为依据</p><pre><code>projectRoot    hooks    platforms    plugins    www        css        img        js    res        screen            android            ios        icon            android            ios</code></pre><h3 id="应用程序图标"><a href="#应用程序图标" class="headerlink" title="应用程序图标"></a>应用程序图标</h3><p>可通过<a target="_blank" rel="noopener" href="http://icon.wuruihong.com/">图标工场</a>一键生成多尺寸图标。</p><ul><li><p>安卓图标具体规格如下（存放目录：res/icon/android/）</p><pre><code>  36*36    drawable-ldpi/icon.png  48*48    drawable-mdpi/icon.png  72*72    drawable-hdpi/icon.png  96*96    drawable-xhdpi/icon.png  144*144     drawable-xxhdpi/icon.png</code></pre></li></ul><ul><li><p>iOS图标具体规格如下（存放目录：res/icon/ios/）</p><pre><code>  57*57   icon.png  114*114 icon@2x.png  29*29    icon-small.png  58*58    icon-small@2x.png  40*40    icon-40.png  80*80    icon-40@2x.png  50*50    icon-50.png  100*100    icon-50@2x.png  60*60    icon-60.png  120*120    icon-60@2x.png  180*180    icon-60@3x.png  72*72    icon-72.png  144*144    icon-72@2x.png  76*76    icon-76.png  152*152    icon-76@2x.png</code></pre></li></ul><h3 id="应用程序启动页面"><a href="#应用程序启动页面" class="headerlink" title="应用程序启动页面"></a>应用程序启动页面</h3><ul><li><p>安卓启动画面具体规格如下（存放目录：res/screen/android/）</p><pre><code>  960*720    splash-land-xhdpi.png  640*480    splash-land-hdpi.png  470*320    splash-land-mdpi.png  426*320    splash-land-ldpi.png  720*960    splash-port-xhdpi.png  480*640    splash-port-hdpi.png  320*470    splash-port-mdpi.png  320*426    splash-port-ldpi.png</code></pre></li></ul><ul><li><p>iOS启动画面具体规格如下（存放目录：res/screen/ios/）</p><pre><code>  320*480    Default~iphone.png  640*960    Default@2x~iphone.png  768*1024    Default-Portrait~ipad.png  1536*2048    Default-Portrait@2x~ipad.png  1024*768    Default-Landscape~ipad.png  2048*1536    Default-Landscape@2x~ipad.png  640*1136    Default-568h@2x~iphone.png  750*1334    Default-667h.png  1242*2208    Default-736h.png  2208*1242    Default-Landscape-736h.png</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Cordova </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cordova </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cordova/phoneGap开发调试工具</title>
      <link href="/2016-07/cordova-phonegap%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
      <url>/2016-07/cordova-phonegap%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p><code>Ripple Emulate</code>：使用Google模拟器，可以帮到大部分的调试，除了需要调用手机设备方面的功能除外。<code>GapDebug</code>：真机安装apk，电脑端和真机端同步调试，适用的项目phonegap/cordova/ionic。</p><h2 id="二、Ripple-Emulate安装和使用"><a href="#二、Ripple-Emulate安装和使用" class="headerlink" title="二、Ripple Emulate安装和使用"></a>二、Ripple Emulate安装和使用</h2><h3 id="Apache-Ripple主页："><a href="#Apache-Ripple主页：" class="headerlink" title="Apache Ripple主页："></a>Apache Ripple主页：</h3><p><a target="_blank" rel="noopener" href="http://ripple.incubator.apache.org/">http://ripple.incubator.apache.org/</a></p><h3 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h3><p><code>npm install -g ripple-emulator</code></p><h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><p>项目路径执行命令行：<code>ripple emulate</code> ；会在默认浏览器打开网页版的模拟器。</p><h3 id="模拟项目失败可能的原因"><a href="#模拟项目失败可能的原因" class="headerlink" title="模拟项目失败可能的原因"></a>模拟项目失败可能的原因</h3><blockquote><p>运行的路径内没有支持的项目。比如没有index.html文件。如果是cordova项目可能没找到platform的文件夹，这时会有cordova相关报错。</p></blockquote><h2 id="三、GapDebug安装和使用"><a href="#三、GapDebug安装和使用" class="headerlink" title="三、GapDebug安装和使用"></a>三、GapDebug安装和使用</h2><p>非常惊喜的发现了这个工具，可以侦听安装在设备上的app，并且进行调试。</p><p><img src="http://cdn.chuyunt.com/uPic/006tNbRwgw1f6qxy2sqdvj30ib0avdgy.jpg" alt="006tNbRwgw1f6qxy2sqdvj30ib0avdgy"></p><h3 id="用前注意"><a href="#用前注意" class="headerlink" title="用前注意"></a>用前注意</h3><ol><li>国外的软件，又涉及到google，所以，这个软件下载要翻墙；第一次使用时软件会自动下载android debug tool，从google下载，所以也要翻墙。如果翻不动墙，又不能通过万能的互联网找到解决方法，那可以不用再往下看了。</li><li>亲测的是最新版2.1，可以用。之前用过网上找的1.0，连接不上手机</li></ol><h3 id="正文开始"><a href="#正文开始" class="headerlink" title="正文开始"></a>正文开始</h3><p>(下面摘自官方指南并翻译)</p><h4 id="调试移动app"><a href="#调试移动app" class="headerlink" title="调试移动app"></a>调试移动app</h4><p>使用GapDebug是非常简单的，只需要连接手机，然后就可用起来！</p><h5 id="移动端配置"><a href="#移动端配置" class="headerlink" title="移动端配置"></a>移动端配置</h5><ul><li><p>iOS：启用Web Inspector</p><p>Settings ⇨ Safari ⇨ Advanced ⇨ Web Inspector，滑动打开</p></li><li><p>Android：启用USB调试</p><p>Settings ⇨ Developer Options ⇨ 勾线 USB Debugging</p></li><li><p>允许APP应用调试</p><p>以Phonegap应用为例，编辑 platforms/android/AndroidManifest.xml，添加：</p><pre><code>&lt;manifest&gt;     ....     &lt;application android:debuggable=&quot;true&quot; /&gt;     ....&lt;/manifest&gt;</code></pre><p>如果使用Phonegap Developer App，则不需要上述设置。</p></li></ul><h5 id="打开GapDebug"><a href="#打开GapDebug" class="headerlink" title="打开GapDebug"></a>打开GapDebug</h5><ol><li>从windows开始菜单或Mac Finder打开GapDebug。</li></ol><p>  没有连接设备的GapDebug界面：</p><p>  <img src="http://cdn.chuyunt.com/uPic/006tNbRwgw1f6qseuph4bj30jg09xab2.jpg" alt="ui-no-devices-v2.png"></p><p>  运行后，GapDebug在你的系统上会产生一个调起快捷菜单的图标，windows是状态栏右侧的托盘，Mac在上面的通知栏上。从Windows系统托盘打开的用户界面：</p><p>  <img src="http://cdn.chuyunt.com/uPic/006tNbRwgw1f6qxwvnzyqj30re08w75w.jpg" alt="openGapdebug.jpg"></p><ol start="2"><li><p>使用USB数据线连接你的设备到你的工作站（workstation）。（USB线连接手机和你的电脑）</p></li><li><p>允许你的工作站作为一个信任设备。最初你的设备连接你的工作站时，你可能收到提示工作站否是可信任的连接源。选择OK或Trust。</p></li></ol><p>  <img src="http://cdn.chuyunt.com/uPic/006tNbRwgw1f6qwl92p6nj30gq05674y.jpg" alt="android-ios-trust-50 (1).jpg"></p><p>  在设备界面的设备信息展示。</p><p>  <img src="http://cdn.chuyunt.com/uPic/006tNbRwgw1f6qwpougquj308c05rjro.jpg" alt="device-panel-connected-android-dev-only-v22.png"></p><p>  USB线连接Nexus7 Android设备</p><p>  提示：我们建议你的设备不使用自动锁屏或休眠设置防止没有响应,并且需要开启开发者模式中的USB调试功能。</p><ol start="4"><li>在你的设备上，开始你想做的调试。app将呈现在你的设备面板的设备详情下方。<br>QRConference Buddy app在设备上的呈现</li></ol><p>  <img src="http://cdn.chuyunt.com/uPic/006tNbRwgw1f6qws6ft9kj30j4076766.jpg" alt="qr-conf-debug1.png"></p><ol start="5"><li>查看连接设备和可用的app。选择一个app在一个新的追踪视图（Inspector View）开始一个调试对话。<br>调试中的安卓appQR Conference Buddy</li></ol><h5 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h5><p>界面和浏览器的开发者工具都大同小异，很容易上手。</p><p><img src="http://cdn.chuyunt.com/uPic/006tNbRwgw1f6qwwh48svj30qd0ddn13.jpg" alt="user-interface-ios2.png"></p><p><img src="http://cdn.chuyunt.com/uPic/006tNbRwgw1f6qwwoklfdj30sb0e8gp5.jpg" alt="screencast1_v22.png"></p><h5 id="实时调试（Instant-Debugging）"><a href="#实时调试（Instant-Debugging）" class="headerlink" title="实时调试（Instant Debugging）"></a>实时调试（Instant Debugging）</h5><p>app可以做实时调试，GapDebug自动检测app的运行并立即开始响应。使用这个图标切换实时调试。</p><h4 id="安装一个app到你的设备"><a href="#安装一个app到你的设备" class="headerlink" title="安装一个app到你的设备"></a>安装一个app到你的设备</h4><p>在你的操作系统里你能够使用GapDebug快捷地安装一个或多个app文件到你的设备。有两个方法安装app——使用安装app图标或拖拽安装文件到你连接的设备上。安装后app会自动运行，看<a target="_blank" rel="noopener" href="https://www.genuitec.com/products/gapdebug/learning-center/user-guide/#auto_start">自动运行设置</a></p><p>注意：安装到Androi设备前，设置设备允许安装Google应用商店以外的资源（国产的手机根本不用担心这个）。</p><h5 id="安装app"><a href="#安装app" class="headerlink" title="安装app"></a>安装app</h5><ol><li><p>点击图标</p></li><li><p>选择你要安装的IOS（.ipa）或android（.apk）文件</p></li><li><p>当安装完成后设备面板上多出一条app提示</p></li></ol><p>  <img src="http://cdn.chuyunt.com/uPic/006tNbRwgw1f6qxgg77iaj30h80cidh6.jpg" alt="app_installed_notice_v2.png"></p><h5 id="使用拖拽文件安装"><a href="#使用拖拽文件安装" class="headerlink" title="使用拖拽文件安装"></a>使用拖拽文件安装</h5><ol><li><p>打开你的文件所在的文件夹</p></li><li><p>将文件拖拽到设备面板上</p></li></ol><p>  <img src="http://cdn.chuyunt.com/uPic/006tNbRwgw1f6qxhmpincj30h80cjtak.jpg" alt="drag_and_drop_install_v2.png"></p><ol start="3"><li>安装完成后会出现一个app提示。</li></ol><h4 id="自动和手动运行"><a href="#自动和手动运行" class="headerlink" title="自动和手动运行"></a>自动和手动运行</h4><p>GapDebug能自动运行安卓或IOS设备上最新安装的app。另外GapDebug支持手动开启app。</p><h5 id="Launch-After-Installation设置"><a href="#Launch-After-Installation设置" class="headerlink" title="Launch-After-Installation设置"></a>Launch-After-Installation设置</h5><p>app安装后GapDebug能立即运行它。这个功能节约了从安装app到调试不受干扰的时间。控制app运行功能下图有两个设置项。</p><p><img src="http://cdn.chuyunt.com/uPic/006tNbRwgw1f6qxj7zzgjj30g708t3zx.jpg" alt="general-settings-start-app.png"></p><p>“Start app after installation”项默认是勾上的。通过GapDebug安装的app会自动在你的设备上启动。</p><p>“Only start app if previously running”项允许你指定app运行，仅限运行过或更新过的已安装app。</p><p>注意：在IOS设备上运行app需要做其他设置。详情去看IOS设置。</p><h5 id="Android设备上的手动运行app"><a href="#Android设备上的手动运行app" class="headerlink" title="Android设备上的手动运行app"></a>Android设备上的手动运行app</h5><ol><li><p>点击图标的图标</p></li><li><p>从菜单中单击要运行的app。菜单关闭后app将立即运行</p></li></ol><p>  <img src="http://cdn.chuyunt.com/uPic/006tNbRwgw1f6qxkzk5l3j30dr085gm8.jpg" alt="run-app-menu12.png"></p><h4 id="调试多个app"><a href="#调试多个app" class="headerlink" title="调试多个app"></a>调试多个app</h4><p>你可能需要同时调试多个app。例如，你可能同时调试一个app的IOS和Android两个版本。当你选择设备面板上的一个app时，调试选项卡打开。还有，当前激活的选项卡是蓝色的。</p><p><img src="http://cdn.chuyunt.com/uPic/006tNbRwgw1f6qxmh1iqtj30ms0cy77y.jpg" alt="active_app_v21.png"></p><p>当你选择第二个app调试时，一个新的选项卡打开。单击可以切换到另一个选项卡。两个选项卡是蓝色时因为他们同时打开的是一个调试实例。无论如何，当前使用的是高亮的，其他的是灰色的。</p><p><img src="http://cdn.chuyunt.com/uPic/006tNbRwgw1f6qxnv2e47j30ms0cyaeu.jpg" alt="multiple_active_apps2_v21.png"></p><h4 id="设备视图截屏"><a href="#设备视图截屏" class="headerlink" title="设备视图截屏"></a>设备视图截屏</h4><p>点击Snapshot图标为设备视图截屏</p><p><img src="http://cdn.chuyunt.com/uPic/006tNbRwgw1f6qxocxpoyj30hq0cc3zl.jpg" alt="snapshot-pgdevapp1.png"></p><p>从Settings设置你想如何操作截图</p><p><img src="http://cdn.chuyunt.com/uPic/006tNbRwgw1f6qxorltasj30gu098404.jpg" alt="snap-settings.png"></p><h4 id="下载、查看和清除设备日志-sysylog"><a href="#下载、查看和清除设备日志-sysylog" class="headerlink" title="下载、查看和清除设备日志(sysylog)"></a>下载、查看和清除设备日志(sysylog)</h4><p>一个设备系统日志包含主要设备和应用事件，能够帮助诊断应用或系统级别错误。</p><h5 id="下载和查看日志"><a href="#下载和查看日志" class="headerlink" title="下载和查看日志"></a>下载和查看日志</h5><p>操作如图，点击菜单的Syslog选项</p><p><img src="http://cdn.chuyunt.com/uPic/006tNbRwgw1f6qxp6njjaj308b04oaa4.jpg" alt="syslog-menu.png"></p><p>从Settings中设置你想对日志的操作</p><p><img src="http://cdn.chuyunt.com/uPic/006tNbRwgw1f6qxqlq4klj30go09etaf.jpg" alt="syslog-settings.png"></p><p>选项1，下载；选项2，打开；选项3，下载并打开</p><h5 id="清除日志"><a href="#清除日志" class="headerlink" title="清除日志"></a>清除日志</h5><p>高亮的Clear Syslog项点击后清除日志</p><p><img src="http://cdn.chuyunt.com/uPic/006tNbRwgw1f6qxroha1xj305p04pq2y.jpg" alt="syslog-clear-menu.png"></p><h4 id="重启和设备关机"><a href="#重启和设备关机" class="headerlink" title="重启和设备关机"></a>重启和设备关机</h4><p><img src="http://cdn.chuyunt.com/uPic/006tNbRwgw1f6qxsm3vdzj308904owek.jpg" alt="restart-shutdown-menu.png"></p><p>Restart重启，Power Off关机</p><p>##参考</p><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/lucy_100/article/details/49820393">文章</a></p>]]></content>
      
      
      <categories>
          
          <category> Cordova </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cordova </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令行创建一个cordova项目</title>
      <link href="/2016-07/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAcordova%E9%A1%B9%E7%9B%AE/"/>
      <url>/2016-07/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAcordova%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="创建cordova项目"><a href="#创建cordova项目" class="headerlink" title="创建cordova项目"></a>创建cordova项目</h2><p>在某个目录下创建cordova项目，打开命令行，</p><p>输入：<code>cordova create sensor com.jkinfo.sensor sensor</code></p><p>创建cordova工程  &lt; 文件夹名 &gt; &lt; 包名 &gt; &lt; app名 &gt;</p><blockquote><p>注意：当第一次创建或编译项目的时候，可能系统会自动下载一些东西，需要一些时间。</p></blockquote><p>文件夹目录：</p><p><img src="http://cdn.chuyunt.com/uPic/72f96cbagw1f5sa2a3kckj207y06mt90.jpg" alt="72f96cbagw1f5sa2a3kckj207y06mt90"></p><ul><li><p>hooks：存放自定义cordova命令的脚本文件。每个project命令都可以定义before和after的Hook，比如：before_build、after_build。没用过，不展开了。</p></li><li><p>platforms：平台目录，各自的平台代码就放在这里，可以放一下平台专属的代码，现在这个目录应该是空的，后面会介绍如何创建平台。</p></li><li><p>plugins：插件目录，安装的插件会放在这里。后面会有专门的文章介绍开发插件。</p></li><li><p><strong>www</strong>：最重要的目录，存放项目主题的HTML5和JS代码的目录。app一开始打开的就是这个目录中index.html文件。</p></li><li><p><strong>config.xml</strong>：主要是cordova的一些配置，比如：项目使用了哪些插件、应用图标icon和启动页面SplashScreen，修改app的版本，名字等信息，还有平台的配置。</p></li></ul><h2 id="添加平台支持"><a href="#添加平台支持" class="headerlink" title="添加平台支持"></a>添加平台支持</h2><p><code>cd</code> 到对应的文件目录，<code>cd sensor</code></p><ul><li>添加平台</li></ul><p>输入：<code>cordova platforms add android（ios）</code></p><p>Android:</p><p><img src="http://cdn.chuyunt.com/uPic/72f96cbagw1f5sa8m5bqaj20lh09nmy7.jpg" alt="72f96cbagw1f5sa8m5bqaj20lh09nmy7"></p><p>iOS:</p><p><img src="http://cdn.chuyunt.com/uPic/72f96cbagw1f5sa7w5t1aj20dl036t9b.jpg" alt="72f96cbagw1f5sa7w5t1aj20dl036t9b"></p><ul><li>移除平台</li></ul><p>输入：cordova platforms rm android  （移除android平台支持）</p><p>也可以通过@版本号，来添加不同版本的android平台，如：</p><p><img src="http://cdn.chuyunt.com/uPic/72f96cbagw1f5saaazgq7j20l80a275c.jpg" alt="72f96cbagw1f5saaazgq7j20l80a275c"></p><p>现在就可以在www文件夹内写自己的js和html代码了。</p><h2 id="添加和删除项目插件"><a href="#添加和删除项目插件" class="headerlink" title="添加和删除项目插件"></a>添加和删除项目插件</h2><ul><li>添加插件</li></ul><p>输入:<code>cordova plugin add cordova-plugin-device</code> (cordova plugin add &lt;插件官方名称&gt;)</p><blockquote><p>插件搜索地址：<a target="_blank" rel="noopener" href="http://cordova.apache.org/plugins/">http://cordova.apache.org/plugins/</a>，也可以通过 <a target="_blank" rel="noopener" href="https://github.com/">github</a> 查找一些第三方插件，</p></blockquote><p>输入：</p><pre><code class="shell"># 这个是扫描二维码插件  (github项目地址)cordova plugin add https://github.com/phonegap/phonegap-plugin-barcodescanner.git</code></pre><ul><li>删除插件</li></ul><p>输入：<code>cordova plugin rm cordova-plugin-device</code>（使用rm和remove都可以）</p><ul><li>插件列表</li></ul><p>输入：<code>cordova plugin list</code>（查看当前安装了哪些插件）</p><h2 id="编译调试程序"><a href="#编译调试程序" class="headerlink" title="编译调试程序"></a>编译调试程序</h2><p>不是每一句代码都需要运行，根据自己的需求进行选择。</p><ul><li><code>cordova install android</code> //将编译好的应用程序安装到模拟器上。</li><li><code>cordova emulate android</code> //在模拟器上运行（前提是创建好AVD）</li><li><code>cordova serve android</code> //在浏览器运行</li><li><code>cordova build android</code> //打包cordova项目到android平台。</li><li><code>cordova run android</code> //通过USB直接安装到真机（该语句已经包括了build命令）</li></ul><p>例如：我现在是手边直接连着测试手机，所以我就会直接用cordova run android</p><p><img src="http://cdn.chuyunt.com/uPic/72f96cbagw1f5sajqxqg0j20j007r0t9.jpg" alt="72f96cbagw1f5sajqxqg0j20j007r0t9"></p><p>中间省略…</p><p><img src="http://cdn.chuyunt.com/uPic/72f96cbagw1f5sajxbxxhj20iz07ct9g.jpg" alt="72f96cbagw1f5sajxbxxhj20iz07ct9g"></p><p>出现LAUNCH SUCCESS则编译成功，已经安装到手机上了。</p>]]></content>
      
      
      <categories>
          
          <category> Cordova </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cordova </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打造一套得心应手的终端工具</title>
      <link href="/2016-07/%E6%89%93%E9%80%A0%E4%B8%80%E5%A5%97%E5%BE%97%E5%BF%83%E5%BA%94%E6%89%8B%E7%9A%84%E7%BB%88%E7%AB%AF%E5%B7%A5%E5%85%B7/"/>
      <url>/2016-07/%E6%89%93%E9%80%A0%E4%B8%80%E5%A5%97%E5%BE%97%E5%BF%83%E5%BA%94%E6%89%8B%E7%9A%84%E7%BB%88%E7%AB%AF%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>iTerm2 是 MAC 下最好的终端工具。可以简单的认为，iTerm2 是配置完毕开箱即用的 tmux。</p><span id="more"></span><h3 id="安装-iTerm2"><a href="#安装-iTerm2" class="headerlink" title="安装 iTerm2"></a>安装 <a target="_blank" rel="noopener" href="http://www.iterm2.com/">iTerm2</a></h3><p>官网下载安装，这里不赘述。</p><h3 id="iTerm-特色功能"><a href="#iTerm-特色功能" class="headerlink" title="iTerm 特色功能"></a>iTerm 特色功能</h3><h5 id="特色快捷键"><a href="#特色快捷键" class="headerlink" title="特色快捷键"></a>特色快捷键</h5><ul><li><p>command+; 根据上下文呼出自动完成窗口，上下键选择</p></li><li><p>全屏 command+enter</p></li><li><p>光标去哪了？command+/ （很少用这个，还是感觉 Zsh 的补全更好用）</p></li><li><p>用鼠标选中某个路径或者某个词汇就自动复制</p></li></ul><h5 id="光标控制"><a href="#光标控制" class="headerlink" title="光标控制"></a>光标控制</h5><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td>ctrl + a</td><td>到行首</td></tr><tr><td>ctrl + e</td><td>行末</td></tr><tr><td>ctrl + u</td><td>删除一行</td></tr><tr><td>⌘ + r（ctrl + l）</td><td>清屏，其实是滚到新的一屏，并没有清空。</td></tr><tr><td>ctrl + r</td><td>搜索命令历史，这个大家都应该很熟悉了</td></tr><tr><td>ctrl + d</td><td>删除当前字符</td></tr><tr><td>ctrl + h</td><td>删除之前的字符</td></tr><tr><td>ctrl + w</td><td>删除光标前的单词</td></tr><tr><td>ctrl + k</td><td>删除到文本末尾</td></tr><tr><td>ctrl + t</td><td>交换光标处文本</td></tr><tr><td>⌘ + —/+/0</td><td>调整字体大小</td></tr><tr><td>ctrl + f/b</td><td>前进后退，相当于左右方向键，但是显然比移开手按方向键更快</td></tr><tr><td>ctrl + p</td><td>上一条命令，相当于方向键上</td></tr></tbody></table><h5 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h5><ul><li>新建窗口：shift + command + d（横向）command + d（竖向）</li><li>关闭窗口：shift + command + w</li><li>前一个窗口：command + `</li><li>后一个窗口：command + ~</li><li>进入窗口 1,2,3：option + command + 编号</li></ul><h5 id="标签页操作"><a href="#标签页操作" class="headerlink" title="标签页操作"></a>标签页操作</h5><ul><li>新建标签页: Command + T</li><li>关闭标签页: Command + W</li><li>前一个标签页: Command + 左方向键，Shift + Command + [</li><li>后一个标签页: Command + 右方向键，Shitf + Command + ]</li><li>进入标签页 1，2，3…: Command + 标签页编号</li><li>Expose 标签页: Option + Command + E（将标签页打撒到全屏，并可以全局搜索所有的标签页）</li></ul><h5 id="面板操作"><a href="#面板操作" class="headerlink" title="面板操作"></a>面板操作</h5><ul><li>垂直分割: Command + D</li><li>水平分割: Shift + Command + D</li><li>前一个面板: Command + [</li><li>后一个面板: Command + ]</li><li>切换到上/下/左/右面板: Option + Command + 上下左右方向键</li></ul><h5 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h5><ul><li>支持自定义全局快捷键用于显示和隐藏 iTerm2 Preference -&gt; Keys －&gt; Show/hide iTerm2 with a system-wide hotkey 打上勾之后</li><li>进入和退出全屏: Command + Enter</li><li>开启和关闭背景半透明: Command + u</li><li>文本选取<ul><li>常见的点击并拖拽方式</li><li>双击选取整个单词</li><li>三击选取整行</li><li>选取某一部分，按住 Shift，再点击某处，可以选取整个矩形内的文本（类似 Windows 下按住 Shift 可以批量选取图标）</li><li>按住 Command + Option，可以用鼠标画出一个矩形，用类似截图的方式选取文本 另外，还可以使用鼠标完成以下操作： 按住 Command 然后点击某个 URL，会在浏览器中打开这个 URL，点击某个文件夹，会在 Finder 里打开这个文件夹（再也不用 open . 啦），点击某个文件名，会打开这个文件（文本文件支持 MacVim，TextMate 和 BBEdit，如果后面跟随一个冒号和行号，文件会在行号处打开，其它格式的文件似乎不能调用默认程序打开） 选取文本之后，按住 Command 同时拖动文本，可以将文本粘贴到目标位置（Drag and Drop） 鼠标中键粘贴（这个太感人了，一下子找回 Linux 的感觉了）</li></ul></li></ul><h5 id="位置书签"><a href="#位置书签" class="headerlink" title="位置书签"></a>位置书签</h5><p>在当前会话中按 Command + Shift + m 可以保存当前位置，之后可以按 Command + Shift + j 跳回这个位置。</p><h5 id="粘贴历史"><a href="#粘贴历史" class="headerlink" title="粘贴历史"></a>粘贴历史</h5><p>使用 Command + Shift + h 可以呼出粘贴历史，支持模糊检索。还可以设置将粘贴历史保存在磁盘上（Preferences -&gt; General）</p><h5 id="即时回放"><a href="#即时回放" class="headerlink" title="即时回放"></a>即时回放</h5><p>使用 Command + Opt + b 打开即时回放，按 Esc 退出。即时回放可以记录终端输出的状态，让你“穿越时间”查看终端内容。默认每个会话最多储存 4MB 的内容，可以在设置中更改（Preferences -&gt; Genernal -&gt; Instant Replay）。</p><h5 id="窗口状态"><a href="#窗口状态" class="headerlink" title="窗口状态"></a>窗口状态</h5><p>通过 Window -&gt; Save Window Arrangement 可以保存当前窗口状态的快照，包括打开的窗口，标签页和面板。通过 Window -&gt; Restore Window Arrangement 还原。还可以在 Preferences -&gt; General -&gt; Open saved window arrangement 中设置在启动 iTerm2 时自动恢复窗口状态</p><h5 id="修改快捷键"><a href="#修改快捷键" class="headerlink" title="修改快捷键"></a>修改快捷键</h5><p>在 iTerm2 下最不能接受的应该就是，不能使用 Command + Delete 键。在日常使用中特别影响效率，所以这里可以根据自己的使用习惯，加一些自定义快捷键，就能解决。</p><ul><li>删除一整行：Action 选择 Send Hex Code： 输入： 0x15</li><li>删除一个字：Action 选择 Send Hex Code： 输入： 0x17</li><li>跳到行头：Action 选择 Send Hex Code： 输入： 0x01</li><li>跳到行尾：Action 选择 Send Hex Code： 输入： 0x05</li><li>跳到前一個字：Action 选择 Send Escape Sequence： 输入： f</li><li>跳到后一個字：Action 选择 Send Escape Sequence： 输入： b</li></ul><p><img src="https://cdn.chuyunt.com/Snipaste_2023-09-03_21-44-08.png"></p><h2 id="让它变得好用"><a href="#让它变得好用" class="headerlink" title="让它变得好用"></a>让它变得好用</h2><h3 id="安装-homebrew"><a href="#安装-homebrew" class="headerlink" title="安装 homebrew"></a>安装 <a target="_blank" rel="noopener" href="https://brew.sh/index_zh-cn">homebrew</a></h3><pre><code class="shell">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;# 国内源/bin/bash -c &quot;$(curl  -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</code></pre><p><strong>Homebrew 的使用</strong></p><ul><li>安装软件：brew install 软件名，例：brew install wget</li><li>搜索软件：brew search 软件名，例：brew search wget</li><li>卸载软件：brew uninstall 软件名，例：brew uninstall wget</li><li>更新所有软件：brew update</li></ul><h3 id="安装并切换成-zsh"><a href="#安装并切换成-zsh" class="headerlink" title="安装并切换成 zsh"></a>安装并切换成 zsh</h3><blockquote><p>Zsh 和 bash 一样，是一种 Unix shell，大多数 Linux 发行版都默认使用 bash shell。但 Zsh 有强大的自动补全参数和自定义配置功能等等。</p></blockquote><pre><code class="shell">chsh -s bin/zsh</code></pre><p>如果哪天想切回 bash</p><pre><code class="shell">chsh -s bin/bash</code></pre><p>然后重新启动 iTerm2，zsh 就已经被配置成默认的 shell 了。</p><h3 id="安装-oh-my-zsh"><a href="#安装-oh-my-zsh" class="headerlink" title="安装 oh-my-zsh"></a>安装 <a target="_blank" rel="noopener" href="http://ohmyz.sh/">oh-my-zsh</a></h3><p>执行下面命令：</p><pre><code class="shell">sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</code></pre><h3 id="开启插件"><a href="#开启插件" class="headerlink" title="开启插件"></a>开启插件</h3><p>在<code>~/.oh-my-zsh/plugins/</code>中已经自带了很多插件，只是没有激活而已，我们可以根据下面的插件激活方式进行激活。</p><p>插件介绍： <a target="_blank" rel="noopener" href="https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins">https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins</a></p><p>打开.zshrc 文件，修改<code>plugins</code></p><pre><code class="bash"># 命令行执行open ~/.zshrc# 根据自己需求，找到plugins配置项，修改成下面：plugins=(git adb autojump branch colored-man-pages command-not-found common-aliases encode64 extract frontend-search git-flow history npm nvm npx osx react-native sudo vscode yarn zsh-interactive-cd)# 命令行执行source ~/.zshrc</code></pre><p>这样自带的插件已开启了</p><h3 id="安装其他插件"><a href="#安装其他插件" class="headerlink" title="安装其他插件"></a>安装其他插件</h3><p><strong>zsh-syntax-highlighting</strong></p><blockquote><p>高亮你的 zsh 可用命令</p></blockquote><pre><code class="shell">$ cd ~/.oh-my-zsh/custom/plugins       # 打开插件的文件夹$ git clone git://github.com/zsh-users/zsh-syntax-highlighting.git   # 克隆插件项目</code></pre><p>打开.zshrc 文件，插件到 plugin 中</p><p>plugins=( [plugins…] zsh-syntax-highlighting)</p><pre><code class="shell">source ~/.zshrc    #重新加载.zshrc的修改</code></pre><p><strong>autojump</strong></p><blockquote><p>autojump 就是通过记录你在 history 中的行为把你访问过的文件夹路径都 cache 下来</p></blockquote><pre><code class="shell">brew install autojump</code></pre><p>打开.zshrc 文件，插件到 plugin 中</p><p>plugins=( [plugins…] autojump)</p><p>将下面命令加到<code>.zshrc</code>最后</p><pre><code class="shell">[[ -s $(brew --prefix)/etc/profile.d/autojump.sh ]] &amp;&amp; . $(brew --prefix)/etc/profile.d/autojump.sh</code></pre><pre><code class="shell">source ~/.zshrc    #重新加载.zshrc的修改</code></pre><blockquote><p>使用 autojump 的缩写 <code>j</code>，<code>cd</code> 命令进入 <code>~/user/github/Youthink</code> 文件夹，<br>下一次再想进入 <code>Yourhink</code> 文件夹的时候，直接 <code>j youthink</code> 即可或者只输入一部分 <code>j youth</code> 都行</p></blockquote><p>删除无效路径</p><p><code>j --purge 无效路径</code></p><h3 id="其他功能-1"><a href="#其他功能-1" class="headerlink" title="其他功能"></a>其他功能</h3><ul><li><p>命令历史记录</p><ul><li>一旦在 shell 敲入正确命令并能执行后，shell 就会存储你所敲入命令的历史记录（存放在~/.zsh_history 文件中），方便再次运行之前的命令。可以按方向键 ↑ 和 ↓ 来查看之前执行过的命令</li><li>可以用 !! 来执行上一条命令</li><li>使用 ctrl-r 来搜索命令历史记录</li></ul></li><li><p>命令和文件补全(按 tab 键)</p></li><li><p>命令别名</p><ul><li>可以简化命令输入，在 .zshrc 中添加 alias shortcut=’this is the origin command’ 一行就相当于添加了别名</li><li>在命令行中输入 alias 可以查看所有的命令别名</li></ul></li></ul><p>一些比较好用的设置</p><pre><code class="shell">alias cls=&#39;clear&#39;alias ll=&#39;ls -l&#39;alias la=&#39;ls -a&#39;alias grep=&quot;grep --color=auto&quot;alias -s html=&#39;vim&#39;   # 在命令行直接输入后缀为 html 的文件名，会在 Vim 中打开alias -s rb=&#39;vim&#39;     # 在命令行直接输入 ruby 文件，会在 Vim 中打开alias -s py=&#39;vim&#39;      # 在命令行直接输入 python 文件，会用 vim 中打开，以下类似alias -s js=&#39;vim&#39;alias -s c=&#39;vim&#39;alias -s java=&#39;vim&#39;alias -s txt=&#39;vim&#39;alias -s gz=&#39;tar -xzvf&#39; # 在命令行直接输入后缀为 gz 的文件名，会自动解压打开alias -s tgz=&#39;tar -xzvf&#39;alias -s zip=&#39;unzip&#39;alias -s bz2=&#39;tar -xjvf&#39;</code></pre><h3 id="Git-插件"><a href="#Git-插件" class="headerlink" title="Git 插件"></a>Git 插件</h3><p>在进入一个 git 文件夹后会切换显示的模式（不过需要配合字体才展示，下面会讲到）：</p><p><img src="http://cdn.chuyunt.com/uPic/65e4f1e6gw1f7jvh758m6j20oe0as0ws.jpg"></p><p>常用命令</p><table><thead><tr><th>Alias</th><th>Command</th></tr></thead><tbody><tr><td>gaa</td><td>git add –all</td></tr><tr><td>gb</td><td>git branch</td></tr><tr><td>gcam</td><td>git commit -a -m</td></tr><tr><td>gcf</td><td>git config –list</td></tr><tr><td>gl</td><td>git pull</td></tr><tr><td>gp</td><td>git push</td></tr><tr><td>gr</td><td>git remote</td></tr><tr><td>gra</td><td>git remote add</td></tr><tr><td>gst</td><td>git status</td></tr></tbody></table><p>自带大部分 git 命令的缩写，命令内容可以参考 <code>~/.oh-my-zsh/plugins/git/git.plugin.zsh</code></p><p><code>Oh My Zsh </code>提供了一套系统别名（alias），来达到相同的功能。比如 gst 作为 git status 的别名。而且 Git 插件是 Oh My Zsh 默认启用的，相当于你使用了 Oh My Zsh，你就拥有了一套高效率的别名，而且还是全球通用的。</p><p>完整列表请参考：<a target="_blank" rel="noopener" href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git">https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git</a>或者输入<code>alias | grep git</code>命令</p><h3 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h3><ol><li>连按两次 Tab 会列出所有的补全列表并直接开始选择，补全项可以使用 ctrl+n/p/f/b 上下左右切换</li><li>更智能的历史命令。在用或者方向上键查找历史命令时，zsh 支持限制查找。比如，输入 ls,然后再按方向上键，则只会查找用过的 ls 命令。而此时使用则会仍然按之前的方式查找，忽略 ls</li><li>智能跳转，安装了 autojump 之后，zsh 会自动记录你访问过的目录，通过 j 目录名 可以直接进行目录跳转，而且目录名支持模糊匹配和自动补全，例如你访问过 hadoop-1.0.0 目录，输入 j hado 即可正确跳转。j –stat 可以看你的历史路径库。</li><li>目录浏览和跳转：输入 d，即可列出你在这个会话里访问的目录列表，输入列表前的序号，即可直接跳转。</li><li>在当前目录下输入 .. 或 … ，或直接输入当前目录名都可以跳转，你甚至不再需要输入 cd 命令了。在你知道路径的情况下，比如 /usr/local/bin 你可以输入 cd /u/l/b 然后按进行补全快速输入</li><li>通配符搜索：ls -l **/*.sh，可以递归显示当前目录下的 shell 文件，文件少时可以代替 find。使用 **/ 来递归搜索</li><li>在 .zshrc 中添加 setopt HIST_IGNORE_DUPS 可以消除重复记录，也可以利用 <code>sort -t &quot;;&quot; -k 2 -u ~/.zsh_history | sort -o ~/.zsh_history</code> 手动清除</li></ol><h2 id="让它变得好看"><a href="#让它变得好看" class="headerlink" title="让它变得好看"></a>让它变得好看</h2><h3 id="安装-Powerline"><a href="#安装-Powerline" class="headerlink" title="安装 Powerline"></a>安装 <a target="_blank" rel="noopener" href="http://powerline.readthedocs.io/en/latest/installation.html">Powerline</a></h3><blockquote><p>Powerline 是用 Python 写的脚本可以美化终端</p></blockquote><h5 id="1-安装-Python-2-X"><a href="#1-安装-Python-2-X" class="headerlink" title="1. 安装 Python 2.X"></a>1. 安装 Python 2.X</h5><p>因为 Powerline 是用 Python 写的脚本，所以我们必须确保在安装 Powerline 我们的 Mac 里面已经安装了 Python（一般来说 Mac 会自带 Python 2.X）</p><pre><code class="shell">$ python -VPython 2.7.10# 我们可以在终端里面输入下面的代码来检查 Python 版本，若此命令没有返回任何讯息说明你的 Mac 里面没有安装 Python。</code></pre><h5 id="2-安装-pip"><a href="#2-安装-pip" class="headerlink" title="2. 安装 pip"></a>2. 安装 pip</h5><p>安装 Powerline 的方法有很多种，我们可以通过 pip 或者 git 等工具，我推荐使用 pip，</p><blockquote><p>由于我还没有安装过 <code>pip</code> ， 所以先执行以下命令安装：</p></blockquote><pre><code class="shell">$ sudo easy_install pip# 或者执行下面代码安装$ wget https://bootstrap.pypa.io/get-pip.py -O - | python</code></pre><h5 id="3-检查-Powerline"><a href="#3-检查-Powerline" class="headerlink" title="3. 检查 Powerline"></a>3. 检查 Powerline</h5><p>用 pip 安装 Powerline</p><pre><code class="shell">$ pip show powerline-status  # 检查是否已经安装Powerline# 如果以上命令执行后，如果出现如下信息，则说明已安装，可跳过下一步。如果没有任何反应说明没有安装，则进行下一步。</code></pre><p><strong>Powerline 信息</strong></p><pre><code class="shell">--Metadata-Version: 1.1Name: powerline-statusVersion: 2.2Summary: The ultimate statusline/prompt utility.Home-page: https://github.com/powerline/powerlineAuthor: Kim SilkebaekkenAuthor-email: kim.silkebaekken+vim@gmail.comLicense: MITLocation: /Users/mac/Library/Python/2.7/lib/python/site-packages #被安装到哪個路径Requires:# 以我的例子，我的使用者名称是 mac# 所以會安装到 /Users/mac/Library/Python/2.7/lib/python/site-packages 目录底下</code></pre><h5 id="4-安装-Powerline"><a href="#4-安装-Powerline" class="headerlink" title="4. 安装 Powerline"></a>4. 安装 Powerline</h5><p>(由于权限问题，无法安装到系统目录下，所以我加上了 –user 选项，选择安装到当前用户目录下)</p><pre><code class="shell">$ pip install --user powerline-status</code></pre><ul><li>配置.bash_profile(如果是已经根据上面步骤，将 bash 切换成 zsh 的，跳过此处，配置.zshrc 就可以了)</li></ul><p>创建、配置 <code>.bash_profile</code> 文件（mac 默认的配置文件，没有的话需要新建一个）让终端每次启动的时候自动运行 Powerline 脚本，新建如下：</p><pre><code class="shell">cd ~ &amp;&amp; l -h# 输入上述命令，查看文件夹下是否有 .bash_profile 文件，没有的话执行下面命令, 如果有就跳过下一步，touch .bash_profile  # 创建 .bash_profile 文件open .bash_profile   # 打开文件</code></pre><ul><li>配置 .zshrc</li></ul><pre><code class="shell">open ~/.zshrc</code></pre><p>只需将下面代码（其实就上面打印出来的安装路径）修改后，复制到你的 <code>bash_profile </code>或者<code>.zshrc</code>文件里就可以啦：</p><p><code>. /Users/[你的用户名]/Library/Python/2.7/lib/python/site-packages/powerline/bindings/bash/powerline.sh</code></p><p><strong>需要注意的是最开始的 ‘.’ 和 ‘/powerline/…’ 中间是以空格分开的。</strong></p><pre><code class="shell">source ~/.zshrc # 保存后执行</code></pre><p>这里也有可能出现“powerline/bindings/bash/../../../scripts/powerline-config:: No such file or directory”的报错。原因没有将 powerline 的相关命令添加到环境变量，可以使用软链接解决:</p><p>则需要将/Users/[用户名]/Library/Python/2.7/bin 加入到 PATH 中，如下：</p><pre><code class="shell">export PATH=/Users/[你的用户名]/Library/Python/2.7/bin:$PATH. /Users/[你的用户名]/Library/Python/2.7/lib/python/site-packages/powerline/bindings/bash/powerline.sh</code></pre><pre><code class="shell">source ~/.zshrc # 保存后执行</code></pre><h5 id="5-更换主题"><a href="#5-更换主题" class="headerlink" title="5. 更换主题"></a>5. 更换主题</h5><p>下载 agnoster 主题，同样在任何目录下，执行下列命令</p><pre><code class="shell">$ cd ~$ git clone https://github.com/fcamblor/oh-my-zsh-agnoster-fcamblor.git$ open oh-my-zsh-agnoster-fcamblor/</code></pre><p>打开文件夹，双击运行 install 文件，主题将安装到<code>~/.oh-my-zsh/themes</code>目录下</p><pre><code class="shell">open ~/.zshrc  # 打开.zshrc</code></pre><p>找到<code>ZSH_THEME</code>字段，改成：<code>ZSH_THEME=&quot;agnoster&quot;</code></p><pre><code class="shell">source ~/.zshrc # 保存后执行</code></pre><p><img src="http://cdn.chuyunt.com/uPic/1816409-20ef0157329eb98f.png"></p><h5 id="6-安装-Powerline-字体"><a href="#6-安装-Powerline-字体" class="headerlink" title="6. 安装 Powerline 字体"></a>6. 安装 Powerline 字体</h5><p>通过 git clone 来下载 powerline 字体，在任意目录下，执行下列命令</p><pre><code class="shell">$ cd ~$ git clone https://github.com/Lokaltog/powerline-fonts.git$ cd powerline-fonts/ &amp;&amp; ./install.sh</code></pre><p>安装完成后，提示所有字体均已下载到/Users/mac/Library/Fonts 路径下，如下提示：</p><pre><code>All Powerline fonts installed to /Users/mac/Library/Fonts</code></pre><p>这样就说明字体库安装完了。</p><p>接着打开 iTerm 2<code>Preferences</code>=&gt;<code>Profile</code>=&gt;<code>Text</code>，找到<code>Font</code>和<code>Non-ASCII Font</code>的字体都设置成 带有<code>Powerline</code> 的字体，我这里设置的字体是<code>12pt Meslo LG S DZ Regular for Powerline</code>，大家可以根据喜好选择，只要是 powerline 字体就可以。</p><p><img src="http://cdn.chuyunt.com/uPic/65e4f1e6gw1f7j33aiji8j20p50f078a.jpg"></p><h5 id="7-安装配色方案"><a href="#7-安装配色方案" class="headerlink" title="7. 安装配色方案"></a>7. 安装配色方案</h5><p>下载配色方案，同样在任何目录下，执行下列命令</p><pre><code class="shell">$ cd ~$ git clone https://github.com/altercation/solarized.git$ open solarized/iterm2-colors-solarized</code></pre><p>然后进入/Users/mac/solarized/iterm2-colors-solarized 下双击 <code>Solarized Dark.itermcolors</code> 和 <code>Solarized Light.itermcolors</code> 两个文件就可以把配置文件导入到 iTerm2 里</p><p>把 iTerm 2 的设置里的<code>Profile</code>=&gt;<code>colors</code>选项卡中里的<code>Load Presets</code>设置为刚刚下载的配色方案就可以了。</p><p><img src="http://cdn.chuyunt.com/uPic/65e4f1e6gw1f7jumenf9ij20po0f00tl.jpg"></p><p>大功告成，看看最后效果吧：</p><p><img src="http://cdn.chuyunt.com/uPic/006tKfTcgy1fd1yxlso6uj30wq0pgju5.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sublime 插件</title>
      <link href="/2016-07/sublime-%E6%8F%92%E4%BB%B6/"/>
      <url>/2016-07/sublime-%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>从去年刚刚接触编程到现在已经一年时间过去了，用 sublime Text 的时间也有大半年了。用 sublime Text 也是因为一个 cordova 项目，从刚开始只用作 txt 文本编辑器，到现在每天都用它来敲代码。感觉自己越来越离不开他它，所以现在对常用的插件做个记录和分享。</p><span id="more"></span><h2 id="package-control"><a href="#package-control" class="headerlink" title="package control"></a>package control</h2><blockquote><p>要在 sublime Text 上安装插件，那就离不开 package control，它是插件的安装器，其实自身也是个插件。</p></blockquote><p>安装方法：从菜单 View - Show Console 或者 ctrl + ~ 快捷键，调出 console。将以下 Python 代码粘贴进去并 enter 执行，不出意外即完成安装。以下提供 ST3 和 ST2 的安装代码：（ios 和 window 一样。）</p><p><strong>Sublime Text 3：</strong></p><pre><code>import urllib.request,os,hashlib; h = &#39;df21e130d211cfc94d9b0905775a7c0f&#39; + &#39;1e3d39e33b79698005270310898eea76&#39;; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &#39;http://packagecontrol.io/&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &#39;wb&#39; ).write(by)</code></pre><p><strong>Sublime Text 2：</strong></p><pre><code>import urllib2,os,hashlib; h = &#39;df21e130d211cfc94d9b0905775a7c0f&#39; + &#39;1e3d39e33b79698005270310898eea76&#39;; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( &#39;http://packagecontrol.io/&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), &#39;wb&#39; ).write(by) if dh == h else None; print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h) if dh != h else &#39;Please restart Sublime Text to finish installation&#39;)</code></pre><h2 id="插件安装方法"><a href="#插件安装方法" class="headerlink" title="插件安装方法"></a>插件安装方法</h2><ul><li><p>按下 <code>ctrl+shift+p</code>/<code>command+shift+p</code>。此时会输出一个输入框， 输入 install。</p></li><li><p>选择<code>package contrl： install package</code> 回车 ，需要稍定一会儿，右下角状态栏会显示正在连接的提示文字。</p><blockquote><p>使用 sublime 时注意看右下角状态栏，很多插件的提示信息都显示在这里，这个状态栏很小，初次使用的人都有可能没有注意到它</p></blockquote></li><li><p>如果要卸载插件， <code>ctrl+shift+p</code>/<code>command+shift+p</code> 输入 <code>remove</code>， 选择<code>package control:remove package</code> 然后再选择已安装的插件， 回车即可卸载。</p><blockquote><p>备注：如果 package control 安装插件时失败了， 我们可以采用手动安装的方式， 在 google 上去搜索插件， 下载插件的源代码。在 sublime 的菜单栏点击 preferences-&gt;Browse package.. 此时会打开插件目录。然后把你下载的插件源代码复制进去就可以</p></blockquote></li><li><p>可以通过这个网址<a target="_blank" rel="noopener" href="https://packagecontrol.io/">https://packagecontrol.io/</a>来查找自己喜欢的插件，了解插件的详细信息。</p></li></ul><h2 id="常用插件推荐"><a href="#常用插件推荐" class="headerlink" title="常用插件推荐"></a>常用插件推荐</h2><h3 id="通用类"><a href="#通用类" class="headerlink" title="通用类"></a>通用类</h3><p><strong>1. <a target="_blank" rel="noopener" href="https://github.com/titoBouzout/SideBarEnhancements">Sidebar Enhancements</a></strong><br>增强侧边栏的插件</p><p><img src="http://cdn.chuyunt.com/uPic/006tKfTcgw1f6gwprvce8j309e0kz406.jpg" alt="屏幕快照 2016-08-03 22.03.04.png"></p><p><strong>2. All Autocomplete</strong></p><p>Sublime Text 默认的 Autocomplete 功能只考虑当前的文件，而 AllAutocomplete 插件会搜索所有打开的文件来寻找匹配的提示词；</p><p><strong>3. Auto Filename</strong> 自动补全文件路径</p><p><strong>4. clickableURLs</strong> url 可点击</p><p><strong>5. DeleteBlankLines</strong> 删除空白行</p><pre><code>快速鍵：刪除選取範圍內的空白行Mac：Ctrl + Alt + DeleteWin/Linux：Ctrl + Alt + Backspace快速鍵：刪除剩餘的空白行Mac：Ctrl + Alt + Shift + DeleteWin/Linux：Ctrl + Alt + Shift + Backspace</code></pre><p><strong>6. Insert Nums</strong> 用于添加可递增的数字</p><h3 id="代码类"><a href="#代码类" class="headerlink" title="代码类"></a>代码类</h3><p><strong>1. <a target="_blank" rel="noopener" href="https://github.com/SublimeCodeIntel/SublimeCodeIntel">Sublime Code Intel</a></strong> 实现代码智能提示和自动完成功能。</p><p>目前该插件支持以下语言：</p><p><code>JavaScript, Mason, XBL, XUL, RHTML, SCSS, Python, HTML, Ruby, Python3, XML, Sass, XSLT, Django, HTML5, Perl, CSS, Twig, Less, Smarty, Node.js, Tcl, TemplateToolkit, PHP</code></p><blockquote><p>PHP:按住 alt+鼠标左键，可以实现自定义函数之间的跳转，方便查找和修改函数内容和读写代码！</p></blockquote><p><strong>2. SublimeLinter</strong> 代码校验工具，检查代码语法是否有错误，并提示。</p><p><a target="_blank" rel="noopener" href="https://gaohaoyang.github.io/2015/03/26/sublimeLinter/">详细步骤</a></p><p><strong>3. HTML-CSS-JS Prettify</strong> HTML+CSS+JAVASCRIPT+JSON 快速格式化</p><p>快捷键：<code>Ctrl+Shift+H/command+shift+H</code></p><p><strong>4. Emmet</strong> 可以快速的编写 HTML、CSS 以及实现其他的功能，<a target="_blank" rel="noopener" href="http://docs.emmet.io/cheat-sheet/">详细语法</a></p><p><strong>5. ConvertToUTF8</strong></p><p>为了支持 sublime 显示非 utf8，如 GBK 等编码的内容</p><p>支持 GBK, BIG5, EUC-KR, EUC-JP, Shift_JIS 等编码的插件</p><p><strong>6. Autoprefixer</strong> 自动添加厂商前缀</p><p>使用方法：按 <code>Ctrl + Shift + P</code>，然后选 <code>Autoprefix CSS</code> 或者设置键盘快捷键 – <code>Preferences &gt; Key Bindings – User</code></p><pre><code class="json">[&#123; &quot;keys&quot;: [&quot;ctrl+alt+x&quot;], &quot;command&quot;: &quot;autoprefixer&quot; &#125;]</code></pre><p>配置：</p><p>打开选项<code>Preferences &gt; Package Settings &gt; Autoprefixer &gt; Settings – User</code></p><p>默认设置：过去 2 个版本（如果 Chrome 30 是最新版的，这款插件自动选 Chrome 28 – 30 的版本来判断否需要前缀）</p><p>配置参数：</p><pre><code>last n versions 支持过去n个版本n% 全球使用率大于百分之 nff &gt; 20 和 ff &gt;= 20 Firefox 20 或者更新none 消灭前缀</code></pre><p><strong>7. DocBlockr</strong> 注释自动完成</p><p>支持 js，php 等多种编程语言的注释自动补全，输入/**回车即可自动补全注释代码，而去支持自动补全注释信息，如 author 等。</p><p><img src="http://cdn.chuyunt.com/uPic/006tKfTcgw1f6gbkwdni1j30cf0aggnb.jpg" alt="20150418165435271753093870.jpg"></p><p><strong>8. Terminal</strong> 从当前文件或根项目文件夹中启动终端</p><p>快捷键是<code>Command+Shift+T</code>，默认是调用自带终端，可以修改为 iterm，要修改插件的设置如下：</p><pre><code class="js">&#123;  // The command to execute for the terminal, leave blank for the OS default  // On OS X the terminal can be set to iTerm.sh to execute iTerm  &quot;terminal&quot;: &quot;iTerm.sh&quot;,  // A list of default parameters to pass to the terminal, this can be  // overridden by passing the &quot;parameters&quot; key with a list value to the args  // dict when calling the &quot;open_terminal&quot; or &quot;open_terminal_project_folder&quot;  // commands  &quot;parameters&quot;: []&#125;</code></pre><p><strong>9. Bracket Highlighter</strong> 代码匹配</p><p>简介：可匹配[], (), {}, “”, ”, <tag></tag>，高亮标记，便于查看起始和结束标记</p><p>使用：点击对应代码即可</p><p><strong>10. SublimeREPL</strong></p><p>功能：允许你在 Sublime Text 中运行各种语言（NodeJS ， Python，Ruby， Scala 和 Haskell 等等）</p><p><a target="_blank" rel="noopener" href="https://github.com/wuub/SublimeREPL">详情链接</a></p><p><strong>11.JavaScript Next</strong> 完美支持 ECMAScript 6</p><p>JavaScript Next 提供了比默认 JavaScript Package 更好的语法高亮，而且他完美支持 ECMAScript 6。</p><p>建议完全使用 JavaScript Next 代替 JavaScript Package。</p><p><strong>12. CSS3</strong> CSS3 语法高亮</p><p>默认安装的 Sublime Text 对 CSS3 的支持让人抓狂，帧动画？别开玩笑了你只会看到一片白色的纯文本一样的代码。</p><p>事实上不光 CSS3，我建议用 CSS3 Package 完全替代原来的 CSS Package 来完成语法高亮。把原来的禁用了吧</p><pre><code>Mac:       cmd+shift+p  -&gt; Package Control: Disable Package -&gt; CSSLinux/Win: ctrl+shift+p -&gt; Package Control: Disable Package -&gt; CSS</code></pre><p><strong>13. <a target="_blank" rel="noopener" href="https://github.com/Monnoroch/ColorHighlighter">Color Highlighter</a></strong> CSS 颜色高亮</p><blockquote><p>Color Highlighter 这个插件会检测 CSS 文件中的颜色码，不论是 Hex 码或者 RGB 码都能很好的显示。</p></blockquote><p>Color Highlighter 能够设置成用背景色或者边框提示颜色，我一般在 Settings 里做这样的设置：</p><pre><code class="js">&#123;  &quot;ha_style&quot;: &quot;filled&quot;,  &quot;icons&quot;: false&#125;//&quot;Filled&quot;, &quot;outlined&quot;, &quot;none&quot;, &quot;colored text&quot; in ST2.//&quot;Filled&quot;, &quot;outlined&quot;, &quot;none&quot;, &quot;underlined&quot; (solid, strippled, squiggly), &quot;colored text&quot; in ST3.</code></pre><p>效果如下：</p><p><img src="http://cdn.chuyunt.com/uPic/006tKfTcgw1f6gchl5fcmj30bj049q38.jpg" alt="Color_Highlighter.jpg"></p><p><strong>14. GitGutter：</strong></p><blockquote><p>实时显示当前工作区的文件与以下四种的区别：</p></blockquote><pre><code>Compare against HEAD(默认选项)Compare against particular branchCompare against particular tagCompare against specific commit</code></pre><p>如果选择默认的第一个选项，就可以实时看到当前的工作区（workplace）相对于最近一次提交（HEAD）的修改。若出现无法工作情况，请先修改用户配置，<code>Preferences &gt; Package Settings &gt; GitGutter &gt; Settings – User</code></p><p>mac 配置：</p><pre><code class="json">&#123;  &quot;git_binary&quot;: &quot;/usr/local/bin/git&quot;,  &quot;non_blocking&quot;: &quot;true&quot;, //解决sublime卡顿问题  &quot;live_mode&quot;: &quot;false&quot; //解决sublime卡顿问题&#125;</code></pre><p>windows 配置：</p><pre><code class="json">&#123;  &quot;git_binary&quot;: &quot;C:/Program Files (x86)/Git/bin/git.exe&quot;&#125;</code></pre><p><strong>15. ESLint</strong></p><blockquote><p>用于检测 JavaScript 代码质量工具</p></blockquote><p><strong>安装</strong></p><p>使用此插件之前要先全局安装<code>eslint</code>：<code>npm install -g eslint</code></p><p><strong>使用：</strong></p><ol><li><p>右键选择<code>ESLint</code>或者使用快捷键：<code>Ctrl + Alt + e (Cmd + Option + e on OSX)</code></p></li><li><p><code>F4</code>: 跳转到下一条错误行；<code>Shift + F4</code> : 跳转到上一条错误行</p></li></ol><p><strong>配置：</strong></p><p>mac：</p><pre><code class="json">&#123;  &quot;node_path&quot;: &quot;/usr/local/bin&quot;,  &quot;node_modules_path&quot;: &quot;/usr/local/lib/node_modules&quot;,  &quot;config_file&quot;: &quot;/Users/mac/code/personal/eslint/.eslintrc.yml&quot;&#125;</code></pre><p>windows:</p><pre><code class="json">&#123;  &quot;node_path&quot;: &quot;C:/Program Files/nodejs&quot;,  &quot;node_modules_path&quot;: &quot;%APPDATA%/npm/node_modules&quot;,  &quot;config_file&quot;: &quot;/path/to/.eslintrc.js&quot;&#125;</code></pre><p><strong>16. sublime Tmpl</strong> 快速生成文件模板</p><p>快捷键：</p><pre><code>ctrl+alt+h //htmlctrl+alt+j //javascriptctrl+alt+c //cssctrl+alt+p //phpctrl+alt+r //rubyctrl+alt+shift+p //python</code></pre><h3 id="写作类"><a href="#写作类" class="headerlink" title="写作类"></a>写作类</h3><p><strong>1. OmniMarkupPreviewer</strong></p><p>Sublime Text 内 Markdown 标签页点击鼠标右键 - 选择 Preview Current Markup in Browser。 或者使用快捷键 (OSX ⌘+⌥+O; Windows, LinuxCtrl+Alt+O) 来预览。</p><p>配置：<code>Sublime Text &gt; Preferences &gt; Package Settings &gt; OmniMarkupPreviewer &gt; Settings - User</code></p><pre><code class="js">&#123;    &quot;renderer_options-MarkdownRenderer&quot;: &#123;        &quot;extensions&quot;: [&quot;tables&quot;, &quot;fenced_code&quot;, &quot;codehilite&quot;]    &#125;&#125;</code></pre><p><strong>2. MarkdownEditing</strong></p><p>MarkdownEditing 是 Markdown 写作者必备的插件，它可以不仅可以高亮显示 Markdown 语法还支持很多编程语言的语法高亮显示。</p><p>快捷键：</p><ul><li>Option + Command + V - 粘贴为链接格式；</li><li>Shift + Command + K - 插入图片。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>1. 更换 Sublime Text 程序图标</strong></p><p>不仅主题可以更换，图标也可以。在<a target="_blank" rel="noopener" href="https://dribbble.com/">Dribbble</a>上有大量重新设计的 Sublime Text 精美图标。更换方法：</p><ol><li>下载一个图标，有.icns 格式的最好。如果没有，用 iConvert 转换之。</li><li>终端执行：open /Applications/Sublime\ Text.app/Contents/Resources/</li><li>替换 Sublime Text 3.icns 或 Sublime Text 2.icns 文件。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sublime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客搭建和配置</title>
      <link href="/2016-07/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
      <url>/2016-07/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>从工作开始，一路过来都是在学习。由于不是计算机专业，所以只能比其他人更勤奋才行。从刚进公司学习 .net，到后来业务需要而接触web前端、cordova、H5等，各种全新的知识给我带了极大的冲击。感觉接触到的知识太乱，天天都是在迷迷糊糊中学了忘，忘了学。这样的过程触使我决定开始做一些备忘，于是就在博客园上开始记录一些东西。用了一段时间后，觉得在博客园上编辑太繁琐，翻出来查看时太麻烦，再加上刚接触Markdown，所以很想直接用Markdown来编辑记录，于是找到了Hexo + GitHub Page建立<a target="_blank" rel="noopener" href="https://lion1ou.github.io/">个人博客</a>。</p><span id="more"></span><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><ul><li>2016.11.07 重新排版总结，添加域名配置、双线部署内容</li><li>2016.07.01 首次整理分享</li></ul><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li><p>硬件：MacBook Pro</p></li><li><p>软件：Git + Node.js + GitHub帐号</p><blockquote><p>以上准备请自行百度，这里不赘述</p></blockquote></li></ul><h2 id="创建GitHub仓库"><a href="#创建GitHub仓库" class="headerlink" title="创建GitHub仓库"></a>创建GitHub仓库</h2><ul><li><p>注册帐号（此步跳过）</p></li><li><p>创建代码库</p><p>  <img src="http://cdn.chuyunt.com/uPic/72f96cbagw1f5rbimjev5j20c9063t8x.jpg"></p></li><li><p>填写名称</p><blockquote><p>名称必须是<code>**.github.io</code>这种格式</p></blockquote><p>  <img src="http://cdn.chuyunt.com/uPic/65e4f1e6gw1f9jptq1saaj20jq0hbdhp.jpg"></p></li><li><p>填写完后，创建成功后出现如下页面：</p><p>  <img src="http://cdn.chuyunt.com/uPic/65e4f1e6jw1f9jpvmep5cj20nh0hgtbb.jpg"></p><blockquote><p>到这里github仓库已经建好了。接下来是本地部分了。</p></blockquote></li></ul><h2 id="Hexo项目创建"><a href="#Hexo项目创建" class="headerlink" title="Hexo项目创建"></a>Hexo项目创建</h2><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><ul><li><p>在任意文件夹下打开终端，执行  <code>sudo npm install hexo-cli -g</code> 命令，全局安装<code>Hexo</code></p><blockquote><p>在命令行前面多加 <strong>sudo</strong> 是为了获取权限，可能需要输入密码（Mac才需要）</p></blockquote><p>  <img src="http://cdn.chuyunt.com/uPic/65e4f1e6jw1f9jpxzbcsoj20pd04w763.jpg"></p><blockquote><p>安装全局的hexo，可能你会看到一个WARN，但是不用担心，这不会影响你的正常使用。若出现长时间不动作情况，请看最后面。</p></blockquote></li><li><p>安装完后，执行 <code>hexo -v</code> 命令，验证是否安装完成</p><p>  <img src="http://cdn.chuyunt.com/uPic/72f96cbagw1f5rh2p9z19j207905v74u.jpg"></p><blockquote><p>安装过程中，若出现未提及错误，请查阅<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">官方文档</a></p></blockquote></li></ul><h3 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h3><ul><li><p><code>cd</code>到自己认为合适位置，执行<code>hexo init lion1ou</code></p><p>  <img src="http://cdn.chuyunt.com/uPic/65e4f1e6gw1f9jq5rt5hcj20e903et9l.jpg"></p><blockquote><p>在该文件夹下创建<code>lion1ou</code>文件夹，并初始化hexo项目</p></blockquote></li><li><p>然后再接着执行 <code>npm install</code></p><blockquote><p><code>npm install</code>将会自动安装该项目所需要的组件和依赖，只需要等待npm操作即可</p></blockquote><p>  文件夹目录中最少含有以下几项：</p><p>  <img src="http://cdn.chuyunt.com/uPic/72f96cbagw1f6elz6tq9lj204h04bt8s.jpg"></p></li></ul><h3 id="使用Hexo"><a href="#使用Hexo" class="headerlink" title="使用Hexo"></a>使用Hexo</h3><ul><li><p>在<code>source/_posts</code>目录下编辑Markdown文件</p></li><li><p>执行 <code>hexo generate</code>命令生成静态文件，可简写成 <code>hexo g</code></p><p>  <img src="http://cdn.chuyunt.com/uPic/72f96cbagw1f5ridnsopmj209n073wgm.jpg"></p></li><li><p>执行 <code>hexo server</code> 启动Hexo自带服务，可简写成 <code>hexo s</code></p><blockquote><p>默认情况下，访问网址为： <a target="_blank" rel="noopener" href="http://localhost:4000/">http://localhost:4000/</a>浏览到你刚建完的本地静态网站。</p></blockquote><p>  <img src="http://cdn.chuyunt.com/uPic/65e4f1e6gw1f9jqf11sdgj20yj0dhtbx.jpg"></p><blockquote><p>到这里hexo项目本地项目也已经创建完成了。</p></blockquote></li></ul><h2 id="部署网站"><a href="#部署网站" class="headerlink" title="部署网站"></a>部署网站</h2><ul><li><p>修改根目录下 <code>_config.yml</code> 文件</p><blockquote><p>将文件下拉到最后，修改为以下格式的代码</p></blockquote><pre><code>  deploy:    type: git    repo: git@github.com:lion1ou/lion1ou.github.io.git    # 在github对应项目中复制，选择shh和http都行    branch: master</code></pre><blockquote><p>以上是部署前必须配置的，其他配置详见<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/configuration.html">官网文档</a></p></blockquote></li><li><p>安装部署Github的依赖，即执行<code>npm install hexo-deployer-git --save</code>命令</p></li><li><p>安装后执行<code>hexo deploy</code>，部署代码至Github</p><blockquote><p>如出现帐号验证提示，请按照提示，分别输入自己的Github账号用户名和密码，开始提交。如需配置Github SHH验证，请参见<a href="http://lion1ou.tech/2016/09/11/">git学习</a></p></blockquote><p>  <img src="http://cdn.chuyunt.com/uPic/72f96cbagw1f5rie1aos8j20gs03y0ti.jpg"></p><blockquote><p>部署完毕后，访问<a target="_blank" rel="noopener" href="https://lion1ou.github.io/">https://lion1ou.github.io</a>（更换为自己的地址）</p></blockquote></li></ul><h2 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h2><ul><li><p>执行<code>hexo new &#39;article title&#39;</code> </p><p>  <img src="http://cdn.chuyunt.com/uPic/65e4f1e6gw1f9jqwghl7nj20e6011mxf.jpg"></p><blockquote><p>source/_posts目录下，创建一篇以「article title」为题目的Markdown文件，供你编辑。</p></blockquote></li><li><p>新建的文件头会有一些yml信息，如下所示：</p><p>  <img src="http://cdn.chuyunt.com/uPic/72f96cbagw1f5rfrsnu6vj20rs07240p.jpg"></p></li><li><p>编辑完成后，执行<code>hexo g</code></p><p>  <img src="http://cdn.chuyunt.com/uPic/65e4f1e6gw1f9js9ab9swj20dd02mdg7.jpg"></p><blockquote><p>将该文件渲染成浏览器能识别的HTML网页和其他Hexo附带文件。</p></blockquote></li><li><p>再执行<code> hexo d</code></p><p>  <img src="http://cdn.chuyunt.com/uPic/65e4f1e6gw1f9jsa618bhj20cn02v0td.jpg"></p><blockquote><p>将渲染后文件部署至Github，这样就完成了一个操作。</p></blockquote></li></ul><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><ul><li><p>在<a target="_blank" rel="noopener" href="http://hexo.io/themes/">Hexo Themes</a>中自己选择喜欢的主题，复制github地址</p><blockquote><p>这里以<a target="_blank" rel="noopener" href="http://theme-next.iissnan.com/">Next主题</a>为例</p></blockquote></li><li><p>执行 <code>git clone https://github.com/iissnan/hexo-theme-next.git themes/next</code></p><blockquote><p>将主题克隆到themes/next目录下</p></blockquote></li><li><p>修改根目录下的<code>_config.yml</code>文件</p><blockquote><p>将主题配置项修改为：<code>theme: next</code></p></blockquote></li><li><p>然后执行<code>hexo clean</code>、<code>hexo g</code>、<code>hexo d</code>重新部署文件，等待一会儿，再访问<a target="_blank" rel="noopener" href="https://lion1ou.github.io/">https://lion1ou.github.io</a>就能看到新主题的效果了~</p></li></ul><h2 id="域名绑定"><a href="#域名绑定" class="headerlink" title="域名绑定"></a>域名绑定</h2><ul><li><p>域名申请，可以在阿里云注册，本人的<a href="http://lion1ou.tech/">lion1ou.win</a>就是阿里云注册的，25RMB/五年，这里不赘述。</p></li><li><p>source/目录下创建<strong>CNAME</strong>文件(不需要后缀名)，并填入自己注册的域名地址(不需要加www)。</p><p>  <img src="http://cdn.chuyunt.com/uPic/65e4f1e6gw1f9jiy5j30yj20f002u0sm.jpg"></p></li><li><p>部署至Github</p></li><li><p>前往阿里云控制台，找到自己的域名，点击解析</p><p>  <img src="http://cdn.chuyunt.com/uPic/65e4f1e6gw1f9jsdecvxwj20r501ymx9.jpg"></p></li><li><p>添加域名解析，如下图所示（要注意的是记录值：<code>lion1ou.github.io.</code>后面还有一个点）</p><p>  <img src="http://cdn.chuyunt.com/uPic/65e4f1e6gw1f9jsg7jk2hj20uo01vaad.jpg"></p></li><li><p>然后等待一会，再访问<a href="http://lion1ou.tech/">lion1ou.win</a>，就ok了。</p></li></ul><h2 id="双线部署"><a href="#双线部署" class="headerlink" title="双线部署"></a>双线部署</h2><ul><li><p>在 Coding 上创建一个与您的用户名（Global Key）相同的项目。</p></li><li><p>如图选择 Pages 服务，并开启服务</p><p>  <img src="http://cdn.chuyunt.com/uPic/65e4f1e6gw1f9kgh88kaij21kw0gggo5.jpg"></p></li><li><p>修改根目录下 <code>_config.yml</code> 文件</p><pre><code>  deploy:    type: git    repo:       github: git@github.com:lion1ou/lion1ou.github.io.git,master      coding: git@git.coding.net:418120186/418120186.git,coding_pages</code></pre></li><li><p>在source/目录下新建空白文件Staticfile</p><p>  具体的原因的话,可能是coding是用静态的方式部署的,检测到这个的时候就知道你的项目是以静态方式发布的</p></li><li><p>然后执行<code>hexo clean</code>、<code>hexo g</code>、<code>hexo d</code>重新部署文件</p><blockquote><p>若部署过程中出现未提及错误，请参见<a target="_blank" rel="noopener" href="https://coding.net/help/doc/git/ssh-key.html">官方文档</a></p></blockquote></li><li><p>访问<a target="_blank" rel="noopener" href="http://418120186.coding.me/">http://418120186.coding.me/</a></p><blockquote><p>或<a target="_blank" rel="noopener" href="http://418120186.coding.me/418120186">http://418120186.coding.me/418120186</a>都可以看到项目部署完成，出现未提及错误，请参见<a target="_blank" rel="noopener" href="https://coding.net/help/doc/pages/index.html">官方文档</a></p></blockquote></li><li><p>解析域名</p><p>  <img src="http://cdn.chuyunt.com/uPic/65e4f1e6gw1f9nfqwtr5zj21kw06n0ub.jpg"></p><blockquote><p>如上图将coding的地址设置为默认，将github的地址设为海外，coding的记录值是固定的<code>pages.coding.me</code>不用修改。</p></blockquote></li><li><p>绑定域名</p><p>  <img src="http://cdn.chuyunt.com/uPic/65e4f1e6gw1f9nftwnvn5j21h00c675s.jpg"></p><blockquote><p>如上图在coding Pages服务页面，添加域名绑定，然后你就可以通过以上域名访问了。</p></blockquote></li></ul><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><ol><li><p>常见问题</p><blockquote><p>修改配置文件时注意YAML语法，参数冒号:后一定要<strong>留空格</strong></p></blockquote><blockquote><p>中文乱码请修改文件编码格式为UTF-8</p></blockquote></li><li><p>勤学勤练Markdown</p><blockquote><p>本地+云端备份数据是一种习惯</p></blockquote><p> Markdown学习路径 - <a target="_blank" rel="noopener" href="http://wsgzao.github.io/post/markdown/">http://wsgzao.github.io/post/markdown/</a></p></li><li><p>使用性感的文本编辑器</p><blockquote><p>工欲善其事必先利其器</p></blockquote><p> Sublime Text - <a target="_blank" rel="noopener" href="http://pan.baidu.com/share/home?uk=3693847658#category/type=0">http://pan.baidu.com/share/home?uk=3693847658#category/type=0</a></p><p> Cmd Markdown - <a target="_blank" rel="noopener" href="http://www.zybuluo.com/mdeditor">http://www.zybuluo.com/mdeditor</a></p><p> 大神整理的软件 - <a target="_blank" rel="noopener" href="http://wsgzao.github.io/post/windows/#%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8">http://wsgzao.github.io/post/windows/#文本编辑器</a></p></li><li><p>若遇见<strong>卡住</strong>不往下执行现象，更换 <code>npm</code> 为 <code>cnpm</code></p><blockquote><p>cnpm是淘宝提供的npm中国镜像加速，cnpm不仅可以加速npm上包的下载，也提供了镜像加速Node.js 源码的下载。<a target="_blank" rel="noopener" href="https://npm.taobao.org/">https://npm.taobao.org/</a></p></blockquote><p> <code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p><p> 安装完后，只需把上面<code>npm</code>命令行都改为<code>cnpm</code>，即下面这种形式，下载速度会有显著提升。</p><p> <code>cnpm install -g hexo-cli</code></p></li><li><p>今天在使用hexo写博客的时候发现使用hexo命令居然出现错误：</p></li></ol><pre><code>Error: Module version mismatch. Expected 48, got 46.    at Error (native)    at Object.Module._extensions..node (module.js:597:18)    at Module.load (module.js:487:32)    at tryModuleLoad (module.js:446:12)    at Function.Module._load (module.js:438:3)    at Module.require (module.js:497:17)    at require (internal/module.js:20:19)    at Object.&lt;anonymous&gt; (/Users/lionluo/code/personal/lion1ou/node_modules/._dtrace-provider@0.8.1@dtrace-provider/dtrace-provider.js:17:23)    at Module._compile (module.js:570:32)    at Object.Module._extensions..js (module.js:579:10)    at Module.load (module.js:487:32)    at tryModuleLoad (module.js:446:12)    at Function.Module._load (module.js:438:3)    at Module.require (module.js:497:17)    at require (internal/module.js:20:19)    at Object.&lt;anonymous&gt; (/Users/lionluo/code/personal/lion1ou/node_modules/._bunyan@1.8.10@bunyan/lib/bunyan.js:79:18)    at Module._compile (module.js:570:32)    at Object.Module._extensions..js (module.js:579:10)    at Module.load (module.js:487:32)    at tryModuleLoad (module.js:446:12)    at Function.Module._load (module.js:438:3)    at Module.require (module.js:497:17)&#123; Error: Cannot find module &#39;./build/default/DTraceProviderBindings&#39;    at Function.Module._resolveFilename (module.js:469:15)    at Function.Module._load (module.js:417:25)    at Module.require (module.js:497:17)    at require (internal/module.js:20:19)    at Object.&lt;anonymous&gt; (/Users/lionluo/code/personal/lion1ou/node_modules/._dtrace-provider@0.8.1@dtrace-provider/dtrace-provider.js:17:23)    at Module._compile (module.js:570:32)    at Object.Module._extensions..js (module.js:579:10)    at Module.load (module.js:487:32)    at tryModuleLoad (module.js:446:12)    at Function.Module._load (module.js:438:3)    at Module.require (module.js:497:17)    at require (internal/module.js:20:19)    at Object.&lt;anonymous&gt; (/Users/lionluo/code/personal/lion1ou/node_modules/._bunyan@1.8.10@bunyan/lib/bunyan.js:79:18)    at Module._compile (module.js:570:32)    at Object.Module._extensions..js (module.js:579:10)    at Module.load (module.js:487:32)    at tryModuleLoad (module.js:446:12)    at Function.Module._load (module.js:438:3)    at Module.require (module.js:497:17)    at require (internal/module.js:20:19)    at Object.&lt;anonymous&gt; (/Users/lionluo/code/personal/lion1ou/node_modules/._hexo-log@0.1.2@hexo-log/lib/log.js:3:14)    at Module._compile (module.js:570:32) code: &#39;MODULE_NOT_FOUND&#39; &#125;&#123; Error: Cannot find module &#39;./build/Debug/DTraceProviderBindings&#39;    at Function.Module._resolveFilename (module.js:469:15)    at Function.Module._load (module.js:417:25)    at Module.require (module.js:497:17)    at require (internal/module.js:20:19)    at Object.&lt;anonymous&gt; (/Users/lionluo/code/personal/lion1ou/node_modules/._dtrace-provider@0.8.1@dtrace-provider/dtrace-provider.js:17:23)    at Module._compile (module.js:570:32)    at Object.Module._extensions..js (module.js:579:10)    at Module.load (module.js:487:32)    at tryModuleLoad (module.js:446:12)    at Function.Module._load (module.js:438:3)    at Module.require (module.js:497:17)    at require (internal/module.js:20:19)    at Object.&lt;anonymous&gt; (/Users/lionluo/code/personal/lion1ou/node_modules/._bunyan@1.8.10@bunyan/lib/bunyan.js:79:18)    at Module._compile (module.js:570:32)    at Object.Module._extensions..js (module.js:579:10)    at Module.load (module.js:487:32)    at tryModuleLoad (module.js:446:12)    at Function.Module._load (module.js:438:3)    at Module.require (module.js:497:17)    at require (internal/module.js:20:19)    at Object.&lt;anonymous&gt; (/Users/lionluo/code/personal/lion1ou/node_modules/._hexo-log@0.1.2@hexo-log/lib/log.js:3:14)    at Module._compile (module.js:570:32) code: &#39;MODULE_NOT_FOUND&#39; &#125;</code></pre><p>虽然也能运行hexo，但是想到每次看到这种东西心里都不爽，所以坚决要解决它。最后经过各种查资料发现是node的版本问题，由于前段时间升级了node版本，以至于现在的node版本是最新的6.3.1。由于新版本中有的模块不支持，所有我们还是按照流行版吧(node4-lts)</p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
